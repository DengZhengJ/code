



## 壹、项目定位

```shell
公司项目 //家用机器人 或 园区无人车

上层应用 //设备上界面(QT)  手机电脑APP界面(H5)   后台数据服务（阿里云）
底层应用 //AI落地（模型压缩） GPU cuda加速
内核驱动 //视觉: 摄像头 + wifi/蓝牙 + 网卡+ GPU
        //小车: i2c+ pwm +马达+oled
```

### 1、内核驱动课程思维导图

![3](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\3.png)

### 2、自己总结的笔记

```c
//常用指令
sudo mount /dev/sdb1 bsp 
pci enum;pci
sudo ifconfig eth0 192.168.5.8 up
ssh yhbd@192.168.0.148(一定要记得切换WIFI模式)
    
ARMV8 64位汇编 jeston nano
ARM公司主要设计ARM系统的RISC处理器内核
jeston nano是4核Cortex-A57
jeston nano 多核异构处理器
CPU 核心适用于通用计算任务，GPU 核心适用于图形处理和并行计算
CPU(ARM A57)负责复杂逻辑运算的处理
GPU负责大数据的同时并行运算
CPU里分为三部分：ALU运算器运算；控制器取址，译码；寄存器暂存数值
现如今，上电后将Flash的启动代码重定位到内存里，提升速度 
体系架构ARMv4-7、8  单片机、RTOS、Linux、AI嵌入式  A应用-R实时-M微控制器
//ARMv7 37个寄存器 1个pc 1个CPSR 5个SPSR 30个通用
当发生异常或者中断时，处理器会将CPSR的当前值保存到SPSR中，以便在异常处理程序结束后恢复
先前的程序状态。
//ARM64
异常级别  //EL0(应用) < EL1(OS) < EL2(虚拟化) < EL3(安全固件) -> 替代啰嗦的工作模式
//ARMv8 31个通用寄存器X0~X30(64位) W0~W30(32位)
```

```
笔记：硬件资源受限，在主机在编译后传入板子
交叉编译：PC端编辑编译，然后在板子上运行，PC端装入ARM编译工具链
通过串口获取板子上的信息，板子的启动代码、系统等事先通过烧写SD卡完成
主机上装虚拟机安装Linux系统，但是串口传输很慢，因此改用网线(USB转有线网卡转接器进行)，利用有线网卡传输
板子上电会运行uboot，然后是Linux内核，最后是APP程序
主机上通过TFTP Server端传输，板子TFTP client端接收
NFS共享文件
```

```
micro-B usb:模拟网卡，u盘，串口
u-boot是板子上电的第一个裸机程序
内核运行需要内核镜像Image和设备树dtb

内核崩溃问题
单独更新Iamge 内核崩溃 不能打印输出 调试信息打印出错
1、重新刷机
2、插入SD卡将原始Iamge替换
不能单独更新Image，需同步更新内核模块，否则内核模块加载不了
```

```shell
板子上电三个阶段：Bootloader----Linux内核----应用
u-boot、kernel、rootfs存放于Falsh中,搬到内存中运行。
BL1:第一段启动程序不是U-boot，是cpu片内的irom中的BL1:--初始化引导媒介(SD或者flash)
BL2:冷启动或者烧写恢复
BL3：微内核集成到bootloader中,启动uboot，开启logo，支持显示,支持usb，远程访问等
BL4: uboot
Flash中的是uboot.image,其中包含3部分
/home/dengzj/bsp/Linux_for_Tegra/bootloader/t210ref/p3450-0000中的u-boot.bin
/home/dengzj/bsp/Linux_for_Tegra/bootloader中的cboot.bin、nvtboot.bin
通过刷机脚本./flash.sh整合为uboot.image
```

```c
//u-boot启动步骤
第一条指令在cpu中内部irom固化程序BL1
考虑安全性第一，速度其次问题，u-boot启动阶段：关中断、看门狗(避免不断复位)、cache关闭(有缓存,数据不一致)、mmu
提升速度，搬移到内存
汇编阶段：SVC模式  需要特殊指令来操作寄存器 汇编不好维护
基本硬件初始化：时钟、串口、flash、内存
uboot中的后面一部分自搬移到内存中运行
汇编到c语言的准备：栈！
c语言阶段：
大部分硬件初始化：USB、网卡、摄像头
内核从flash中搬移到内存中运行
```

```
u-2022和usb移植都有问题，需要控制变量
当前u-boot里没有8169，最新的u-boot里才有，如何移植呢
先将最新版本里的u-boot里的8169.c的代码copy到当前的u-boot的/drivers/net中
然后修改Makefile和Kconfig
```

```
内核移植的目的:板子上的内核版本太老，有些设备功能不支持，所以需要移植
scp linux-4.9.253.tar.gz  yhai@192.168.0.148:/home/yhbd/bsp/
总结：注意格式 空格问题会导致找不到文件夹 权限问题：修改文件权限即可
NFS挂载失败可能是本机IP地址冲突消失导致的
解压文件需要确定大小，防止解压不完整，出现后续问题
解决编译错误，尽量不要改源码和Makefile,而是通过menuconfig里取消配置的方式
内核添加调试信息 打印行号函数文件名  需要在ubootargs里添加loglevel=8
```



## 贰、ARM开发

![ARM开发](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\ARM开发.png)

```
ARMV8 64位汇编 jeston nano
```

### 一、初识ARM√

```
ARM公司主要设计ARM系统的RISC处理器内核
jeston nano是4核Cortex-A57
```

![初始ARM](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\初始ARM.png)

![产品线](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\产品线.png)

![嵌入式发展](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\嵌入式发展.png)

#### 1、课程安排√

![4](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\4.png)

#### 2、ARM体系结构√

![ARM体系结构](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\ARM体系结构.png)

#### 3、环境搭建

##### ①keil(mdk)安装

##### ②keil(mdk)最简示例

#### 4、购硬件配件√

##### ①电源5V4A

##### ②USB转网线接口

##### ③STM32套件

### 二、ARM汇编

#### 1、硬件系统组成和运行原理√

![硬件系统组成](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\硬件系统组成.png)

```
CPU(ARM Cortex-A57)负责复杂逻辑运算的处理
GPU负责大数据的同时并行运算
CPU里分为三部分：ALU运算器运算；控制器取址，译码；寄存器暂存数值
现如今，上电后将Flash的启动代码重定位到内存里，提升速度 
```

#### 2、工作模式及寄存器框图√

![ARM工作模式](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\ARM工作模式.png)

```c
User(用户模式)、FIQ(快中断模式)、IRQ(中断模式)、Supervisor(SVC管理模式)、Abort(终止模式)、Undef、System
ARM有37个寄存器
1个 CPSR(Current Program Status Register)当前程序状态寄存器
5个 SPSR(Saved Program Status Register)备份程序状态寄存器
1个 PC寄存器
30个 通用寄存器
    
特殊寄存器
R13: SP(Stack Pointer)寄存器(用作栈指针寄存器)
R14: LR(Link Register)寄存器(连接寄存器)	记录函数调用时的返回地址
R15: PC(Program Counter)寄存器(程序计数器)	存放下一条指令地址的寄存器
使用FIQ的好处，当User切换到IRQ时，由于r0~r12说共用的，因此需要将user寄存器里的数据进行现场保护入栈，当执行完IRQ时再出栈恢复现场。进出栈会浪费时间，此时使用FIQ时，若我们将User数据保存在r8~r12，FIQ与User不是共用的，因此会省去进出栈的时间，从而提升效率。
    
异常向量表
```

#### 3、汇编指令初级

##### ①搬移指令

```assembly
mov   r13,#3

mrs   r0,cpsr
msr   cpsr,r0

and   r0,r0,#0xFFFFFFE0
orr   r0,r0,#0x10

mov   r0,r1,LSL#2      
mov   r0,r1,LSR#2
```

##### ②指令是如何存储的和被解析的

![ARM汇编指令如何解析](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\ARM汇编指令如何解析.png)

##### ③指令的机器码

##### ④跳转指令

```assembly
b    main      跳转到标号为main地代码处 (只能短跳转32M) 

bl   func      跳转函数func,并保存下一条要执行的指令的位置到 lr寄存器,
               当跳转代码结束后,用mor pc,lr指令跳回来

beq  addr     相等时，跳转到地址addr处
                          相等（指CPSR寄存器中的Z条件码置位时)

bne  addr     不等时，跳转到地址addr
```

##### ⑤逻辑指令

```assembly
and    r0,r1,r2       
and    r0,r1,#0xFF    与

orr    r0,r1,r2
orr    r0,r1,#0xFF    或

bic    r0,r0,#0x0B    清除r0中的位 0、1、和 3  
tst    r0,#0x20       测试第6位是否为0 ，为0则Z标志置1 
cmp    r1,r0          将寄存器R1的值与寄存器R0的值相减，
                      并根据结果设置CPSR的标志位
```

##### ⑥算术指令

```assembly
add     r0,r1,r2       默认是不影响CPSR的标志位的
add     r0,#1

sub     r0,r1,#3      类似  r0= r1 - 3
sub     r0,#1

sub     r0,r1,r2,LSL#1     
```

#### 4、汇编指令高级

##### ①LoadStore架构

##### ②GNU汇编伪指令

##### ③批量操作指令

```assembly
ldr 	  r12,=srcBuf
   ldr 	  r13,=dstBuf
   ldmia  r12!,{r0 - r11}
   stmia  r13!,{r0 - r11}

  .data
srcBuf:
  .string "abcdefghijkomnopqrstubwxyz\0"
dstBuf:
   .space  12*4
```

##### ④堆栈操作指令

```assembly
stmfd sp!,{r0-r12,lr}       
//将寄存器r0~r12 lr中的值存入栈中   常用于中断保护现场,! 表示会自动偏移                                       
 ldmfd sp!,{r0-r12,pc}^   
//将栈中值逐个弹出到寄存器r0~r12 pc中  常用于中恢复断现场，^表示会恢复spsr到cpsr
```

#### 5、异常处理

##### ①异常向量表

##### ②软中断最简

```assembly
.text
	@---------vector table
	b   main  	@0x00 reset
	nop       	@0x04 undef         
	b sirq_hander	@0x08 soft irq
	nop       	@0x0c prefecth abort
	nop	      	@0x10 data abort
	nop		@0x14 reserved
	nop		@0x18 irq
	nop		@0x1C fiq
	
	@ handler vector table
sirq_hander:
        stmfd sp!,{r0-r12,lr}
        add  r2,#1

sirq_hander_end:
	ldmfd sp!,{r0-r12,pc}
        @----------app----
main: 
        ldr sp,=stack_buf
	mov r1,#1
	mov r2,#2
	swi 0x1   
	cmp r2,#2
	moveq r4,#4
	movne r4,#6
main_end:
	b  main_end
     
	.data

        .space 15*4
stack_buf:

	.end

```

##### ③软中断完整

```assembly
.text
	@---------vector table
	b   main  	@0x00 reset
	nop       	@0x04 undef         
	ldr pc,_sirq_hander	@0x08 soft irq
	nop       	@0x0c prefecth abort
	nop	      	@0x10 data abort
	nop		 @0x14 reserved
	nop		 @0x18 irq
	nop		 @0x1C fiq
	
_sirq_hander:
	.word  sirq_hander
	
	@ handler vector table
sirq_hander:
    stmfd sp!,{r0-r12,lr}
	ldr r0,[lr,#-4]
	bic r0,#0xff000000
	cmp r0,#1
	addeq  r2,#1
	cmp r0,#2
	subeq  r2,#1

sirq_hander_end:
	ldmfd sp!,{r0-r12,pc}
    @----------app----
main: 
    ldr sp,=stack_buf
    mov r1,#1
    mov r2,#2
    swi 0x1   
    cmp r2,#2
    moveq r4,#4
    movne r4,#6
    swi 0x2
    mov r0,#3	
main_end:
    b  main_end
     

	.data

    .space 15*4
stack_buf:

	.end
```

#### 6、源头

### 三、ARMV8 64位汇编

```c
ARM Cortex-A 系列 ARMv8-A 程序员指南 https://developer.arm.com/documentation/den0024/a 

Armv8-A 架构寄存器 https://developer.arm.com/documentation/ddi0595/2021-09?lang=en

Arm A64 指令集架构 https://developer.arm.com/documentation/ddi0596/2021-09/Base-Instructions

资料见云盘 6.ARMV8资料
```

```c
三大动因 //应对大内存 虚拟化和安全的需求
    	//大内存(Large Memory): 突破32位机的4G空间限制  -> 硬件越来越强，软件越来越复杂 
        //虚拟化(Virtualization): 隔离 高效  -> 虚拟机       
        //安全(Security):  物理隔离  -> 交易支付，隐私数据安全
三大创新  //执行状态,异常级别，和安全模式

执行状态  //AArch64 和 AArch32 两种可切换  
         //AArch64: 新增A64(ARM 64bit)指令集 -> 大内存(突破4G限制)
         //AArch32: 可用以前A32(ARM 32bit)指令集和 T32(Thumb 32bit)指令集 -> 向前兼容
异常级别  //EL0(应用) < EL1(OS) < EL2(虚拟化) < EL3(安全固件) -> 替代啰嗦的工作模式
安全模式  //分为正常世界 和 安全世界  -> 真正的安全(物理隔离,如支付场景)         
```

#### 1、多核处理器√

![多核处理器](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\多核处理器.png)

```
jeston nano 多核异构处理器
```

#### 2、内存管理单元MMU√


![MMU](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\MMU.png)

```
Peripherals(外围设备)
虚拟地址映射到实际物理地址，通过TTBR0_EL0、TTBR1_EL1寄存器分配
TTBR0_EL0:用户空间的地址转换
TTBR1_EL1:操作系统内核的地址转换
```

![地址映射](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\地址映射.png)


#### 3、ARMv8 寄存器框图√

![ARMv8 64位寄存器](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\ARMv8 64位寄存器.png)

##### ①31个通用寄存器√

```c
X/W  //X是64位  W是低32位

ARMv7 中使用Bank register(每个模式下独有的寄存器空间)来减少异常的延迟 //然而使用的寄存器都不到一半
//独有寄存器，属于牺牲空间换时间，减少进出栈的时间
AArch64 执行状态具有 31× 64位通用寄存器 //可在所有时间和所有异常级别访问	
```

##### ②特殊寄存器√

```assembly
XZR     #零寄存器: 用作源寄存器时读为零，用作目标寄存器时丢弃结果	
SP      #堆栈指针 (每个异常级别，独有一个副本SP_ELn)
PC      #程序计数器
SPSR    #发生异常时，存储处理器状态(类似于 ARMv7 中的 CPSR)
ELR_EL  #异常链接寄存器	保存导致异常的指令的地址	

PSTATE  #可独立访问的处理器状态的寄存器组 (取代 CPSR的状态字段)
NZCV  #条件标志
      #bit[31:29]: N Z C V  
      #源头：搜索NZCV 在https://developer.arm.com/documentation/ddi0595/2021-09/AArch64-Registers
      #mrs X0, NZCV      
DAIF  #中断屏蔽位(为1时屏蔽)
      #bit[9:6]: D A I F  D(断点观察点)   A:SError  I(IRQ)  F(FIQ)
CurrentEL #当前的异常级别  
          #bit[3:2]: 00(EL0)  01(EL1) 10(EL2) 11(EL3)      
          # mrs x1, CurrentEL   可独立访问          
SPSel #选择堆栈指针的异常级别 
      #bit[0]:   0(都用SP_EL0)   1(用对应的SP_ELx) 
```

##### ③系统寄存器√

![系统寄存器](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\系统寄存器.png)

```assembly
寄存器手册 // https://developer.arm.com/documentation/ddi0595/2021-09?lang=en
SCTLR  //系统控制机器： 如MMU、缓存和对齐检查	
TTBR0_EL1 //转换表基址寄存器0  -> 物理空间 映射 应用空间 
TTBR1_EL1 //转换表基址寄存器1  -> 物理空间 映射 内核空间
MPIDR        //多处理器关联寄存器
ICC_SRE_EL3  //中断控制寄存器
ESR_EL      //异常综合症寄存器: 包括有关异常原因的信息
HCR_EL      //管理程序配置寄存器： 控制虚拟化设置和捕获 EL2 的异常 
```

##### ④向前兼容√

ARMv7架构

![ARMv7架构](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\ARMv7架构.png)

![向前兼容](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\向前兼容.png)

```assembly
在AArch32中执行时，无法访问AArch64寄存器的高32位 //它使用32位W寄存器(相当于32位ARMv7寄存器)
```

##### ⑤ARMV8异常级别√

![异常级别](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\异常级别.png)

#### 4、环境搭建: 用qemu+ gdb + vscode 实现特权寄存器的访问

##### ①ssh登录后 gdb调试 c/c++程序

##### ②qemu 安装

##### ③最简

##### ④寄存器对应关系

#### 5、ARMv8 汇编指令

##### ①函数

##### ②宏函数

#### 6、ARMv8 异常处理

##### ①异常类型

##### ②异常向量表

#### 7、UBOOT启动源码分析：动静结合

##### ①源码获取

##### ②入口

##### ③异常向量表

##### ④中断控制器初始化

##### ⑤C语言的执行环境 初始化

##### ⑥调试(动态)

##### ⑦作业

### 四、硬件控制

#### 1、环境搭建√

![交叉编译](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\交叉编译.png)

```shell
笔记：硬件资源受限，在主机在编译后传入板子
交叉编译：PC端编辑编译，然后在板子上运行，PC端装入ARM编译工具链
通过串口获取板子上的信息，板子的启动代码、系统等事先通过烧写SD卡完成
主机上装虚拟机安装Linux系统，但是串口传输很慢，因此改用网线(USB转有线网卡转接器进行)，利用有线网卡传输
板子上电会运行uboot，然后是Linux内核，最后是APP程序
主机上通过TFTP Server端传输，板子TFTP client端接收
NFS共享文件
```

##### ①硬件配件√

###### (1)电源5V4A

###### (2)USB转网线接口

###### (3)STM32套件

##### ②JTAG调试仿真√

```shell
笔记：以前的裸机开发，硬件上没有程序，都说用JTAG调试仿真
核心板里的部件频率高，外围部件频率相对比较低。
控制LED，首先找到外围板的电路原理图，三极管弱电流控制大电流，在查看芯片手册配置寄存器
不支持JTAG(j太可特)，引脚未引出
```

##### ③uart串口调试√

```c
usb转串口的接线图  红色 5V 黑色 GND白色 RXD绿色 TXD
jtag口 //隐藏在金手指核心板的背部，未引出到扩展板的管脚上，不好调试
uart调试口 //在SD卡底部，横着一排(2G板子时在摄像头 排线的旁边)
           //GND: usb转串口的黑线接板子的  TXD: 接白线  RXD: 接绿线 红线(电源):不接


打开win10设备管理器，查看有COM口吗 //没有或异常，需安装驱动PL2303_Prolific_GPS_1013_20090319.exe
                //驱动报错：pl2303hxa自2012已停产,请联系供货商
                //下载老的驱动，更新驱动时 选老版本驱动即可,或卸载重装
```

##### ④uboot的tftp下载√

```shell
uboot的tftp下载 -> 裸机调试(因jtag仿真用不了 uboot本身是裸机程序)
```

###### (1)主机安装TFTP服务

```shell
$ sudo apt-get install xinetd tftpd tftp	
$ sudo vim /etc/xinetd.d/tftp /*添加下面内容, 
service tftp
{
protocol        = udp
port            = 69
socket_type     = dgram
wait            = yes
user            = nobody
server          = /usr/sbin/in.tftpd
server_args     = /tftpboot
disable         = no
}

$ sudo mkdir /tftpboot
$ sudo chmod -R 777 /tftpboot
$ sudo chown -R nobody /tftpboot 
$ vim /tfpboot/test //创建测试文件
$ sudo service xinetd restart  //新系统的重启服务
$ sudo /etc/init.d/xinetd restart  	//老系统的重启服务

$ tftp localhost  //自环测试
tftp> get  test
Received 7 bytes in 0.0 seconds  //有下载到文件，表示tftp服务安装成功
tftp> q //退出
```

###### (2)板子与虚拟机能ping通

```c
用网线连接板子和电脑  //需买网线，笔记本电脑还需买 usb转网卡 设备

//win10设置：
  右下脚无线网图标上右键 -> 打开网络和internet设置 -> 以太网 -> 网络和共享中心
  -> 点以太网（有线网卡） -> 属性 -> TCP/ipv4-> 选使用下面的ip地址
  -> IP地址    192.168.5.10   -> 确定
     子网掩码  255.255.255.0
     网关      192.168.5.1
  关闭防火墙 // 右下角向上箭头 -> 点盾牌的图标 -> 把域网络 专有网络 公有网络 防火墙全部关闭（否则是ping不通的）
命令行输入  > ipconfig      //能看到以太网适配器里右ip  192.168.5.10表示设置成功
    
//板子设置：	
$ sudo ifconfig eth0 192.168.5.8 up  //设置有线网卡的ip地址(默认eth0是有线网卡)
$ ifconifg   //看到 eth0 设为 192.168.9.110 表示设置成功
$ ping 192.168.5.10 /*如果有回信息表示板子与电脑网络连接成功
```

主机关联有线网卡设定静态ip

```shell
WorkStation -> 编辑 -> 虚拟网络编辑器 -> 更改设置 -> 桥接模式 -> 选usb有线网卡 -> 确定退出
WorkStation -> 虚拟机 -> 设置 -> 自定义 -> 选Vnet0 //需和前一个一致
ubuntu -> 右键右上角的网络图标 -> 设置 -> 点+ 号新加网卡 -> 身份 名称设为 board -> 
选ipv4 -> 手动 -> 地址 设为192.168.5.11  子网掩码 255.255.255.255.0  网关：192.168.5.1 -> 确定退出
$ ifconfig //如果看到有 192.168.5.11 的网卡，表示设置成功
```

###### (3)TFTP下载文件到板子上

```shell
# pci enum;pci  /* 激活pci设备(否则ping时报：No ethernet found.)
Scanning PCI devices on bus 0
BusDevFun  VendorId   DeviceId   Device Class       Sub-Class
_____________________________________________________________
00.01.00   0x10de     0x0fae     Bridge device           0x04
00.02.00   0x10de     0x0faf     Bridge device           0x04	
  */	
# setenv serverip   192.168.5.11            192.168.9.119 
# setenv ipaddr   192.168.5.8  				192.168.9.9
# ping 192.168.5.10 /*先ping通win10
  Using eth_rtl8169 device
  host 192.168.9.120 is alive

# ping  192.168.5.11   /*再ping通虚拟机(如果不通，看一下前面 主机关联有线网卡设定静态ip）
   Using eth_rtl8169 device
   host 192.168.9.119 is alive
# saveenv

# tftp Image  /*内核33M下载要3分钟（太慢了，为什么）
	Using eth_rtl8169 device
	TFTP from server 192.168.9.119; our IP address is 192.168.9.9
	Filename 'Image'.
	Load address: 0x84000000
	Loading: ##########....
         ####################################################
         308.6 KiB/s
	done
	Bytes transferred = 34484232 (20e3008 hex)
	占用地址范围  0x84000000 ~ 0x84000000+20e3008
   */	
# tftp 0x88000000 tegra210-p3448-0002-p3449-0000-b00.dtb   
```

##### ⑤交叉编译工具安装√

```shell
$ cp /mnt/hgfs/share/gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu.tar.xz  . //从与win10的共享目录拷贝过来(不要采用拖拉到虚拟机中方式，文件太大了会不完整)
$ tar -xvf 	gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu.tar.xz
$ cd gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu/bin/
$ pwd //如  /home/dengzj/Downloads/gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu/bin

$ export PATH=/home/dengzj/Downloads/gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu/bin:$PATH // 注：export 路径要和你自己的pwd 一致
$ export //查看环境变量，可成功看到PATH变化 ，系统会通过它来找到aarch64-linux-gcc

$ aar 后按tab键能补全为aarch64-linux-gnu- 表示成功
      //export只是才当前有效，重开新终端，或重启就消失了，需重设，故把它添加到启动脚本里，让它自动生效。
$ vim ~/.bashrc //在其末尾添加export PATH=/home/dengzj/Downloads/gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu/bin:$PATH
$ source ~/.bashrc //使启动脚本修改生效
关掉终端重新打开
$ aarc 按tab健 //能补全为 aarch64-linux-gnu- 表示安装成功
```

##### ⑥运行裸机程序√

```shell
$ make
$ cp led.bin  /tftpboot

//板子重启 停在u-boot处
# pci enum;pci
# tftp led.bin
# go 0x84000000  //运行程序
               //如果是异常重启，可能是顺序执行到非法区域，或某指令写非法地址    
```

###### led.s

```assembly
	mov x3,#0x5A
	mov x4,#0x55
loop:
	b   loop
```

###### Makefile

```shell
CROSS = aarch64-linux-gnu-
CC=$(CROSS)gcc
LD=$(CROSS)ld
OBJCOPY=$(CROSS)objcopy
    
all: led.s
	$(CC) -g -c -o led.o led.s  
	$(LD) led.o -Ttext 0x80090000 -o led.elf
	$(OBJCOPY)  -O binary -S led.elf led.bin
	$(CROSS)objdump -D led.elf > led.dis
	 
clean:
	rm -f *.o *.elf *.bin *.dis	
```

#### 2、硬件架构图√

![1](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\1.png)

```c
官方资料下载 //https://developer.nvidia.com/embedded/downloads里 输入nano  搜
板载描述(重点) //见SP-09732-001_v1.1.pdf  
            //NVIDIA Jetson Nano Developer Kit Carrier Board P3449_B01
电路图   //见Jetson_Nano_Carrier_Board_OrCAD_Schematics.pdf
芯片手册 //见Jetson Nano Module Data Sheet 
         //注：芯片手册中寄存器时代 被 设备树时代替代了

GPU      //NVIDIA Maxwell架构，配备 128 个 NVIDIA CUDA核心
CPU      //四核 ARM  Cortex-A57
内存     //4 GB 64 位 LPDDR4    -> 到 SOC 内部
存储     //外插Micro SD卡(TF卡)
视频编码 //4K @ 30 (H.264/H.265)
视频解码 //4K @ 60 (H.264/H.265)
摄像头    //1×2 通道（3x4 或 4x2）MIPI CSI-2 DPHY 1.1 (1.5 Gbps)
网卡      //千兆以太网（ 无wifi,需另加配件)
显示输出  //HDMI 2.0 或 DP1.2 | eDP 1.4 | DSI (1 x2) 2 同步
高速接口  //1 x1/2/4 PCIE、4个USB3.0接口
I/O接口   //3x UART / 2x SPI /4x I2C / 2x I2S/ GPIO

板子代号  //Jetson Nano 4GB  P3448-0000
          //board: jetson-nano-devkit
```

```
CPU+GPU的架构 64位 ARMv8 cpu处理复杂逻辑
128个CUDA核 善于处理图像运算
外插flashSD卡
I2C接OLD屏和小车，PWM通过控制电机控制小车
```

#### 3、引子

##### ①点灯场景

```
接面包板，LED灯，杜邦线等 //板子上 CPU 通过某管脚，能把灯点亮
点灯过程  //板子标注 -> 电路图 -> 芯片手册 -> 程序

$ sudo -i  // 输入密码jetbot后，能看到root，表示成功切换到root用户
$ cd /sys/class/gpio/  //利用内核开发接口,控制灯

$ echo 79 > export	 //把sysfs里管脚的编号导出（pin 12脚对应的sysfs 的gpio 79）
$ cd  gpio79
$ echo out > direction //把管脚设为输出模式
$ echo 1 > value //输出高电平，发现灯亮了
$ echo 0 > value  //输出低电平，发现灯灭了
$ cat /sys/kernel/debug/gpio  //查询gpio状态
$ echo 79 > unexport //取消导出（发现gpio79消失了)
```

##### ②源头

```shell
源头 //从官方入手，收集足够资料，全部先看一遍，做到心中有底
     //侦探破案的第一步，收集足够的线索和证据
     //注：jetson它提供的文档比较散，要化很多时间去找，有些信息，还是论坛里给的提示，
官方文档中心 //https://developer.nvidia.com/embedded/downloads	
-> 选jetson //过滤调无关的后, 把列表相关文档全部先走一遍，做到心中有底  
-> Jetson Nano Product Design Guide //1.产品设计指导(入口)
      //-> 1.1 References  列出了相关的文档
 
-> Jetson Nano Developer Kit Carrier Board Specification  //2.1板子标注说明  
-> Jetson Nano Module Data Sheet  //2.2板子的芯片手册      
-> Jetson Nano Developer Kit Carrier Board Specification //2.3板子的电路图
     			//Maxwell GPU + ARM Cortex-A57 + 4GB LPDDR4 + 16GB eMMC
     			//与电路图中管脚编号一致，但和板子上标注不一致。
-> Tegra X1 (SoC) Technical Reference Manual //3 CPU(soc)的芯片手册    				             
-> Jetson Nano Pin and Function Names Guide Application Note //4.1引脚的控制
-> Jetson Nano Developer Kit Pinmux  //4.2 40PIN外接管脚的转换表    
-> Jetson Nano Pinmux   //4.3 管脚复用的映射表 

官方论坛  //https://forums.developer.nvidia.com/	
-> Jetson & Embed system -> Jetson Nano 
-> 搜索关键字 如datasheet  //根据你目标搜关键字，列出了很多相关文档，都查看一下

ARM官网 //https://developer.arm.com/ip-products/processors/cortex-a/cortex-a57 
-> 下载 DDI0488H_cortex_a57_mpcore_trm.pdf //cortex_a57 芯片手册 
```

#### 4、电路图

##### ①LED灯

```shell
三极管  //NPN (PNP是反的)  ->弱电流控制大电流
        //b: 基极  开（高电平），关（低电平） 
        //e: 发射极
		    //c: 集电极
        //注：为何要用三极管，电流放大（极弱电流控制弱电流) 
        //    因芯片管脚太多，管脚电流要很小，否则功耗很大，会很烫
        //    但电流太小，光太暗了，故用三极管进行电流放大	
        
场效应管 //NMOS 场效应管 （PMOS管是反的）
         //G：删极,gate门，开（高电平），关（低电平）
         //S: 源极，电流流出端
         //D: 漏极，电流流入端
	 //如果是三极管，基极需加限流电阻，
	 //场效应管是电压驱动，G极电流很小，但开关瞬间的寄生电容的充放电大。
	 //串联电阻（几欧或几十欧）形成RC放电回路，减小峰值电流。0.05ohm（欧姆）
	       
DS3  //丝印: 板子上标注不同器件 
LED_SMD_0603  //表贴型(SMD) 发光二极管，尺寸0603(长0.06英寸，宽0.03英寸)
25ma  //工作电流 (注电流太大，烧毁，电流太小亮度不够)
      //5/1.8k欧 = 27ma  约等于25ma 
```

##### ②PWM

#### 5、芯片手册

```shell
etsonNano_DataSheet_DS09366001v1.0.pdf //JetsonNano板子的简明芯片手册
Tegra_X1_TRM_DP07225001_v1.3p.pdf  //JetsonNano用的cpu(Tegra_X1) 的详细芯片手册
DDI0488H_cortex_a57_mpcore_trm.pdf //Cortex_a57 芯片手册 
```

##### ①CPU框图

##### (1)CPU核

```shell
GIC   //Generic Interrupt Controller 通用中断控制器	
NEON  //是一种基于SIMD(单指令多数据流指令)的arm技术 -> 矩阵运算，图像处理
I$ 48  D$ 32//48K指令和32数据 一级缓存(cache) 
L1(2M)  //2 MB共享的2级缓存	
CoreSight //片内的黑匣子 -> 不用jtag 调试 跟踪
         //通过专有的硬件非入侵地实时记录程序执行路径和数据读写信息，然后压缩成Trace数据流，
         //通过专用的数据通道和输出端口传输至调试主机。调试主机中的开发工具解压缩这些Trace数据流，
         //恢复程序运行信息后，就可以进行调试和性能分析。
```

###### (2)总线

```shell
AXI(Advanced eXtensible Interface) // 高级可扩展接口(多通道并行) -> 与GPU FPGA的大数据传输           
APB(Advanced Peripheral Bus) //高级外围总线(单通道)  -> 用于低带宽设备(如uart i2c)	
AHB(Advanced High-performance Bus) // 高级高性能总线(单通道) -> 高性能高时钟频率场景
     //(如ARM核与内部RAM、NAND FLASH、DMA、Bridge的连接)

```

###### (3)存储

```shell
PCIE //Peripheral Component Interconnect Express 周边设备高速互联 ,连接如WIFI高速设备   
EMC //External Memory Controller  接外部存储器（如内存）的接口
MC  //Memory Controller 内存控制器模块，处理来自内部客户端的请求并，进行仲裁其中分配内存带宽。   
DDR  //Double Data Rate SDRAM  双倍速率同步动态随机存储器,即内存
LPDDR // Low Power Double Data Rate SDRAM，低功耗双倍数据速率内存  
SATA //Serial Advanced Technology Attachment 接硬盘的常用接口
```

###### (4)多媒体

```shell
VI  //Video Input  视频输入
VIC //VIDEO IMAGE COMPOSITOR  视频图形合成
NVENC //NVIDIA Video Encoder engine 视频编码引擎
NVDEC //NVIDIA Videod Decoder engine 视频解码引擎
NVJPG //NVIDIA 的jpg图片的处理
TSEC //Tegra Security Co-processor,，一种嵌入式安全处理器，主要用于管理HDMI链路上的HDCP加密和密钥。
ISP //Image Signal Processor 图像信号处理器，是相机处理硬件引擎管道
MIPI // Mobile Industry Processor Interface  移动行业处理器接口(一些移动设备的标准接口)
CSI  //Camera Serial Interface  摄像头串行接口
DSI  //Display Serial Interface 显示串行接口
eDP  //Embedded Display Port 嵌入式显示端口
HDMI //High-Definition Multimedia Interface  高清晰度多媒体接口
```

###### (5)低速区

```shell
IRAM //片内存储器
IROM //片内只读存器
Semaphore //信号量 -> 多核互斥
ATOMIC //原子操作 -> 同步
Clock  //时钟
Flow Control  //流控 -> 多核流程排序
GPIO  //General Purpose Input/Output 通用输入输出
RTC //Real Time Clock 实时时钟
PWM //Pulse Width Modulation 脉冲宽度调制
UART //Universal Asynchronous Receiver/Transmitter 通用异步收发传输器 -> 串口调试
I2C  //
SPI  //
PMC //Power Management Controller 电源管理控制器
```

##### ②地址映射

##### ③管脚控制 √

×××

##### ④时钟

##### ⑤总线

```shell
PCIE //Peripheral Component Interconnect Express 周边设备高速互联
     //金手指 高速端到端传输(达5GT/S = 500M byte/s)
     //速度: gen1代(2.5GT/S) ,gen2代(5GT/s = 5000/10 M byte/s)
     //4根主线: 发送(Tx+ Tx- )和接收(Rx+  Rx-)  两对差分线每通道 
     //协议： 串行，全双工，端到端
```

##### ⑥中断控制 √

×××

##### ⑦多媒体 √

×××

##### ⑧多核并发 √

×××

##### ⑨存储 √

×××

##### ⑩电源管理 √

×××

#### 6、GPIO点灯(在硬件层)

##### ①看电路图 芯片手册->找控制引脚的寄存器

###### (1)定位

```shell
定位 //板子丝印 -> 电路图 -> 芯片手册

pin 12(丝印) -> I2S0_SCLK  //参2.1板子标注说明 的 3.3 40-Pin Expansion Header
 -> GPIO3_PJ.07 //参 4.2 40PIN外接管脚的转换表 
 -> GPIO Controller 3 – Port  J   //参3.1CPU芯片手册Tegra_X1_TRM_DP07225001_v1.3p.pdf  
        GPIO_CNF_1           204 //第3组GPIO的J端口的配置寄存器的偏移地址是204
```

###### (2)地址映射

```shell
// GPIO模块的基地址
2.1 System Address Map   //8*4*8 = 256个GPIO管脚 (8个bank，每个bank 4个port ,每个port8个管脚 )
         开始地址    结束地址
GPIO-1  0x6000D000  0x6000D0FF
...
GPIO-3  0x6000D200  0x6000D2FF
...
GPIO-8  0x6000D700  0x6000D7FF

// GPIO寄存器的地址映射
Register Name  
GPIO Controller 3  	 I    J   K   L   I   J   K   L   //有前面 GPIO3_PJ.07
GPIO_CNF_[0/1/2/3] 	200  204 208 20C 280 284 288 28C  //-> GPIO_CNF_1 204
GPIO_OE_[0/1/2/3] 	210  214 218 21C 290 294 298 29C  //-> GPIO_OE_1  214
GPIO_OUT_[0/1/2/3] 	220  224 228 22C 2A0 2A4 2A8 2AC  //-> GPIO_OE_1  214
```

###### (3)GPIO寄存器

```shell
9.13.1 GPIO_CNF_0   
15 DISABLE  //LOCK_7: Lock access to pin 7 CNF, OE and OUT
	    //0 = DISABLE 1 = ENABLE
7 0x0       //BIT_7: Configures each pin to be in either GPIO or SFIO mode
            //0 = SPIO  1 = GPIO

-> 0x6000D204 = 0x8080 //把pin12（GPIO3_PJ.07）配置为GPIO模式

9.13.2 GPIO_OE_0
7 0x0      //BIT_7: GPIO mode (GPIO_CNF.x=1) must be true for this condition to be valid.
           //0 = TRI_STATE 1 = DRIVEN
-> 0x6000D214 =0x80  //使能output

9.13.3 GPIO_OUT_0
7 0x0      //BIT_7: GPIO_CNF.x=1 (in GPIO mode) AND GPIO_OE.x=1 (GPIO output enabled) must be true for this to be a valid state
           //0 = LOW 1 = HIGH    
-> 0x6000D224 =0x80  //输出高电平
```

##### ②led程序

```shell
$ make
$ cp led.bin  /tftpboot

//板子重启 停在u-boot处
# pci enum;pci
# tftp led.bin
# go 84000000  //运行程序
               //如果是异常重启，可能是顺序执行到非法区域，或某指令写非法地址
```

###### (1)led.s

```assembly
.equ  GPIO_CNF,0x6000D204
.equ  GPIO_OE,0x6000D214
.equ  GPIO_OUT,0x6000D224

    .text
    ldr  x6,=GPIO_CNF
    ldr  x7,=GPIO_OE
    ldr  x8,=GPIO_OUT
    
    //set gpio mode
    ldr  x1,=0x8080
    orr  x0,x6,x1
    str  x0,[x6]
    //enable output
    ldr  x1,=0x80
    orr  x0,x7,x1
    str  x0,[x7]
    //output high
    ldr  x1,=0x80
    orr  x0,x8,x1
    str  x0,[x8]
loop_end:
    b  loop_end

    .end
```

###### (2)Makefile

```c
CROSS = aarch64-linux-gnu-
CC=$(CROSS)gcc
LD=$(CROSS)ld
OBJCOPY=$(CROSS)objcopy
    
all: led.s
	$(CC) -g -c -o led.o led.s  
	$(LD) led.o -Ttext 0x80090000 -o led.elf
	$(OBJCOPY)  -O binary -S led.elf led.bin
	$(CROSS)objdump -D led.elf > led.dis
	 
clean:
	rm -f *.o *.elf *.bin *.dis	
```

#### 7、GPIO点灯(在内核层)

##### ①分层映射

##### ②最简代码

$ sudo insmod led.ko  插入驱动模块

$ dmesg  查看内核输出日志

$ sudo rmmod led  卸载驱动模块

```c
#include <linux/module.h> 

int led_init(void)
{
   printk("led init ok\n");
   return 0; //放回0：表示成功
}

void led_exit(void)
{
   printk("led exit ok\n");   
}
module_init(led_init);  //声明 led_init 是内核模块加载入口 insmod led.ko 时会触发调用 
module_exit(led_exit); //声明led_exit是内核模块的卸载入口 rmmod led  时会触发调用 
```

**makefile**

```c
ifeq ($(KERNELRELEASE),)
KVERSION = $(shell uname -r)
all:
	$(MAKE) -C /lib/modules/$(KVERSION)/build M=$(shell pwd) modules
clean:
	$(MAKE) -C /lib/modules/$(KVERSION)/build M=$(shell pwd) clean
else
	obj-m :=led.o
endif	
```

##### ③读寄存器的值

```shell
$ sudo insmod led.ko  //插入驱动模块吗，查看信息
$ dmesg  //查看内核输出日志
$ echo 79 > /sys/class/gpio/export   //导出79号gpio 引脚，使得可在应用层访问
$ echo out > /sys/class/gpio/gpio79/direction  //设置 为输出
$ echo 1 > /sys/class/gpio/gpio79/value //输出高电平 开灯
$ sudo rmmod led 
$ dmesg  
$ echo 0 > /sys/class/gpio/gpio79/value  //输出低电平， 关灯
$ sudo insmod led.ko 
$ dmesg 
```

```
//源码led.c
#include<linux/module.h>  //模块的头文件 (for module_init MODULE_LICENSE)
#include <asm/io.h>   	  //io操作的头文件(for  ioremap readl)

#define GPIO_OUT 0x6000D224 //GPIO3_PJ7的输出寄存器的地址（1：高电平 0：低电平）

unsigned char *out;	
int led_init(void)
{
    out = ioremap(GPIO_OUT , 4); //从物理地址GPIO_OUT 开始，映射4字节长度的空间到内核空间
    if (out == NULL) {  //如果映射失败，会返回空指针
	printk("ioremap GPIO_OUT error\n");
	return  -1;  //返回负数：表示失败
    }  	
    printk(" out =%x\n",readl(out)); //读out 指向空间的4字节数据(readw 2字节 readb 1字节)
    printk("led init ok\n");
    return 0;  //返回0： 表示成功
}

void led_exit(void)
{
    iounmap(out); //取消映射	
    printk("led exit\n");
}
module_init(led_init); //插入模块入口
module_exit(led_exit); //卸载模块的入口
MODULE_LICENSE("GPL v2"); //遵循的开源声明
```



##### ④查看相关寄存器

```shell
$ sudo insmod led.ko  //插入驱动模块吗，查看信息
$ dmesg  //查看内核输出日志(全是零)
$ echo 79 > /sys/class/gpio/export   //导出79号gpio 引脚，使得可在应用层访问
$ echo out > /sys/class/gpio/gpio79/direction  //设置 为输出
$ echo 1 > /sys/class/gpio/gpio79/value //输出高电平 开灯
$ sudo rmmod led //卸载模块时，查看信息
$ dmesg  //查看内核输出日志(发现值都变为了0x80)
$ echo 0 > /sys/class/gpio/gpio79/value  //输出低电平， 关灯
$ sudo insmod led.ko 
$ dmesg //发现 out 变为0
```

```
//led.c	
#include<linux/module.h>  //模块的头文件 (for module_init MODULE_LICENSE)
#include <asm/io.h>   //io操作的头文件(for  ioremap readl)

#define GPIO3  	0x6000D200 // 第3个Bank GPIO 的基地址
//---偏移量
#define CNF	0x04  //配置寄存器 (0:GPIO  1:SFIO)
#define OE   	0x14  //输出使能寄存器 (1:使能 0:关闭)
#define OUT  	0x24  //输出寄存器（1：高电平 0：低电平）
#define MSK_CNF 0x84  //配置屏蔽寄存器(高位1:屏蔽 高位0:不屏蔽   低位1:GPIO模式 低位0:SFIO模式)
#define MSK_OE  0x94  //输出使能屏蔽寄存器(高位1:禁止写   低位1:使能)
#define MSK_OUT 0xA4  //输出屏蔽寄存器(高位1:禁止写   低位1:高电平)

unsigned char *gpio_base;	

void show_reg(void)  //查看相关寄存器的内容
{
  printk(" cnf =%x\n",readl(gpio_base+CNF)); //通过基地址加偏移量，来访问对应的配置寄存器
  printk(" oe =%x\n",readl(gpio_base+OE));  
  printk(" out =%x\n",readl(gpio_base+OUT));   
  printk("mask cnf =%x\n",readl(gpio_base+MSK_CNF));
  printk("mask oe =%x\n",readl(gpio_base+MSK_OE));  
  printk("mask out =%x\n",readl(gpio_base+MSK_OUT));    	 
}
int led_init(void)
{
  gpio_base = ioremap(GPIO3, 0xFF); //从物理地址GPIO3开始，映射 0xFF字节长度的空间到内核空间
  if (gpio_base == NULL) {
    printk("ioremap gpio_base error\n");
    return  -1;
  }  		
  show_reg();
  printk("led init ok \n");
  return 0;
}

void led_exit(void)
{
  show_reg();
  iounmap(gpio_base); //取消映射
  printk("led exit \n");
}
module_init(led_init);
module_exit(led_exit);
MODULE_LICENSE("GPL v2");
```

##### ⑤开关灯

$ sudo insmod led.ko  开灯

$ sudo rmmod led  关灯

```
//文件 led.c
#include<linux/module.h>  //模块的头文件 (for module_init MODULE_LICENSE)
#include <asm/io.h>   //io操作的头文件(for  ioremap readl)

#define GPIO3  	0x6000D200 // 第3个Bank GPIO 的基地址
//---偏移量
#define CNF		0x04  //配置寄存器 (0:GPIO  1:SFIO)
#define OE   	0x14  //输出使能寄存器 (1:使能 0:关闭)
#define OUT  	0x24  //输出寄存器（1：高电平 0：低电平）
#define MSK_CNF 0x84  //配置屏蔽寄存器(高位1:屏蔽 高位0:不屏蔽   低位1:GPIO模式 低位0:SFIO模式)
#define MSK_OE  0x94  //输出使能屏蔽寄存器(高位1:禁止写   低位1:使能)
#define MSK_OUT 0xA4  //输出屏蔽寄存器(高位1:禁止写   低位1:高电平)

unsigned char *gpio_base;	

//开灯
void led_on(void)
{
  //取消GPIO3_PJ7 引脚的屏蔽
  writel(readl(gpio_base+MSK_CNF) | 1 << 7, gpio_base+MSK_CNF); //取消对GPIO模下引脚的屏蔽 
  writel(readl(gpio_base+MSK_OE) | 1 << 7, gpio_base+MSK_OE);  //取消引脚 使能屏蔽
  //配置GPIO3_PJ7 引脚  输出高电平
  writel(readl(gpio_base+CNF) | 1 << 7, gpio_base+CNF); //配置引脚为 GPIO模式
  writel(readl(gpio_base+OE) | 1 << 7, gpio_base+OE);	  //使能引脚
  writel(readl(gpio_base+OUT) | 1 << 7, gpio_base+OUT); //引脚输出高电平，点亮灯
  printk("out put high ,led on 输出高电平，点亮灯\n");
}

//关灯
void led_off(void)
{
  writel(readl(gpio_base+CNF) | 1 << 7, gpio_base+CNF); //配置引脚为 GPIO模式
  writel(readl(gpio_base+OUT) & ~(1 << 7), gpio_base+OUT);  //引脚输出低电平，灭灯
  printk("out put low, led off 输出低电平，灭灯\n");	
}

int led_init(void)
{
  gpio_base = ioremap(GPIO3, 0xFF); //从物理地址GPIO3开始，映射 0xFF字节长度的空间到内核空间
  if (gpio_base == NULL) {
    printk("ioremap gpio_base error\n");
    return  -1;
  }  		
  led_on();
  printk("led init ok \n");
  return 0;
}

void led_exit(void)
{
  led_off();
  iounmap(gpio_base); //取消映射
  printk("led exit \n");
}
module_init(led_init);
module_exit(led_exit);
MODULE_LICENSE("GPL v2");
```

##### ⑥点亮另一灯

```shell
#include <linux/module.h> 
#include <asm/io.h> //io操作的头文件（readl)

//GPIO3_PJ_7
#define GPIO3 0x6000D100 // 第3个Bank GPIO 的基地址
/*---偏移量
#define CNF     0x04  //配置寄存器 (0:GPIO  1:SFIO)
#define OE    0x14  //输出使能寄存器 (1:使能 0:关闭)
#define OUT   0x24  //输出寄存器（1：高电平 0：低电平）

#define MSK_CNF 0x84  //配置屏蔽寄存器(高位1:屏蔽 高位0:不屏蔽   低位1:GPIO模式 低位0:SFIO模式)
#define MSK_OE  0x94  //输出使能屏蔽寄存器(高位1:禁止写   低位1:使能)
#define MSK_OUT 0xA4  //输出屏蔽寄存器(高位1:禁止写   低位1:高电平)
*/
//GPIO3_PE_6
#define CNF 0x00 //配置寄存器 (0:GPIO  1:SFIO)
#define OE 0x10 //输出使能寄存器 (1:使能 0:关闭)
#define OUT 0x20 //输出寄存器（1：高电平 0：低电平）

#define MSK_CNF 0x80 //配置屏蔽寄存器(高位1:屏蔽 高位0:不屏蔽   低位1:GPIO模式 低位0:SFIO模式)
#define MSK_OE 0x90 //输出使能屏蔽寄存器(高位1:禁止写   低位1:使能)
#define MSK_OUT 0xA0 //输出屏蔽寄存器(高位1:禁止写   低位1:高电平)
unsigned char * gpio_base=NULL;

void show_reg(void)  //查看相关寄存器的内容
{
 printk(" cnf =%x\n",readl(gpio_base+CNF)); //通过基地址加偏移量，来访问对应的配置寄存器
 printk(" oe =%x\n",readl(gpio_base+OE));  
 printk(" out =%x\n",readl(gpio_base+OUT));   
 printk("mask cnf =%x\n",readl(gpio_base+MSK_CNF));
 printk("mask oe =%x\n",readl(gpio_base+MSK_OE));  
 printk("mask out =%x\n",readl(gpio_base+MSK_OUT));       
}

void led_on(void)
{
 //取消GPIO3_PJ7 引脚的屏蔽
 writel(readl(gpio_base+MSK_CNF) | 1 << 6, gpio_base+MSK_CNF); //取消对GPIO模下引脚的屏蔽 
 writel(readl(gpio_base+MSK_OE) | 1 << 6, gpio_base+MSK_OE);  //取消引脚 使能屏蔽
 //配置GPIO3_PJ7 引脚  输出高电平
 writel(readl(gpio_base+CNF) | 1 << 6, gpio_base+CNF); //配置引脚为 GPIO模式
 writel(readl(gpio_base+OE) | 1 << 6, gpio_base+OE);   //使能引脚
 writel(readl(gpio_base+OUT) | 1 << 6, gpio_base+OUT); //引脚输出高电平，点亮灯
 printk("out put high ,led on 输出高电平，点亮灯\n");  
}
void led_off(void)
{
 writel(readl(gpio_base+CNF) | 1 << 6, gpio_base+CNF); //配置引脚为 GPIO模式
 writel(readl(gpio_base+OUT) & ~(1 << 6), gpio_base+OUT);  //引脚输出低电平，灭灯
 printk("out put low, led off 输出低电平，灭灯\n");    
}
int led_init(void)
{
 gpio_base = ioremap(GPIO3, 0xFF); //从物理地址GPIO3开始，映射 0xFF字节长度的空间到内核空间
 if (gpio_base == NULL) {
 printk("ioremap gpio_base error\n");
 return  -1;
  }   
 led_on();
 show_reg(); 
 printk("led init GPIO3_PE_6  333 \n");
 return 0; //放回0：表示成功
}

void led_exit(void)
{
 led_off();
 show_reg(); 
 iounmap(gpio_base); //取消映射
 printk("led exit ok\n");   
}
module_init(led_init);  //声明 led_init 是内核模块加载入口 insmod led.ko 会触发调用 led_init
module_exit(led_exit);  //声明led_exit是内核模块的卸载入口 rmmod led  会触发调用  led_exit
MODULE_LICENSE("GPL v2"); //遵循的开源声明
```

#### 8、排查思路(灯点不亮)

##### ①网络搜

```shell
网络搜  //找灵感(核心是关键词)	 
"jetson 点灯示例"   	
"GPIO 灯点不亮" //找提示,发现有一个说GPIO  ARM需设置时钟可能灯需外界上拉电阻         
官方论坛搜GPIO //https://forums.developer.nvidia.com/t/gpio-customization-on-jetson-platform/163609   GPIO customization on Jetson Platform 
```

##### ②细看芯片手册

```shell
细看芯片手册  //寄存器不对(错了，漏了)
             //仔细看一下，是寄存器位数设错了，哪个开关没打开等              
全芯片手册中搜GPIO //找相关的寄存器，看是哪个没设置，导致GPIO没有输出 

时钟 // GPIO需时钟启动吗， 配置GPIO寄存器才有效吗
pinmux //管脚复用需配置，如何配置
电源  //GPIO需电源支持，如上拉电阻，内部电源供电开关等
```

##### ③找OK的做参考

###### (1)从应用层

```shell
//命令：
echo 79 > /sys/class/gpio/export
echo out > /sys/class/gpio/gpio79/direction
echo 1 > /sys/class/gpio/gpio79/value  //输出高电平，点亮灯
echo 79 > /sys/class/gpio/unexport	
//官方OK的程序示例： 如 python点灯示例(略)
```

###### (2)从内核层

```
内核源码里官方示例
```

###### (3从硬件层

```shell
//用gpio命令点亮灯
$ gpio  set  J7  //设置GPIO3_J7 输出高电平         
$ gpio  status J7 //查看J7管脚情况
                  // $ gpio  status -a  查看所有管脚  	
$ mw 0x70003150 0x05  //pin_mux 设置后，发现灯亮了
$ md 0x70003150      //查看内容，看设置成功否
$ gpio  clear  J7	  //灭灯

//用mw命令点亮灯
$ mw 0x6000D284 0x80  //使能写权限
$ mw 0x6000D294 0x80  //使能输出权限
$ mw 0x70003150 0x05  //pin_mux 
$ mw 0x6000D204 0x80  //向 0x6000D204中写入值0x80 -> 把pin12（GPIO3_PJ.07）配置为GPIO模式
                      //注意可能设置无效，原因时GPIO_MSK_CNF_0有写限制需打开
$ mw 0x6000D214 0x80  //使能output 
     
$ md 0x6000D204   //查看寄存器的值（发现 有6个寄存器变成80）
```

##### ④系统跟踪(侦探破案): 应用层 -》 内核层 -》 硬件层

```
问题 //灯点不亮，或驱动中方向需设为out，灯才能点亮
     //必须 echo out > /sys/class/gpio/gpio79/direction 成功后，操作其它寄存器才会有效	
	
线索 //找OK例子切入，顺藤摸瓜: 命令 -> 源码 -> 设备树 -> 芯片手册 (你对系统的认知深度，决定你的段位)
     //找转换关系: 板子丝印 -> 电路图 -> 芯片手册 -> 设备树 -> u-boot -> kernel -> app(python/c)
     //找引脚 对应的寄存器: 电路图芯片手册，设备树，源码（u-boot/kernel)  三合一找线索 
     //启动信息: 从内核启动信息中搜 gpio
     //     找到 gpiochip_setup_dev: registered GPIOs 0 to 255 on device: gpiochip0 (tegra-gpio)
     //     内核源码中 搜 gpiochip_setup_dev
```

###### (1)从OK的示例切入

```
//命令：
echo 79 > /sys/class/gpio/export
echo out > /sys/class/gpio/gpio79/direction
echo 1 > /sys/class/gpio/gpio79/value  //输出高电平，点亮灯
echo 79 > /sys/class/gpio/unexport	
```

###### (2)源码跟踪

###### (3)暴露到应用层的接口

```shell
$ sudo cat  /sys/kernel/debug/gpio      //查看gpio 管脚配置
$ sudo cat  /sys/kernel/debug/tegra_gpio	 //查看GPIO 寄存器内容
$ sudo cat  /sys/kernel/debug/tegra_pinctrl_reg  //查看 pinctrl 寄存器内容
        //在echo out > /sys/class/gpio/gpio79/direction导出时 0x70003150的值会变化
	//echo Bank: 1 Reg: 0x70003150 Val: 0x00000005 -> dap4_sclk_pj7   	
```

###### (4)设备树 

```shell
//tegra210-soc-base.dtsi   CPU基本配置
//位置: public_sources\hardware\nvidia\soc\t210\kernel-dts\tegra210-soc\
 compatible = "nvidia,tegra210"; //节点ID: 厂商(nvidia)+ 设备型号(tegra210)
	                         //兼容性： 驱动和设备匹配的依据

  pinmux: pinmux@700008d4 { //管脚复用配置
    compatible = "nvidia,tegra210-pinmux";  //详细管脚映射 见驱动 pinctrl-tegra210.c
    reg = <0x0 0x700008d4 0x0 0x2a5    /* Pad control registers  */   -> 芯片手册 
           0x0 0x70003000 0x0 0x294>; /* Mux registers */
		#gpio-range-cells = <3>;
		status = "disabled";
 };
  gpio: gpio@6000d000 {//gpio子节点
    compatible = "nvidia,tegra210-gpio", "nvidia,tegra124-gpio", "nvidia,tegra30-gpio";
    reg = <0x0 0x6000d000 0x0 0x1000>; //前2个数表示起始地址(由父节点的#address-cells = <2> 决定)
                                       //后2个数表示长度范围(由父节点的#size-cells = <2> 决定)
  }
```

###### (5)芯片手册

```shell
//pinmux -> DAP4_SCLK	
2.1 System Address Map	
MISC 7000:0000 7000:3fff 0000:0000 0000:3fff 16 KB
GP 				 0000:0800 0000:0bff 1 KB
PINMUX_AUX 0000:3000 0000:3fff 4 KB
9.5.2 Per Pad Control Group
DRVDN / UP Drive Down / Up. Driver Output Pull-Up/Pull-Down drive strength code. Normally, the code is 5 bits
DAP4_SCLK 0x70000980 16:12 24:20
	
9.15.82 PINMUX_AUX_DAP4_SCLK_0
Offset: 0x3150 | Read/Write: R/W | Reset: 0x00000074 (0bxxxxxxxxxxxxxxxxxxx00xx001110100)	
			
21.1.4.43 APB_MISC_GP_DAP4_SCLK_CFGPADCTRL_0
DAP4_SCLK_CFG Pad control register
Offset: 0x980 | Read/Write: R/W | Reset: 0x00000000 (0bxxxxxxx00000xxx00000xxxxxxxxxxxx)
Bit  Reset Description
24:20 0x0 CFG2TMC_DAP4_SCLK_CFG_CAL_DRVUP
16:12 0x0 CFG2TMC_DAP4_SCLK_CFG_CAL_DRVDN
	
#define  DAP4_SCLK_CFG  				 0x70000980
#define  PINMUX_AUX_DAP4_SCLK_0  0x70003150
```

###### (6)示例代码：内核层点灯

```c
#include<linux/module.h>  //模块的头文件 (for module_init MODULE_LICENSE)
#include <asm/io.h>   //io操作的头文件(for  ioremap readl)

#define GPIO3  	0x6000D200 // 第3个Bank GPIO 的基地址
//---偏移量
#define CNF	0x04  //配置寄存器 (0:GPIO  1:SFIO)
#define OE   	0x14  //输出使能寄存器 (1:使能 0:关闭)
#define OUT  	0x24  //输出寄存器（1：高电平 0：低电平）
#define MSK_CNF 0x84  //配置屏蔽寄存器(高位1:屏蔽 高位0:不屏蔽   低位1:GPIO模式 低位0:SFIO模式)
#define MSK_OE  0x94  //输出使能屏蔽寄存器(高位1:禁止写   低位1:使能)
#define MSK_OUT 0xA4  //输出屏蔽寄存器(高位1:禁止写   低位1:高电平)


#define  DAP4_SCLK_PJ7  0x70003150

unsigned char *gpio_base;	
unsigned char *gpio_pinmux;	
//查看相关寄存器的内容
void show_reg(void)  
{
    printk(" cnf =%x\n",readl(gpio_base+CNF)); //通过基地址加偏移量，来访问对应的配置寄存器
    printk(" oe =%x\n",readl(gpio_base+OE));  
    printk(" out =%x\n",readl(gpio_base+OUT));   
    printk("mask cnf =%x\n",readl(gpio_base+MSK_CNF));
    printk("mask oe =%x\n",readl(gpio_base+MSK_OE));  
    printk("mask out =%x\n",readl(gpio_base+MSK_OUT));    	 
    printk("gpio_pinmux  =%x\n",readl(gpio_pinmux));    	 
}

//开灯
void led_on(void)
{
	//取消GPIO3_PJ7 引脚的屏蔽
	writel(readl(gpio_base+MSK_CNF) | 1 << 7, gpio_base+MSK_CNF); //取消对GPIO模下引脚的屏蔽 
	writel(readl(gpio_base+MSK_OE) | 1 << 7, gpio_base+MSK_OE);  //取消引脚 使能屏蔽
  //配置GPIO3_PJ7 引脚  输出高电平
	writel(readl(gpio_base+CNF) | 1 << 7, gpio_base+CNF); //配置引脚为 GPIO模式
	writel(readl(gpio_base+OE) | 1 << 7, gpio_base+OE);	  //使能引脚
         writel(readl(gpio_base+OUT) | 1 << 7, gpio_base+OUT); //引脚输出高电平，点亮灯
	printk("out put high ,led on 输出高电平，点亮灯\n");
}

//关灯
void led_off(void)
{
	writel(readl(gpio_base+CNF) | 1 << 7, gpio_base+CNF); //配置引脚为 GPIO模式
        writel(readl(gpio_base+OUT) & ~(1 << 7), gpio_base+OUT);  //引脚输出低电平，灭灯
	printk("out put low, led off 输出低电平，灭灯\n");	
}

int led_init(void)
{
	gpio_base = ioremap(GPIO3, 0xFF); //从物理地址GPIO3开始，映射 0xFF字节长度的空间到内核空间
	if (gpio_base == NULL) {
		printk("ioremap gpio_base error\n");
		return  -1;
	}  		
	gpio_pinmux = ioremap(DAP4_SCLK_PJ7, 8); 
	if (gpio_pinmux == NULL) {
		printk("ioremap gpio_pinmux error\n");
		return  -1;
	}  	
    writel(readl(gpio_pinmux) & ~(1 << 4), gpio_pinmux);

  led_on();
  show_reg();
  printk("led init ok go  2021\n");
  return 0;
}

void led_exit(void)
{
  led_off();
   show_reg();
  iounmap(gpio_base); //取消映射
  printk("led exit \n");
}
module_init(led_init);
module_exit(led_exit);
MODULE_LICENSE("GPL v2");
```

##### ⑤裸机程序复位的问题  -》 最简化

```
# go 84000000  //运行程序
               //如果是异常重启，可能是顺序执行到非法区域，或某指令写非法地址	
 
//用gpio命令点亮灯 （用OK的方式把灯点亮点灭）
$ gpio  set  J7  //设置GPIO3_J7 输出高电平         
$ mw 0x70003150 0x05  //pin_mux 设置后，发现灯亮了
$ mw 0x6000D224 0x80  //点灯
$ mw 0x6000D224 0x00  //灭灯 
	      
// 用最简的汇编指令实现	  点亮灯  把 0x6000D224   设为 0x80
// 注： 最后通过最简化 方式发现 需把.equ宏去掉灯才能点亮，不会复位了	 
```

###### (1)最简汇编程序

```assembly
//led.s
    ldr x1,=0x6000D224 //不能用宏.equ，否则，当str写时，会复位
    mov w0,#0x80
    str w0,[x1]   //当str时会复位，甚至怀疑过，是否新版本的u-boot，打开了mmu映射，最后发现不是
 
loop_end:
    b  loop_end
```

##### ⑥LED 裸机汇编示例

```shell
$ make 
$ cp led.bin /tftpboot

//---板子端
板子重启 停在u-boot处
# pci enum;pci
# tftp led.bin   //如果有问题，见前面 uboot的tftp下载
# go 84000000  //运行裸机程序， 可成功看到，灯闪烁了一下，才复位板子（是故意让它继续运行，复位的，避免手动复位）
```

```
//led.s
    //pin mux set gpio mode 
    ldr x1,=0x70003150 //注意：不能用宏.equ，否则，当str写时，会复位
    mov w0,#0x05      
    str w0,[x1]

    mov w0,#0x80
    //取消GPIO3_PJ7 引脚的屏蔽
    ldr x1,=0x6000D284 
    str w0,[x1]
    //取消GPIO3_PJ7 引脚的使能屏蔽
    ldr x1,=0x6000D294 
    str w0,[x1]
    //配置引脚为 GPIO模式 
    ldr x1,=0x6000D204 
    str w0,[x1]
    //使能引脚
    ldr x1,=0x6000D214 
    str w0,[x1]
    //引脚输出高电平，点亮灯
    ldr x1,=0x6000D224 
    str w0,[x1]

    //led off
    bl   delay1s
    mov w0,#0x00
    str w0,[x1]

    //led on
    bl   delay1s
    mov w0,#0x80
    str w0,[x1]

    //led off
    bl   delay1s
    mov w0,#0x00
    str w0,[x1]

//loop_end:
 //   b  loop_end   //如果不加死循环，会导致指令顺序执行到未知区域导致复位
    b   go_run   //

delay1s:	
    ldr	    x4,=0xffffffa
loop_delay:
    sub     x4,x4,#1
    cmp     x4,#0
    cbz     x4,delay_end        
    b.ne    loop_delay
delay_end:      
    ret       

go_run:
```

##### ⑦LED 裸机C语言示例

```shell
$ make   
$ cp led.bin /tftpboot

注意 //链接地址 必须是你下载到内存的地址，如0x84000000  ,
     //如果是别的地址如0x80009000,会复位，原因是b main 时 b指令跳转时是有范围限制的。

//---板子端
板子重启 停在u-boot处
# pci enum;pci
# tftp led.bin   //注意：多敲几次，一次有可能下载不完整，导致运行复位 
# go 84000000
```

###### (1)汇编程序

###### (2)C程序

###### (3)Makefile

###### (4)链接脚本

#### 9、PWM

#### ①电路图与管脚映射

#### ②芯片手册之管脚复用

#### ③芯片手册之PWM模块

#### ④芯片手册之时钟设置

#### ⑤最简测试

#### ⑥露到应用层的接口

#### ⑦驱动

### 五、串行接口

#### 1、UART

#### 2、I2C

#### 3、SPI

### 六、U-BOOT使用

#### 1、初识U-BOOT

#### 2、U-BOOT命令

##### ①查看支持的命令

##### ②环境变量√

```shell
#pri   //输入pri的命令 查看uboot环境变量
#setenv ipaddr 192.168.5.8  //设置环境变量
#saveenv  //保存环境变量

#bootdelay  延时
#baudrate 波特率

#pri bootcmd  //查看自启动命令
#setenv bootcmd pci enum \; pci \; run distro_bootcmd
```

##### ③常用命令

#### 3、U-BOOT编译烧写

#### 4、模拟器调试U-BOOT

#### 5、内存中调试U-BOOT

#### 6、点灯(确定运行位置)

#### 7、用点灯法跟踪调试(串口初始化前)

#### 8、用打印信息跟踪调试(串口初始化后)

#### 9、源码跟踪vim命令使用

### 七、U-BOOT源码分析

#### 1、脚本

#### 2、入口

#### 3、异常向量表

#### 4、准备C语言的执行环境

#### 5、前置板级初始化(重定位前)

#### 6、后置板级初始化(重定位后)

#### 7、进入主循环(无输入自启动，有输入则进入交互模式)

#### 8、跟踪示例

### 八、U-BOOT驱动开发

#### 1、自定义命令

#### 2、C语言嵌入汇编

#### 3、中断

#### 4、定时器中断

#### 5、按键中断

## 叁、系统移植

### 一、开发环境√

#### 1、初识√

```c
What 是什么，难不难学 //硬件变化，软件相应的改 -> 核心是定制
     //手机： 摄像头高清 夜拍 全景 屏幕 指纹识别 
     //家用机器人： 大屏幕，语音对话，远程监控聊天，摄像头定位导航，升降杆
     //逗猫机器人：逗猫杆 喂食器，马达控制
     //未来：大移植战略，底层的系统移植，和应用移植，这里指底层系统移植
     
Why 为什么学，学了能干嘛
     //面试，简历中，要求会内核移植裁剪
     //工作中硬件不断更新，需不断移植优化调整
     //未来：开源时代，一切皆移植，如何资源整合。
       
How 怎么才能学好，关键点在哪
     //难点：怎么改改哪里，对系统不熟悉  重点: 内核移植，设备树（结合电路图芯片手册）
     //从零开始，如何移植u-boot 内核和rootfs，构建完整知识体系，学会通用移植方法，思维
     //学习方式： 学三国的诸葛亮,广博，抓重点，关注改的部分，而不是细节
     //面向面试工作，结合以前项目经验讲解
```

```shell
系统移植：硬件变化后软件做相应的修改 
uboot、Linux内核、根文件系统
系统移植的模块不在于代码量多大，而是关注于需要修改的地方有多少(时间成本)
```

#### 2、BSP开发框架√

##### ①官方下载√

```c
https://developer.nvidia.com/embedded/linux-tegra BSP官网入口 概要介绍 列举了推荐下载的发布的稳定版本（如32.6 现在是最新版本36.2）

***https://docs.nvidia.com/jetson/archives/l4t-archived/l4t-3261/index.html  BSP开发文档(针对32.6.1版本)

https://developer.nvidia.com/embedded/jetson-linux-archive	其他版本列举
    //注：我们前面从零制作的镜像就是32.6.1的，所以我们这里以这个版本位切入进行学习
    //登录板子 $ head -n 1 /etc/nv_tegra_release  可查看当前版本
	// # R32 (release), REVISION: 6.1, GCID: 27863751, BOARD: t210ref, EABI: aarch64, DATE: Mon Jul 26 19:20:30 UTC 2021 

//BSP指针对特定硬件平台(英伟达)的软件包 
1、BSP开发框架 //下载: Jetson Nano -> L4T Driver Package (BSP)  -> 下载后得到 Jetson-210_Linux_R32.6.1_aarch64.tbz2 262M
            //它是BSP开发的总框架入口(包含BSP安装脚本，内核uboot等源码需通过框架里的脚本来下载）

2、BSP源码包  //下载： Jetson Nano -> L4T Driver Package (BSP) Sources -> 下载后得到 public_sources.tbz2   155M
           //它是BSP源码离线包(包括linux kernel u-boot等),可不用BSP开发框架脚本下载源码包
           
3、rootfs     //下载： Sample Root Filesystem -> 下载后得到  Tegra_Linux_Sample-Root-Filesystem_R32.6.1_aarch64.tbz2  1.4G  
           //它是已经制作好的根文件系统镜像，可直接用。
           //如果想自己制作它，可下载 Sample Root Filesystem Sources 下载后得到 ubuntu_bionic-l4t_lxde_aarch64_src.tbz2  5G	//这个太大了，暂时不下载
           
4、交叉编译工具链  //下载: GCC 7.3.1 for 64 bit BSP and Kernel -> 下载后得到  gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu.tar.xz   109M    
             //它是已制作好的可直接用，想从头做的也可下对应源码包，但没必要
```

##### ②虚拟机扩容√

```shell
关机态 ->虚拟机 -> 设置 -> 硬盘(SCSI) -> 添加 -> 
       -> 创建新虚拟磁盘 -> 大小设为60G -> -> 完成 -> 确定 ->开启虚拟机 

$ sudo fdisk -l /*查看设备情况
   Disk /dev/sdb：60 GiB   这是新增的磁盘
$ sudo fdisk  /dev/sdb  //磁盘分区
  输入m -> n -> p -> 1 -> 回车 回车 -> w
$ sudo fdisk -l  /*查看分区成功否
  /dev/sdb1        2048 125829119 125827072  60G  分区后的磁盘

$ sudo mkfs -t ext3 /dev/sdb1  //格式化成ext3的文件系统
$ mkdir bsp
$ sudo mount /dev/sdb1 bsp  //挂载设备到该目录
$ ls bsp  //查看，如果有 lost+found，表示成功
```

##### ③拷贝文件：通过共享文件夹√

```shell
$ vmware-hgfsclient  //启动共享文件夹服务
$ mkdir win_share   //自己创建共享文件夹(不用/mnt/hgfs)，如果已存在文件夹把它删掉，重新建
$ vmhgfs-fuse .host:/  win_share  //挂载共享目录
$ ls win_share //看到共享的内容，表示成功
$ cd win_share/share/
$ cp Jetson-210_Linux_R32.6.1_aarch64.tbz2  ~/bsp  //主框架
$ cp public_sources.tbz2  ~/bsp  //bsp源码(内核 u-boot)
$ cp gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu.tar.xz  ~/bsp  //交叉编译工具链
$ cp Tegra_Linux_Sample-Root-Filesystem_R32.6.1_aarch64.tbz2 ~/bsp //制作好的rootfs 样例
```

##### ④创建开发框架目录√

```c
$ cd ~/bsp   //用于存放官方BSP包Jetson-210_Linux_R32.6.1_aarch64.tbz2的目录。

//解压后得到BSP开发框架的空壳即:Linux_for_Tegra文件，source文件里没有内容
1、$ tar -xvf 	Jetson-210_Linux_R32.6.1_aarch64.tbz2 //它是英伟达提供的BSP框架（不包括源码包）

//自动填充到Linux_for_Tegra/source/public
2、$ tar -xvf public_sources.tbz2 //public_sources是从BSP框架中独立出来的内核源码压缩包。
$ cd Linux_for_Tegra/source/public

$ tar -xvf kernel_src.tbz2  //解压Linux内核(解压后生成 kernel和hardware )
                             //hardware 是独立出来的硬件信息部分，包括设备树和头文件
3、$ sudo tar -xvf Tegra_Linux_Sample-Root-Filesystem_R32.6.1_aarch64.tbz2  -C ~/bsp/Linux_for_Tegra/rootfs   //解压rootfs到对应目录
```

###### 内核编译安装

```c
注 //修改Makefile 直接写死，简单方便，但是是侵入时的。如果编译匹配别的板子，不方便
$ cd kernel/kernel-4.9
$ vim Makefile /*直接指定ARCH  CROSS_COMPILE （写死的）
#ARCH           ?= $(SUBARCH)
ARCH            = arm64
#CROSS_COMPILE  ?= $(CONFIG_CROSS_COMPILE:"%"=%)
CROSS_COMPILE   = aarch64-linux-gnu-
*/
$ export LOCALVERSION=-tegra //导入配置前需设置它，
    //否则后面安装 modules_install后, rootfs/lib/modules下不是4.9.253-tegra 而是4.9.253， 
    //导致内核模块.ko 都不能加载, 启动后用lsmod可查看是空的
$ make tegra_defconfig  //导入官方配置( 见 kernel-4.9\arch\arm64\configs\tegra_defconfig)
$ make menuconfig  /*菜单配置
        报错：<command-line>:0:12: fatal error: curses.h: No such file or directory
        解决：sudo apt-get install libncurses5-dev   如果网络报错，是虚拟机能上网

$ make  -j4  /*编译(内核和内核模块都会编译,有生成arch/arm64/boot/Image 表示成功)
报错；gcc: error: unrecognized command line option ‘-mlittle-endian’
解决：空格ARCH 和CROSS_COMPILE 的?= 应该换为=

报错: make: aarch64-linux-gcc: Command not found
解决：把aarch64-linux-改为 aarch64-linux-gnu- 才对*/	

//将基于英伟达编译的镜像导入BSP框架中。注意修改前 ，需备份原镜像（如kernel下的Image和dtb）
$ cp arch/arm64/boot/Image  		~/bsp/Linux_for_Tegra/kernel/Image    //安装内核
$ cp arch/arm64/boot/dts/*.dt*   ~/bsp/Linux_for_Tegra/kernel/dtb/        //安装设备树*/
$ sudo make  modules_install INSTALL_MOD_PATH=~/bsp/Linux_for_Tegra/rootfs  //安装模块(ko) 到指定位置	
注意  ~/Linux_for_Tegra 目录 其实就是~/bsp/Linux_for_Tegra 的软连接 （类似快捷方式）
      Linux_for_Tegra/kernel/ 是英伟达刷机的内核镜像存放目录，当你采用usb线刷机时，必须你的Image拷贝到该目录。
```

##### ⑤构建√

```shell
$ cd ~/bsp/Linux_for_Tegra/Linux_for_Tegra

#会将Linux_for_Tegra文件下的Image、dts、rootfs生成一个总的镜像
$ sudo ./apply_binaries.sh 		/*构建开发框架，如果报Success!表示成功
  报错： 1. The root filesystem, provided with this package
  $ sudo chown -R root:root rootfs/   递归更改文件夹的权限，该目录必须是 root用户创建的
  报错：ERROR qemu not found! To install时
  $ sudo apt-get install qemu-user-static
```

##### ⑥刷整机√

```c
注意 //如果是国产版，内置emmc启动的，刷机见 天眼-> 开发板SDK包 -> 国产的B01板子的补充说明 ->BSP刷机精简版
//这里是针对 国外原版sd卡启动
//即 jetson-nano-qspi-sd 表示刷机SD卡，  jetson-nano-qspi-emmc表示刷机 内置emmc
```

###### (1)需先进入恢复模式

```c
参考  //https://docs.nvidia.com/jetson/archives/l4t-archived/l4t-3261/index.html -> 快速开始 -> 强制恢复模式

载板 B01，J50 的引脚 9和 10需插入跳线帽 //位于 Jetson 模块下方的载板边缘，调试usb口的旁边

用micro usb线，连接板子和电脑，板子重上电  //用usb线来刷机
$ lsusb   //如看到下面信息，表示进入了恢复模式
Bus 003 Device 008: ID 0955:7f21 NVIDIA Corp
```

###### (2)刷整机

```c
cd  ~/bsp/Linux_for_Tegra
$ sudo ./flash.sh jetson-nano-qspi-sd mmcblk0p1 /*刷整机镜像
    看到 The target t210ref has been flashed successfully. 表示成功*/
```

###### (3)初始设置

```c
拔掉跳线帽，重启板子
//方法一: 显示器上设置(略)
接上HDMI线，重启板子后，在显示器上会显示ubuntu初始设置,按以前方式设置即可。

//方法二: 命令行设置
重启后，串口终端上会显示一个串口， //通过micro usb线，模拟生成一个串口(不用另外接串口转usb的线）
//通过黑白文字界面，通过tab enter 和上下键，可进行简单设置，网络可先跳过设置，后面登录后再通过命令来设置
```

###### (4)远程登录

```c
//wifi设置
$ sudo nmcli device wifi connect 'TP-LINK_312shiyanshi' password 'WEARESUPERMEN'
$ ifconfig //查看当前ip 如  192.168.0.148

//远程登录  打开虚拟机  先备份之前的
$ mv .ssh .ssh.bak2
$ ssh dengzj@192.168.0.148 //输入密钥即可登录
免密登录见前面
```

##### ⑦免密登录SSH√

```c
//虚拟机端	
$ ssh-keygen -t rsa  //生成Key私钥和公钥
$ ls ~/.ssh //发现有生成文件 私钥id_rsa 和 公钥id_rsa.pub
$ cd ~/.ssh
$ scp id_rsa.pub dengzj@192.168.0.148:/home/dengzj/   //上传公钥到板子

//板子端
$ mkdir .ssh
$ cp id_rsa.pub  .ssh/authorized_keys  //拷贝文件到.ssh下并重命名为 authorized_keys 

//测试免密登录：  
$ ssh dengzj@192.168.0.148 //不用输密码，表示成功。	关键是，不卡了(因密钥登录检测比较多，会比较卡)

//win10下免密登录
用虚拟机里 .ssh 替换 win10 当前用户目录下的 .ssh
> ssh dengzj@192.168.0.148    //发现能和Ubuntu里一样免密登录
```

VSCODE远程登录

```shell
//原VSCODE远程登录编辑
把原来的.ssh/config 拷贝到新的.ssh目录里就可以了  需要添加相关配置文件并进行修改对应用户名dengzj
```

##### ⑧U-BOOT编译烧写√

```shell
$ cd  ~/bsp/Linux_for_Tegra/source/public
$ tar -xvf  u-boot_src.tbz2 #解压u-boot
$ cd  u-boot
确认已安装交叉编译工具链 #输入aar 按tab键能补全为aarch64-linux-gnu-，说明有安装
$ vim Makefile  /* 指定交叉编译工具链 
把CROSS_COMPILE ?= aarch64-linux-gnu-
添加到下面代码前
ifeq ($(HOSTARCH),$(ARCH))
   CROSS_COMPILE ?=
#endif	

$ make distclean
#./source/public/u-boot/configs/p3450-0000_defconfig
$ make 	p3450-0000_defconfig  #配置u-boot 为 jetson nano 板子的
见p3450由来，https://docs.nvidia.com/jetson/archives/l4t-archived/l4t-3261/index.html
的u-boot构建 里面的 命令中的占位符 里面可查到 jetson nano 板子的id号
p3450-0000  p3450-0000_defconfig配置在configs下可查到，这是英伟达官方已做好的
  
  报错： /bin/sh: 1: bison: not found
  解决：sudo apt-get install bison
  报错： /bin/sh: 1: flex: not found
  解决：sudo apt-get install flex  
  
$ vim  arch/arm/mach-tegra/board.c  #添加打印信息
在dram_init 函数里添加
    printf("dram_init entry\n");
$ make   #编译，看到下面信息表示成功
  COPY    u-boot.bin
  SYM     u-boot.sym
  COPY    u-boot.dtb
  CFGCHK  u-boot.cfg
```

###### 只刷U-BOOT

```c
$ cd  ~/bsp/Linux_for_Tegra/bootloader/t210ref/p3450-0000  //注意别弄错了 是p3450-0000的目录
$ mv u-boot.bin  u-boot.bin.org   //备份原镜像

$ ~/u-boot
//将基于英伟达的uboot复制到当前目录
$ cp u-boot.bin  ~/bsp/Linux_for_Tegra/bootloader/t210ref/p3450-0000	

$ sudo ./flash.sh -k LNX jetson-nano-qspi-sd mmcblk0p1	/*刷机成功，会看到下面信息
   The [LNX] has been updated successfully. */
断开强制恢复模式 的短线帽，重启板子 /* 成功，可看到u-boot时间有更新，和自己添加的打印信息。
U-Boot 2020.04 (Jan 29 2022 - 17:13:21 +0800)

SoC: tegra210
Model: NVIDIA Jetson Nano Developer Kit
Board: NVIDIA P3450-0000
DRAM:  dram init entry   这是我们添加的打印信息*/
```

##### ⑨内核编译烧写

###### (1)备份原烧录文件√

```shell
$ cp  ~/bsp/Linux_for_Tegra/kernel/Image    ~/bsp/Linux_for_Tegra/kernel/Image.org   //备份原内核镜像
$ cp  -rf ~/bsp/Linux_for_Tegra/kernel/dtb    ~/bsp/Linux_for_Tegra/kernel/dtb.org //备份设备树镜像
$ sudo cp  -rf ~/bsp/Linux_for_Tegra/rootfs/lib/modules  ~/bsp/Linux_for_Tegra/rootfs/lib/modules.org //备份

已安装的内核模块(.ko)
        //或用sudo tar --owner root --group root -cjf kernel_supplements.tbz2   lib/modules 归档备份
        // kernel/kernel_supplements.tbz2 就是原内核模块的备份，如果要恢复，拷贝到~/Linux_for_Tegra/rootfs 解压即可	
```

###### (2)官方编译方式(可选)

```shell
注 //官方采用非侵入式（不修改源码的）,指定输出目录方式
  //不推荐用，因指定到别的输出目录，每次重编，所有的文件都会重新编译，时间非常长
$ TEGRA_KERNEL_OUT=~/kernel_out	   //设置内核编译后的输出目录
$ echo $TEGRA_KERNEL_OUT  //查看环境变量设置好没
$ mkdir -p $TEGRA_KERNEL_OUT  //创建目录
$ export CROSS_COMPILE=aarch64-linux-gnu-  //设置交叉编译工具链前缀
$ export LOCALVERSION=-tegra  //设定版本号(对应 rootfs/lib/modules/4.9.253-tegra )
$ cd ~/Linux_for_Tegra/source/public/kernel/kernel-4.9
$ make ARCH=arm64 O=$TEGRA_KERNEL_OUT tegra_defconfig  //导入配置
$ make ARCH=arm64 O=$TEGRA_KERNEL_OUT -j4 //编译内核
     
//拷贝到烧写目录
$ cp  $TEGRA_KERNEL_OUT/arch/arm64/boot/Image  ~/Linux_for_Tegra/kernel/   //替换内核镜像
$ cp -rf $TEGRA_KERNEL_OUT/arch/arm64/boot/dts/*.dt*   ~/bsp/Linux_for_Tegra/kernel/dtb/        //安装设备树*/
$ sudo make ARCH=arm64 O=$TEGRA_KERNEL_OUT modules_install \   
    	INSTALL_MOD_PATH=~/Linux_for_Tegra/rootfs        //安装内核模块（到lib/modules里）
$ ls  ~/Linux_for_Tegra/rootfs/lib/modules   //确认安装好否
    //如果是4.9.253   需手动改为 4.9.253-tegra   ，否则内核启动后，所有内核模块 .ko都不会加载，启动后用lsmod可查看是空的 
```

###### (3)侵入式编译方式√

```shell
注 //修改Makefile 直接写死，简单方便，但是是侵入时的。如果编译匹配别的板子，不方便
$ cd kernel/kernel-4.9
$ vim Makefile /*直接指定ARCH  CROSS_COMPILE （写死的）
#ARCH           ?= $(SUBARCH)
ARCH            = arm64
#CROSS_COMPILE  ?= $(CONFIG_CROSS_COMPILE:"%"=%)
CROSS_COMPILE   = aarch64-linux-gnu-
*/
$ export LOCALVERSION=-tegra //导入配置前需设置它，
    //否则后面安装 modules_install后, rootfs/lib/modules下不是4.9.253-tegra 而是4.9.253， 
    //导致内核模块.ko 都不能加载, 启动后用lsmod可查看是空的
$ make tegra_defconfig  //导入官方配置( 见 kernel-4.9\arch\arm64\configs\tegra_defconfig)
$ make menuconfig  /*菜单配置
        报错：<command-line>:0:12: fatal error: curses.h: No such file or directory
        解决：sudo apt-get install libncurses5-dev   如果网络报错，是虚拟机能上网
        */

$ make  -j4  /*编译(内核和内核模块都会编译,有生成arch/arm64/boot/Image 表示成功)
报错；gcc: error: unrecognized command line option ‘-mlittle-endian’
解决：
空格ARCH 和CROSS_COMPILE 的?= 应该换为=

报错: make: aarch64-linux-gcc: Command not found
解决：
把aarch64-linux-改为 aarch64-linux-gnu- 才对

//注意修改前 ，需备份原镜像（如kernel下的Image 和dtb）
$ cp arch/arm64/boot/Image  ~/Linux_for_Tegra/kernel/Image    //安装内核
$ cp arch/arm64/boot/dts/*.dt*   ~/Linux_for_Tegra/kernel/dtb/        //安装设备树*/
$ sudo make  modules_install INSTALL_MOD_PATH=~/Linux_for_Tegra/rootfs  //安装模块(ko) 到指定位置	
```

###### (4)脚本编译方式（推荐）

```shell
注 //非侵入，每次运行脚本即可

$ cd /home/yhai/bsp/Linux_for_Tegra/source/public/kernel/kernel-4.9
$ vim bulid.sh /* 创建脚本	
export CROSS_COMPILE=aarch64-linux-gnu-
export LOCALVERSION=-tegra
make ARCH=arm64  tegra_defconfig
make ARCH=arm64 -j4
cp  arch/arm64/boot/Image   ~/Linux_for_Tegra/kernel/
cp -rf arch/arm64/boot/dts/*.dt*  ~/Linux_for_Tegra/kernel/dtb/
sudo make ARCH=arm64 modules_install INSTALL_MOD_PATH=~/Linux_for_Tegra/rootfs
*/
$ sudo chmod 777 bulid.sh

$ ./bulid.sh //运行脚本,自动完成编译和拷贝到烧写目录
```

###### (5)刷机

```c
$ sudo ./flash.sh jetson-nano-qspi-sd mmcblk0p1 /*刷整机(内核Image，英伟达是放在rootfs/boot下，即是在system.img中，不能单独刷机的)
 启动后，能成功看到内核启动信息，可看到内核编译时间，如下 
[    0.000000] Booting Linux on physical CPU 0x0
[    0.000000] Linux version 4.9.253-tegra (yhai@yhai) 
(gcc version 7.3.1 20180425 [linaro-7.3-2018.05 revision d29120a424ecfbc167ef90065c0eeb7f91977701] (Linaro GCC 7.3-2018.05) ) 
#1 SMP PREEMPT Mon Jan 31 13:47:29 CST 2022    编译的日期
刷整机后，需重做前面的 初始设置 

为何把Image 放到rootfs/boot下 //原因，可能是想，直接在板子上编译源码，Image可直接替换/boot/Image, 
            //重启即可。不用虚拟机，远程登录板子即可	
```

###### (6)SCP方式更新内核(推荐)√

```shell
> scp dengzj@192.168.0.148:/boot/Image .  //win10里备份原镜像
$ cp /boot/Image  ~/Image.org  //板子上备份镜像

$ vim  main.c /*添加打印信息
asmlinkage __visible void __init start_kernel(void)
{
490 	pr_notice("---------my test start kernel----------\n"); 
          初始化时，用传统的puts(内核解压前)。printascii(console 初始化之前) ,printk(console 初始化之前) 可能有问题
          注意： 如在console_init前用 printk ，内核启动后 无任何信息输出，可能原因是版本问题，
          所有这里最好用 用当前版本源码示例有的打印方式  如后面代码历有pr_notice
          
590     console_init();
591 
592     printk("---------yhbd start kernel go---------\n");	烧录后内核信息中无输出，原因是启动时输出信息进行了过滤，打印级别问题
               登录后，用dmesg 就能看到了
 ..
}

//$ make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- Image  指定环境变量方式，太麻烦，用修改Makefile方式代替
$ vim Makefile /*直接指定ARCH  CROSS_COMPILE （写死的）
#ARCH           ?= $(SUBARCH)
ARCH            = arm64
#CROSS_COMPILE  ?= $(CONFIG_CROSS_COMPILE:"%"=%)
CROSS_COMPILE   = aarch64-linux-gnu-
*/
$ make Image //编译内核
$ scp arch/arm64/boot/Image dengzj@192.168.0.148:/home/dengzj/	 //传输镜像到板子
	  //如果报错 port 22  refused  可能是网卡不通，可以重启虚拟机,板子再试试
	
$ sudo cp Image /boot/  //用新的内核镜像，替换原来的
$ sudo reboot //重启后，看到修改后的信息，表示成功
```

###### (7)内核崩溃，如何恢复***√

```c
方式一 //把SD卡拔出，插入电脑 -> 点虚拟机 -> 可移动设备 -> 连接该SD卡到虚拟机中 -> 进入SD卡目录中，把Image.org	恢复	

方式二 //重新刷机
```

###### (8)内核模块未加载问题***√

```c
注//不能单独更新Image，需同步更新内核模块，否则内核模块加载不了

把卡拔出，用usb读卡器接入虚拟机
$ cd ~/kernel-4.9
$ lsusb
$ ./build.sh
$ cd /media/yhai/4587387a-8eff-4065-9398-311c8788bf60/boot 
$ sudo cp ~/kernel-4.9/arch/arm64/boot/Image  .
$ sudo cp ~/kernel-4.9/arch/arm64/boot/dts/*.dt*  .                          */
$ cd ..
$ sudo cp -rf ~/Linux_for_Tegra/rootfs/lib/modules   lib/

把卡插入板子，启动登录后 lsmod不为空了，成功解决
```

##### ⑩刷机脚本分析√

###### (1)查看 帮助

```shell
$ /flash.sh -h /* 查看 帮助
eg:sudo ./flash.sh jetson-nano-qspi-sd mmcblk0p1
Usage: sudo ./flash.sh [options] <target_board> <rootdev>
  Where,
	target board: Valid target board name. 目标板子的名字型号（如jetson-nano-qspi-sd)
	rootdev: Proper root device.
    options:
        -b <bctfile> --------- Boot control table config file.
        -c <cfgfile> --------- Flash partition table config file.
        -d <dtbfile> --------- device tree file.
        -e <emmc size> ------- Target device's eMMC size.
        -f <flashapp> -------- Path to flash application (tegraflash.py)
        -h ------------------- print this message.
        -i <enc rfs key file>- key for disk encryption support.
        -k <partition id> ---- partition name or number specified in flash.cfg.  刷指定分区
        /*sudo ./flash.sh -k LNX jetson-nano-qspi-sd mmcblk0p1*/
        -r ------------------- skip building and reuse existing system.img.    跳过 不重新制作 系统镜像(system.img)
```

###### (2)刷不同区域

```shell
$ sudo ./flash.sh jetson-nano-qspi-sd  mmcblk0p1 /*重新制作system.img后，整机擦除烧写
     jetson-nano-qspi-sd: 目标板子的型号名字(target_board), 这里用的是jetson nano sd卡的板子
     mmcblk0p1:  分区名

$ sudo ./flash.sh -r jetson-nano-qspi-sd  mmcblk0p1 /*用现有的system.img，整机擦除烧写
     -r : 跳过 不重新制作 系统镜像(system.img)

$ sudo ./flash.sh -k LNX jetson-nano-qspi-sd mmcblk0p1	/*只刷u-booot
   -k:  刷指定分区     更新U-Boot 分区(Linux_for_Tegra/bootloader/t210ref/p3450-porg/u-boot.bin)
   LNX: 是存放u-boot的分区（详见bootloader/flash.xml） 
       ls -lh bootloader/boot.img 才652K 证明，这里的boot.img指的是u-boot.bin,   而不像android里boot.img的包含bootloader 内核 rootfs等

$ sudo ./flash.sh -r -k DTB jetson-nano-qspi-sd mmcblk0p1 /*只刷设备树
   DTB： 是存放内核设备树的分区    需先将新的DTB文件 拷贝到烧写目录
  $ cp sources/kernel/kernel-4.9/build/arch/arm64/boot/dts/kernel_tegra210-p3448-0000-p3449-0000-b00.dtb   kernel/dtb/
```

###### (3)分区配置表

```shell
虚拟机路径
$ /home/dengzj/bsp/Linux_for_Tegra/bootloader
```

###### (4)刷机日志

```
略
```

#### 3、TFTP√

双网卡并行

##### ①虚拟机设置

```shell
编辑 ->虚拟网络编辑器	-> 更改设置 -> 选VMnet1 -> 桥接选择 usb网卡 （如 TP-Link的）-> 确定
虚拟机 -> 设置 -> 添加 -> 网路适配器 -> 自定义 -> 选VMnet1 -> 确定 
虚拟机里 右上角，设置一个网卡 连接wifi上外网， 一个网卡，连接usb网卡，连接板子。
```

##### ②板子联通虚拟机

```shell
板子重启 停在u-boot处
# pci enum;pci
# setenv serverip  192.168.5.11 
# setenv ipaddr 192.168.5.8
# ping  192.168.5.11   /*再ping通虚拟机
		Using eth_rtl8169 device
		host 192.168.5.11 is alive
    */
# saveeenv
# tftp Image //能tftp下载，表示tftp服务ok
```

##### ③运行裸机程序

```shell
板子重启 停在u-boot处
# pci enum;pci
# tftp led.bin   //如果有问题，见前面 uboot的tftp下载
# go 84000000  //运行裸机程序
```

#### 4、启动分析***√

##### ①启动流程

![启动流程](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\启动流程.png)

```shell
板子上电三个阶段：Bootloader----Linux内核----应用
u-boot、kernel、rootfs存放于Falsh中,搬到内存中运行。
BL1:第一段启动程序不是U-boot，是cpu片内的irom中的BL1:--初始化引导媒介(SD或者flash)，加密验证，保存安全性
BL2:冷启动或者烧写恢复
BL3：微内核集成到bootloader中,启动uboot，开启logo，支持显示,支持usb，远程访问等
BL4: uboot
Flash中的是uboot.image,其中包含3部分
/home/dengzj/bsp/Linux_for_Tegra/bootloader/t210ref/p3450-0000中的u-boot.bin
/home/dengzj/bsp/Linux_for_Tegra/bootloader中的cboot.bin、nvtboot.bin
通过刷机脚本./flash.sh整合为uboot.image
```

##### ②启动日志

###### (1) BL1

```
//BR:BootROM(BL1)
固化在cpu片内的rom里, 运行未不输出串口信息
```

###### (2) BL2



###### (3) BL3



###### (4) BL4



###### (5) 内核启动信息



###### (6) 根文件系统信息



###### (7) 疑问：拔掉SD卡，启动信息还有

```
板子上可能固有程序，不深究了
```

##### ③U-BOOT启动步骤***

![U-boot启动步骤](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\U-boot启动步骤.png)

```
第一条指令在cpu中内部irom固化程序BL1
考虑安全性第一，速度其次问题，u-boot启动阶段：关中断、看门狗(避免不断复位)、cache关闭(有缓存,数据不一致)、mmu
提升速度，搬移到内存
汇编阶段：SVC模式  需要特殊指令来操作寄存器 汇编不好维护
基本硬件初始化：时钟、串口、flash、内存
uboot中的后面一部分自搬移到内存中运行
汇编到c语言的准备：栈！
c语言阶段：
大部分硬件初始化：USB、网卡、摄像头
内核从flash中搬移到内存中运行
```

### 二、U-BOOT移植√

#### 1、准备√

##### ①BOOT源码目录

```c
// /home/dengzj/bsp/Linux_for_Tegra/source/public/u-boot
u-boot/arch:CPU体系结构，如arm、x86
u-boot/arch/arm:对于不同公司所对应的系列，如mach-tegra指代英伟达
u-boot/arch/arm/cpu:对应不同体系架构ARMv7、ARMv8
u-boot/board:开发板外围硬件设备
u-boot/drivers:设备驱动目录 如I2c、led、PWM
u-boot/config:配置文件
u-boot/cmd: uboot命令行使用的命令，如pri、tftp
```

#### 2、配置编译√

```shell
官网下载 https://source.denx.de/u-boot/u-boot 
         //->选最新的稳定版本 如v2022.01 -> 下载得u-boot.v2022.01.tar.bz2
$ tar -xvf  u-boot.v2022.01.tar.bz2 //注意，不能再共享目录解压
$ make 	p3450-0000_defconfig  /*导入英伟达对应的官方配置
  见p3450由来，https://docs.nvidia.com/jetson/archives/l4t-archived/l4t-3261/index.html
  的u-boot构建 里面的 命令中的占位符 里面可查到 jetson nano 板子的id号
  p3450-0000  p3450-0000_defconfig配置在configs下可查到，这是英伟达官方已做好的

$ make CROSS_COMPILE=aarch64-linux-gnu-  /* 编译时 需指定 交叉编译工具链（不用ARCH=arm指定 cpu体系结构，因前面导入配置里已指定）
 报错：include/image.h:1133:12: fatal error: openssl/evp.h: 没有那个文件或目录
 解决：sudo apt-get install libssl-dev
*/   
 pci enum;pci
 
$ cp u-boot.bin /tftpboot
板子上运行 /*能看到下面信息表示成功
	U-Boot 2022.01 (Feb 25 2022 - 09:59:57 +0800)

	SoC: tegra210
	Model: NVIDIA Jetson Nano Developer Kit
	Board: NVIDIA P3450-0000
	DRAM:  3.5 GiB
	MMC:   sdhci@700b0000: 1, sdhci@700b0600: 0
 
$ vim  Makefile /*每次编译时输入   make CROSS_COMPILE=aarch64-linux-gnu- 太麻烦，直接写死
CROSS_COMPILE=aarch64-linux-gnu-
$ make
```

#### 3、USB网卡移植√

##### ①基本概念

###### (1) USB架构

![USB架构](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\USB架构.png)

```
图见CPU芯片手册22章
EHCI Enhanced Host Controller Interface 增强型主机控制器接口 USB2.0主要用的是EHCI
USB 1.1则是OHCI和UHCI。EHCI为了兼容USB 1.1，就将OHCI或UHCI之一集成进自己的规范里，
这样在设备管理器中就一般能同时看到两种USB主机控制器存在，这种方式名叫Companion(伙伴)模式。

XHCI /*eXtensible Host Controller Interface 可扩展的主机控制器接口,主要是面向USB 3.0的，同时它也支持USB 2.0及以下的设备 是英特尔公司开发的一个USB主机控制器接口。
XHCI 不再和以前的主机控制器规范兼容，一个规范支持所有的USB协议具有通用性 易扩展 高性能，省电 
```

###### (2) PCIE架构

![PCIE架构](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\PCIE架构.png)

```shell
PCIE /*Peripheral Component Interconnect Express 周边设备高速互联
金手指 高速端到端传输(达5GT/S = 500M byte/s)
速度: gen1代(2.5GT/S) ,gen2代(5GT/s = 5000/10 M byte/s)
4根主线: 发送(Tx+ Tx- )和接收(Rx+  Rx-)  两对差分线每通道 
       PCIE0_RX0_P   接收端 正极差分信号
       PCIE0_RX0_N   接收端 负极差分信号
协议： 串行，全双工，端到端
```

###### (3)网卡工作原理

![网卡](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\网卡.png)

##### ②识别设备型号

```c
usb网卡连入虚拟机 
$ lsusb  /*查看usb设备信息（里面有品牌信息）
Bus 001 Device 004: ID 0b95:772b ASIX Electronics Corp. AX88772B  usb网卡的信息
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 003: ID 0e0f:0002 VMware, Inc. Virtual USB Hub
Bus 002 Device 002: ID 0e0f:0003 VMware, Inc. Virtual Mouse
Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub

$ lsusb -t /*查看usb 设备的树壮信息，里面有驱动信息
/:  Bus 02.Port 1: Dev 1, Class=root_hub, Driver=uhci_hcd/2p, 12M
    |__ Port 1: Dev 2, If 0, Class=Human Interface Device, Driver=usbhid, 12M
    |__ Port 2: Dev 3, If 0, Class=Hub, Driver=hub/7p, 12M
/:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=ehci-pci/6p, 480M
    |__ Port 1: Dev 4, If 0, Class=Vendor Specific Class, Driver=asix, 480M

$ lsmod  /*查看驱动模块是否安装
Module                  Size  Used by
ax88796b               16384  1
asix                   61440  0
usbnet                 53248  1 asix
mii                    20480  2 usbnet,asix  驱动模块
vsock_loopback         16384  0
vmw_vsock_virtio_transport_common    40960  1 vsock_loopback
```

##### ③OK示例参考(有线网卡)

###### (1)运行测试

```shell
# pci enum;pci /*激活 并扫描pci总线(网卡一般走PCI总线)
#电路图 从网卡 GBE_MDI0_P GBE_MDI0_N 配对 对应的是PCI总线的差分信号，-> 有线网卡是接PCI的，需激活pci，网卡才生效

Scanning PCI devices on bus 0
BusDevFun  VendorId   DeviceId   Device Class       Sub-Class
_____________________________________________________________
00.01.00   0x10de     0x0fae     Bridge device           0x04
00.02.00   0x10de     0x0faf     Bridge device           0x04

Tegra210 (P3450-0000) # ping 192.168.5.11
Using eth_rtl8169 device
host 192.168.5.11 is alive
```

###### (2)配置

```c
$ sudo make menuconfig  //u-boot目录下 
  //配置命令支持
  Command line interface
      Device access commands
    		 [*] pci - Access PCI devices

  Device Drivers
    //配置驱动支持     
    [*] Network device support 
			[*]   Realtek 8169 series Ethernet controller driver   
	  //配置PCI总线支持	
		[*] PCI support 
			[*]   Tegra PCI support	   
```

###### (3)配置的补充取消pci命令

###### (4)源码***

```c
//cmd/pci.c   命令
{
    #if defined(CONFIG_DM_PCI)
    "pci enum\n"
    "    - Enumerate PCI buses\n"
    #endif

    U_BOOT_CMD(
        pci,    5,  1,  do_pci,
        "list and access PCI Configuration Space", pci_help_text
    ); 
}

//cmd/Makefile
{
    ifdef CONFIG_PCI                             
    obj-$(CONFIG_CMD_PCI) += pci.o 
    endif 	
}

//cmd/Kconfig
{
    config CMD_PCI                               
        bool "pci - Access PCI devices"          
        help 	
}

//drivers/net/rtl8169.c	驱动
    static int rtl8169_eth_probe(struct udevice *dev)
    {
        struct pci_child_platdata *pplat = dev_get_parent_platdata(dev);
        struct rtl8169_private *priv = dev_get_priv(dev);
        struct eth_pdata *plat = dev_get_platdata(dev);
        u32 iobase;
        int region;
        int ret;

        debug("rtl8169: REALTEK RTL8169 @0x%x\n", iobase);
        switch (pplat->device) {
        case 0x8168:
            region = 2;
            break;
       dm_pci_read_config32(dev, PCI_BASE_ADDRESS_0 + region * 4, &iobase); //PCI
        iobase &= ~0xf;
        priv->iobase = (int)dm_pci_mem_to_phys(dev, iobase);

        ret = rtl_init(priv->iobase, dev->name, plat->enetaddr);
        if (ret < 0) {
            printf(pr_fmt("failed to initialize card: %d\n"), ret);
            return ret;
        }
    }

    static const struct udevice_id rtl8169_eth_ids[] = {
        { .compatible = "realtek,rtl8169" },
        { }
    };

    U_BOOT_DRIVER(eth_rtl8169) = {
        .name   = "eth_rtl8169",
        .id = UCLASS_ETH,
        .of_match = rtl8169_eth_ids,
        .probe  = rtl8169_eth_probe,
        .ops    = &rtl8169_eth_ops,
        .priv_auto_alloc_size = sizeof(struct rtl8169_private),
        .platdata_auto_alloc_size = sizeof(struct eth_pdata),
    };

    U_BOOT_PCI_DEVICE(eth_rtl8169, supported);  //网卡是走PCI总线

//drivers/net/Makefile
{
    obj-$(CONFIG_RTL8169) += rtl8169.o
}

//drivers/net/Kconfig
{
    config RTL8169                               
        bool "Realtek 8169 series Ethernet controler driver"
        help
}
```

###### (5)电路图芯片手册

```c
//----2.3板子电路图Jetson_Nano_Carrier_Board_OrCAD_Schematics.pdf
Gigabit Ethernet with PoE -> GBE_MDI0_P	 
//----2.2板子芯片手册JetsonNano_DataSheet_DS09366001v1.0.pdf
4.2 PCI Express (PCIe)
PCIE_WAKE //唤醒  
PCIE0_CLK_N  PCIE0_CLK_P  //差分信号的参考时钟	
PCIE0_CLKREQ  //时钟请求
PCIE0_RST     //复位
//lane 0通道： 两对 收发 差分信号： 振幅相同，相位相反 -> 抗干扰
PCIE0_RX0_P   //接收端 正极差分信号
PCIE0_RX0_N   //接收端 负极差分信号

PCIE0_TX0_P   //发送端 正极差分信号
PCIE0_TX0_N   //发送端 负极差分信号
//lane 1通道：
//lane 2通道：
//lane 3通道：

//----3.1CPU芯片手册Tegra_X1_TRM_DP07225001_v1.3p.pdf
CHAPTER 34: PCI EXPRESS (PCIe) CONTROLLER	
```

###### (6)思考

```
老版本u-boot里没有8169，如何才能移植使它支持呢
当前u-boot里没有8169，最新的u-boot里才有，如何移植呢

方法：先将最新版本里的u-boot里的8169.c的代码copy到当前的u-boot的/drivers/net中
然后修改Makefile和Kconfig
```

##### ④移植USB命令

###### (1)运行测试

```shell
#检测usb命令有没
板子上插入usb网卡
# usb  /* usb命令使用说明
usb - USB sub-system

Usage:
usb start - start (scan) USB controller
usb reset - reset (rescan) USB controller
usb stop [f] - stop USB [f]=force stop
usb tree - show USB device tree
usb info [dev] - show available USB devices
usb test [dev] [port] [mode] - set USB 2.0 test mode
    (specify port 0 to indicate the device's upstream port)
    Available modes: J, K, S[E0_NAK], P[acket], F[orce_Enable]
usb storage - show details of USB storage devices
usb dev [dev] - show or set current USB storage device
usb part [dev] - print partition table of one or all USB storage    devices
usb read addr blk# cnt - read `cnt' blocks starting at block `blk#'
    to memory address `addr'
usb write addr blk# cnt - write `cnt' blocks starting at block `blk#'
    from memory address `addr'
*/
# usb start /* 启动（扫描）usb控制器
starting USB...
Bus usb@7d000000: tegrausb: Invalid dr_mode 2 for host mode
probe failed, error -1
Bus xusb@70090000:
Firmware size 126464
Firmware timestamp: 0x5f23e558, Version: 50.26 release

Register HCSParams1: 9000124 NbrPorts: 9
Starting the controller
USB XHCI 1.00
scanning bus xusb@70090000 for devices... 5 USB Device(s) found
       scanning usb for storage devices... 0 Storage Device(s) found

 */ 
# usb tree /* 查看usb的设备树

USB device tree:
  1  Hub (5 Gb/s, 0mA)
  |  U-Boot XHCI Host Controller
  |
  +-2  Hub (480 Mb/s, 0mA)
  | |  Generic 4-Port USB 2.1 Hub
  | |
  | +-4  Hub (480 Mb/s, 100mA)
  |   |   USB 2.0 Hub
  |   |
  |   +-5  Vendor specific (480 Mb/s, 100mA)
  |        Realtek USB 10/100 LAN 00E04C3603EA   usb网卡 是Realtek的
  |
  +-3   (12 Mb/s, 100mA)

*/ 
# usb infor /*查看usb的设备 的信息
5: Vendor specific,  USB Revision 2.10
 - Realtek USB 10/100 LAN 00E04C3603EA
 - Class: (from Interface) Vendor specific
 - PacketSize: 64  Configurations: 2
 - Vendor: 0x0bda  Product 0x8152 Version 32.0       网卡芯片型号   8152
   Configuration: 1
   - Interfaces: 1 Bus Powered Remote Wakeup 100mA
     Interface: 0
     - Alternate Setting 0, Endpoints: 3
     - Class Vendor specific
     - Endpoint 1 In Bulk MaxPacket 512
     - Endpoint 2 Out Bulk MaxPacket 512
     - Endpoint 3 In Interrupt MaxPacket 2 Interval 8ms

*/
 //注意：如果usb命令没有，或一些信息不对，需配置u-boot usb相关配置选项
```

###### (2)配置***

```shell
$ make menuconfig  
  //配置命令支持
  Command line interface
      Device access commands
    		 [*] usb	
```

###### (3)源码

```c
//cmd/Kconfig
{config CMD_USB
    bool "usb"
    select HAVE_BLOCK_DEVICE
    help 
      USB support.	
}
//cmd/Makefile
{
obj-$(CONFIG_CMD_USB) += usb.o disk.o	
}

//cmd/usb.c  usb命令（u-boot里大部分功能触发，通过命令）	
{
U_BOOT_CMD(
    usb,    5,  1,  do_usb,
    "USB sub-system",
    "start - start (scan) USB controller\n"
    "usb reset - reset (rescan) USB controller\n"
    "usb stop [f] - stop USB [f]=force stop\n"
    "usb tree - show USB device tree\n"
    "usb info [dev] - show available USB devices\n"
    "usb test [dev] [port] [mode] - set USB 2.0 test mode\n"
    "    (specify port 0 to indicate the device's upstream port)\n"
    "    Available modes: J, K, S[E0_NAK], P[acket], F[orce_Enable]\n"
);
}
```

##### ⑤移植网卡驱动

```shell
u-boot搜索8152  //发现有该驱动 drivers/usb/eth/r8152.c
       //注：如果没有，可看看最新版本u-boot里，官方网站有裸机驱动没，最后不得已再linux内核里找
       //但是Linux内核里的各个软件框架和u-boot有非常大的差异，移植难度非常大。

$ make menuconfig  
  Device Drivers 
    USB support
      //配置USB总线支持
      [*]   Enable driver model for USB
      [*]   xHCI HCD (USB 3.0) support
      [*]     Support for NVIDIA Tegra T210 on-chip XHCI USB controller 
      [*]   EHCI HCD (USB 2.0) support
      [*]     Support for NVIDIA Tegra on-chip EHCI USB controller 
      //配置驱动支持
      USB to Ethernet Controller Drivers
        [*]   Realtek RTL8152B/RTL8153 support   
       
$ make
$ cp u-boo.bin  /tftpboot
```

###### (1)运行测试

```shell
# setenv bootcmd pci enum \;  pci \; tftp u-boot.bin //内存中测试u-boot
# reset
# goraw 0x84000000
# usb start 启动（扫描）usb控制器
把网线从网口拔出，插入到usb网卡
# ping 192.168.5.11   //测试网络
 Using r8152_eth device  //发现该信息表示8152驱动有加载（用自带的网卡时打印信息是 
 host 192.168.5.11 is alive //表示网卡成功启动
# tftp u-boot.bin //发现用该网卡，能成功下载。移植成功

//注意切换回原网卡时，需切换pci总线	
# usb stop //关闭usb网卡
# pci enum;pci 
# ping 192.168.9.119  //发现失败，不能切换到原网卡，原因不明
```

###### (2)源码

```
//drivers/usb/eth/r8152.c
```

###### (3)电路图芯片手册

```
//----2.3板子电路图Jetson_Nano_Carrier_Board_OrCAD_Schematics.pdf

//----2.2板子芯片手册JetsonNano_DataSheet_DS09366001v1.0.pdf

//----3.1CPU芯片手册Tegra_X1_TRM_DP07225001_v1.3p.pdf
CHAPTER 22: USB COMPLEX
框图 //Figure 51: Tegra X1 USB Controllers and Interfaces
```

###### (4)挑战:尝试 看能否两个网卡同时工作，或可切换工作

#### 4、U盘启动√

![USB启动顺序](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\USB启动顺序.png)

##### ①启动盘优先顺序√

```c
启动盘优先顺序 //SD卡 -> 内部eMMC ->USB 设备(或 NVMe 设备)  -> 通过 DHCP/PXE 的 NFS 网络	
# run distro_bootcmd  //按启动盘优先顺序 选择启动
# setenv bootcmd run distro_bootcmd //设置自启动命令，为按启动盘优先顺序 选择启动
# saveenv
```

###### UBOOT环境变量

```shell
yhai# pri
arch=arm
baudrate=115200
board=p3450-0000
board_name=p3450-0000
boot_net_usb_start=usb start
boot_pci_enum=pci enum  //扫描激活pci总线
boot_prefixes=/ /boot/
boot_script_dhcp=boot.scr.uimg
boot_scripts=boot.scr.uimg boot.scr
#最后找到这个配置文件
boot_syslinux_conf=extlinux/extlinux.conf   
boot_targets=mmc1 mmc0 usb0 nvme0 pxe dhcp //启动顺序：SD卡(mmc1) -> 内部eMMC(mmc0) -> USB 设备(usb0) -> 通过 DHCP的 NFS 网络	
            //NVMe 设备（仅限 Jetson TX2 系列才有）
bootcmd=run distro_bootcmd
bootcmd_mmc0=devnum=0; run mmc_boot
bootcmd_mmc1=devnum=1; run mmc_boot
bootcmd_nvme0=devnum=0; run nvme_boot
bootcmd_pxe=run boot_net_usb_start; run boot_pci_enum; dhcp; if pxe get; then pxe boot; fi
bootcmd_usb0=devnum=0; run usb_boot
bootdelay=2

cpu=armv8
#distro_bootcmd u-boot板子上电后3、2、1自动加载启动第一步
distro_bootcmd=setenv nvme_need_init; for target in ${boot_targets}; do run bootcmd_${target}; done
     //按boot_targets，顺序选择启动设备。
efi_dtb_prefixes=/ /dtb/ /dtb/current/
ethact=eth_rtl8169
ethaddr=48:b0:2d:51:f9:45
fdt_addr=83100000
fdt_addr_r=0x83000000
fdt_copy_node_paths=/chosen/plugin-manager:/chosen/reset:/chosen/display-board:/chosen/proc-board:/chosen/pmu-board:/external-memory-controller@7001b000:/memory@80000000
fdt_copy_prop_paths=/bpmp/carveout-start:/bpmp/carveout-size:/chosen/eks_info:/chosen/nvidia,bluetooth-mac:/chosen/nvidia,ethernet-mac:/chosen/nvidia,wifi-mac:/chosen/uuid:/chosen/linux,initrd-start:/chosen/linux,initrd-end:/serial-number:/psci/nvidia,system-lp0-disable
fdt_copy_src_addr=83100000
fdt_high=ffffffffffffffff
fdtcontroladdr=fc5fa380
fdtoverlay_addr_r=0x90200000
fileaddr=84000000
filesize=a6d84
initrd_high=ffffffffffffffff
ipaddr=192.168.9.9
kernel_addr_r=0x84000000
load_efi_dtb=load ${devtype} ${devnum}:${distro_bootpart} ${fdt_addr_r} ${prefix}${efi_fdtfile}
loadaddr=0x84000000

#从flash启动
mmc_boot=if mmc dev ${devnum}; then devtype=mmc; run scan_dev_for_boot_part; fi
nvme_boot=run boot_pci_enum; run boot_dcache_off; run nvme_init; if nvme dev ${devnum}; then devtype=nvme; run scan_dev_for_boot_part; fi
nvme_init=if ${nvme_need_init}; then setenv nvme_need_init false; nvme scan; fi
preboot=if test -e mmc 1:1 /u-boot-preboot.scr; then load mmc 1:1 ${scriptaddr} /u-boot-preboot.scr; source ${scriptaddr}; fi
pxefile_addr_r=0x90100000
ramdisk_addr_r=0x83200000

scriptaddr=0x90000000
serverip=192.168.9.119
soc=tegra210
stderr=serial
stdin=serial
stdout=serial

#从usb启动
usb_boot=run boot_pci_enum; usb start; if usb dev ${devnum}; then devtype=usb; run scan_dev_for_boot_part; fi
vendor=nvidia
xusb_fw_addr=92ca828c

Environment size: 5340/8188 bytes
```

##### ②加载内核启动

###### (1)传统加载内核方式

```shell
SD卡里烧写u-boot、内核镜像、rootfs
u-boot加载内核到内存中，内核将根文件系统加载到内存中，才能进行文件访问
```

###### (2)从应用层加载内核

```c
把内核放到文件系统中  /boot/Image //在应用层 ，可像普通文件一样更新内核
```

###### (3)实现原理

```shell
extlinux启动 #从文件系统中加载内核启动
    #u-boot -> 从sd卡加载 初始小文件系统(ramdisk) ->  再从该文件系统里加载 kernel. 和挂载rootfs 
             
extlinux.conf /*启动配置文件 
注意：u-boot 通过 /boot/extlinux/extlinux.conf 里指定加载的内核，和挂载根文件系统的位置

LABEL primary
      MENU LABEL primary kernel
      LINUX /boot/Image      //指定启动的内核名
      INITRD /boot/initrd    //指定初始ramdisk（u-boot加载内核用） 
      APPEND ${cbootargs} rootfstype=ext4 root=/dev/mmcblk0p1 rw rootwait //指定文件系统 
      

root=/dev/mmcblk0p1 指定要挂载的根文件系统的位置 是sd卡的第一个分区
mmcblk 指“ flash/sd块设备”，0 是设备的顺序编号，p1 就是第一个分区。  
sda 是硬盘的命名规则，很多U盘 硬件 ext2格式的文件系统都是按这个去分区
sda表示第一块硬盘 sda1表示第一个分区， sdb表示第二块硬盘      
      

为何需要 extlinux /*目的是能把内核镜像，放在文件系统中，u-boot可以读取，
替换方便，可远程登录板子，可像普通文件一样替换内核即可

传统方式，是u-boot 是加载内核后，才能看到文件系统， 
如要更改，要用脚本刷分区才行。
如 sudo ./flash.sh -k LNX jetson-nano-qspi-sd mmcblk0p1
 
#u-boot上电后内核启动
Loading Environment from SPI Flash... SF: Detected mx25u3235f with page size 256 Bytes, erase size 4 KiB, total 4 MiB
OK
In:    serial
Out:   serial
Err:   serial
Net:   No ethernet found.
Hit any key to stop autoboot:  0
switch to partitions #0, OK
mmc1 is current device
Scanning mmc 1:1...
#寻找配置文件
Found /boot/extlinux/extlinux.conf
Retrieving file: /boot/extlinux/extlinux.conf
845 bytes read in 29 ms (28.3 KiB/s)
1:      primary kernel
#内存构建虚拟文件
Retrieving file: /boot/initrd
7160133 bytes read in 332 ms (20.6 MiB/s)
#加载内核
Retrieving file: /boot/Image
34418696 bytes read in 1512 ms (21.7 MiB/s)
```

##### ③虚拟机里：更改U盘分区信息*

```
把sd卡通过读卡器，接入虚拟机里。
$ cd /media/yhai/b1c100cd-cc74-4e7f-acb8-f0d34c931ee8/  //接入虚拟机后自动识别的目录
yhai@yhai:~$ sudo parted /dev/sdc /*查看分区表
编号  起始点  结束点  大小    文件系统  名称     标志
 2    1049kB  1180kB  131kB             TBC
 3    2097kB  2556kB  459kB             RP1
 4    3146kB  3736kB  590kB             EBT
 5    4194kB  4260kB  65.5kB            WB0
 6    5243kB  5439kB  197kB             BPF
 7    6291kB  6685kB  393kB             BPF-DTB
 8    7340kB  7406kB  65.5kB            FX
 9    8389kB  8847kB  459kB             TOS
10    9437kB  9896kB  459kB             DTB //设备树
11    10.5MB  11.3MB  786kB             LNX //u-boot
12    11.5MB  11.6MB  65.5kB            EKS
13    12.6MB  12.8MB  197kB             BMP
14    13.6MB  13.8MB  131kB             RP4
 1    14.7MB  128GB   128GB   ext4      APP  //存放 rootfs（app的存储场所）
*/
	
$ sudo boot/extlinux/extlinux.conf /*更改启动分区
   把 root=/dev/mmcblk0p1
   改为 root=/dev/sda1      
   mmcblk 指“ flash/sd块设备”，0 是设备的顺序编号，p1 就是第一个分区。  
   sda 是硬盘的命名规则，很多U盘 硬件 ext2格式的文件系统都是按这个去分区
   sda表示第一块硬盘 sda1表示第一个分区， sdb表示第二块硬盘
 */
```



##### ④板子上:设置从U盘启动

```shell
插入到板子USB 
# run usb_boot  //从u盘启动
# setenv bootcmd run usb_boot //设置自动启动从u盘启动
# saveenv 
# reset  //复位后 发现能成功从U盘启动了
```

### 三、最小系统√

#### 1、基本概念√

##### ①存储√

![存储](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\存储.png)



##### ②根文件系统√

![根文件系统](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\根文件系统.png)



##### ③文件系统类型√

![文件系统类型](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\文件系统类型.png)

```
伪文件系统(内存中虚拟)，掉电后消失；更改后，重新上电不会有更改效果。
```

#### 2、根文件系统制作***√

```shell
官网下载 https://busybox.net/

$ wget https://busybox.net/downloads/busybox-1.34.1.tar.bz2 //最新稳定版
$ tar -xvf 	busybox-1.34.1.tar.bz2
$ cd bsp/busybox-1.34.1

$ make make menuconfig
 Setting
  [*] Build static binary (no shared libs)
   (aarch64-linux-gnu-) Cross compiler prefix  //注意 一定要指定交叉编译工具  
$ make

$ file busybox /*确认编译生成的是 ARM 平台的
   busybox: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, for GNU/Linux 3.7.0, BuildID[sha1]=76a214150af2231f6762e712edc8dead5b55a00b, stripped
  */
$ make install //安装，默认安装路径为_install
$ cd _install
$ ls
  bin  linuxrc  sbin  usr  

$ mkdir dev etc var proc tmp home root mnt sys //创建需要的目录
$ cp -rf ../examples/bootfloppy/etc/* etc/    拷贝最简示例配置,*/
$ cp /home/yhai/store/gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu/aarch64-linux-gnu/libc/lib/  . -a   //拷贝编译工具链里的库
$ du -mh lib   /*查看lib库的大小
45M	lib/debug
228M	lib

$ rm  lib/*.a     裁剪，删除掉静态库文件*/
$ aarch64-linux-gnu-strip  lib/*  裁剪掉库里的调试信息 */
$ rm -rf lib/debug/  //删掉不需要的库
$ du -mh lib   /*查看lib库的大小
   8.5M	lib/

$ sudo mknod dev/null c 1 3
$ sudo mknod   dev/console  c  5  1
```

##### ①下载BUSYBOX

##### ②编译

##### ③填充内容***

#### 3、网络文件系统挂载√

##### ①NFS的作用√

```shell
确认制作好的根文件系统能够跑起来，是基本ok的，那么使用NFS更加好。因为烧写Flash比较麻烦，烧写根文件系统的二进制放到板子上运行。
远程的某一个文件可以在本地板子上同步到内存
```

##### ②安装NFS服务√

```c
$ sudo apt install nfs-kernel-server
$ sudo systemctl status nfs-server  /*查看服务启动否
● nfs-server.service - NFS server and services
     Loaded: loaded (/lib/systemd/system/nfs-server.service; enabled; vendor pres>
     Active: active (exited) since Tue 2022-03-01 21:18:47 CST; 4min 1s ago */
 sudo systemctl enable nfs-server设为开启自启动
 sudo systemctl start  nfs-server  开启服务


$ sudo mkdir /nfs
$ cp _install -rf   /nfs/rootfs
$ sudo chmod 777 -R /nfs

$ sudo vi /etc/exports  修改配置文件，指定共享目录位置
在末尾追加
 /nfs/rootfs *(rw,sync,no_subtree_check)

rw 允许读写
sync 文件同时写入硬盘和内存
no_subtree_check 即使输出目录是一个子目录，nfs服务器不检查其父目录的权限，这样可以提高效率

$ sudo systemctl restart nfs-server  //重启服务(使得前面配置修改生效)

//自环测试
$ sudo mount -t nfs localhost:/nfs/rootfs/  /mnt/  //测试nfs服务是否安装成功。
$ ls /mnt/  /*如果其中的内容和/nfs/rootfs中一致。 表示有挂载成功
 如显示下面内容，表示成功
    bin  dev  etc  lib  linuxrc  mnt  proc  root  sbin  sys  tmp  usr  va
    r
$ sudo umount /mnt
```

##### ③板子从NFS启动

```c
$ setenv bootargs  root=/dev/nfs rw nfsroot=192.168.5.11:/nfs/rootfs console=ttyS0,115200 init=/linuxrc ip=192.168.5.8 
/*	bootargs 启动参数，传递给内核的
	root=/dev/nfs  指定rootfs所在的设备 是NFSS
	nfsroot=192.168.9.119:/nfs/rootfs 指定nfs rootfs的位置 （是在ip 是192.168.9.120的机器上 ，的/nfs/rootfs目录下）. 注意/nfs/rootfs必须和前面NFS服务配置文件设置一致
	console=ttyS0,115200  指定内核启动后串口信息从串口0输出，波特率115200 (设置错，将导致没有内核信息输出) 
	init=/linuxrc 指定第一个应用程序
  ip=192.168.9.9  需设置为板子u-boot自己的IP*/

$ pci enum;pci //激活网卡

$ fstype mmc 1:1 //查看emmc设备（flash)  1号设备的1号分区
$ ext4ls mmc 1:1 //查看emmc设备的目录和文件信息
$ ext4load mmc 1:1 0x84000000  /boot/Image  //读ext 文件系统中的 /boot/Image 到内存 0x84000000
$ ext4load mmc 1:1 83100000   /boot/tegra210-p3448-0002-p3449-0000-b00.dtb
$ booti 0x84000000 - 83100000	  /*启动Image格式的内核
booti，引导ARM64 kernel image----Image；
bootz，引导ARM kernel image----zImage；
bootm，引导u-boot自定义的kernel image----uImage。

内核不对或地址有问题，会报错  Bad Linux ARM64 Image magic!
设备树不对或下载地址不对，会报错 ERROR: Did not find a cmdline Flattened Device Tree

正常启动后，能看到内核启动信息
```

##### ④日志：NFS挂载失败



##### ⑤失败原因分析***

```c
侦探破案思维(关键是锻炼破案的能力，而不是结果）
//找线索
百度报错的信息如 VFS: Cannot open root device "nfs" or unknown-block(2,0) 
错误日志 与 参考正常日志对比 //不一致地方可能就有问题

//列举可能原因
内核 移植支持网卡NFS了吗
rootfs 一定没问题吗
nfs服务是ok的吗
设备树对吗，正确解析吗
bootargs 参数对吗，有被u-boot正确解析吗

//排查
排序 //按可能性大能快速验证的优先排查
排查关键 //你如何百分百确认，这个环节没问题
```

##### ⑥利用OK的示例

```
注 //板子SD卡 内核启动挂载rootfs是成功的。可做参考依据
```

###### （1）启动配置

```
//extlinux.conf
TIMEOUT 30
DEFAULT primary

MENU TITLE L4T boot options

LABEL primary
      MENU LABEL primary kernel
      LINUX /boot/Image
      INITRD /boot/initrd
      APPEND ${cbootargs} quiet root=/dev/mmcblk0p1 rw rootwait rootfstype=ext4 console=ttyS0,115200n8 console=tty0 fbcon=map:0 net.ifnames=0
```

###### （2）在应用层挂载->验证环境没问题

```c
$ sudo ifconfig eth0 192.168.5.8  //设置自己ip地址
$ ping 192.168.5.11
$ sudo apt install nfs-kernel-server  //按前面方式安装NFS服务
$ sudo mount -t nfs -o nolock,vers=3 192.168.5.11:/nfs/rootfs /mnt /*挂载测试失败
	报错： mount.nfs: Connection reset by peer
  排查：
     0：百度错误信息
          mount.nfs: Connection reset by peer
     1： 板子ubuntu 安装 nfs-kernel-server 自环测试
         虚拟机端 nfs自环测试
     2: 防火墙关闭
         win10 ubuntu防护墙
     3： nfs配置权限问题
     5： 关闭wifi等干扰只保留 一个网卡有线连接，且联通
       sudo nmcli r wifi off
       ifconfig
       ping 192.168.9.119  发现不稳定 很卡
           发现与win10 ip地址重名了 板子的是192.168.9.120  win10也是

     6： 切换到wifi通路挂载
        sudo nmcli device wifi connect 'ChinaNet-xqqe_EXT2.4G' password 'lzvjryud' 连接wifi
       sudo mount -t nfs -o nolock 192.168.10.243:/nfs/rootfs /mnt

        发现能成功挂载
           说明 是有线网卡 通路挂载问题
        $ cd /mnt/bin/
        $ ./ls     运行自己制作的rootfs的命令，能运行 -> 测试制作的rootfs有问题没
     4：确认是板子端还是虚拟机端的问题

       win10 端去挂载 （mount \\192.168.9.119\nfs\rootfs save）
       尚未验证过，就发现了板子ip和电脑的ip相同了
	 */
最后挂载成功 //失败原因 发现是win10 ip地址 相同了
```

##### ⑦成功的UBOOT  NFS启动设置

```c
$  setenv bootargs  root=/dev/nfs rw nfsroot=192.168.5.11:/nfs/rootfs,v3 console=ttyS0,115200 init=/linuxrc ip=192.168.5.8 
    /*bootargs 启动参数，传递给内核的
	root=/dev/nfs  指定rootfs所在的设备 是NFSS
	nfsroot=192.168.9.119:/nfs/rootfs 指定nfs rootfs的位置 （是在ip 是192.168.9.120的机器上 ，的/nfs/rootfs目录下）. 注意/nfs/rootfs必须和前面NFS服务配置文件设置一致
	console=ttyS0,115200  指定内核启动后串口信息从串口0输出，波特率115200 (设置错，将导致没有内核信息输出) 
	init=/linuxrc 指定第一个应用程序
  ip=192.168.9.9  需设置为板子u-boot自己的IP	
  
  最后发现 错误VFS: Cannot open root device "nfs" or unknown-block(2,0): error -6 NFS挂载不上
	原因ubuntu 20.04，nfs版本的问题需在bootargs 里加v3
	 */ 
$ setenv bootcmd pci enum \; pci \; ext4load mmc 1:1 0x84000000 /boot/Image \; ext4load mmc 1:1 83100000 /boot/tegra210-p3448-0002-p3449-0000-b00.dtb \; booti 0x84000000 - 83100000
```

##### ⑧系统配置脚本

###### (1)启动配置文件

```shell
/etc/inittab 启动配置文件
#this is run first except when booting in single-user mode.
:: sysinit:/etc/init.d/rcS      //指定系统初始化脚本是rcS 也可指定别的名字，但习惯用rcS
# /bin/sh invocations on selected ttys
# start an "askfirst" shell on the console (whatever that may be)
::askfirst:-/bin/sh    //需按确认键，才能进入shell

# stuff to do when restarting the init process
::restart:/sbin/init
# stuff to do before rebooting
::ctrlaltdel:/sbin/reboot
```

###### (2)启动脚本

```shell
//etc/init.d/rcS 启动脚本
#!/bin/sh
# This is the first script called by init process
/bin/mount  -a         //挂载 /etc/fstab文件指定的所有文件系统 
#/etc/init.d/rc.local  //扩展子脚本
echo  /sbin/mdev  >  /proc/sys/kernel/hotplug  //设置系统的有热插拔设备时，调用mdev程序
/sbin/mdev  -s  //mdev 系统启动和热插拔 或动态加载驱动程序时，自动产生驱动程序所需的节点文件
#./app.exe   //可添加自己程序，让其上电自己运行
/sbin/ifconfig eth0 192.168.9.18 //启动后自动配置ip

//$ chmod   +x  init.d/rcS	//添加可执行权限	
```

###### (3)自动挂载的文件系统列表

```
//etc/fstab  自动挂载的文件系统列表 	                                                  
//fstab 指定启动后自动挂载的文件系统 介质，挂载点等 ，如挂载失败会报错
#device     mount-point   type     	options         dump     fsck order
proc        /proc         proc          defaults     	 0     	   0
tmpfs       /tmp          tmpfs     	defaults         0         0
sysfs       /sys          sysfs     	defaults         0         0
tmpfs  	    /dev          tmpfs     	defaults         0         0
```

###### (4)系统环境变量的设置

```shell
#etc/profile 系统环境变量的设置
#!/bin/sh
export HOSTNAME=yhai
export USER=root
export HOME=root
export PS1="[$USER@$HOSTNAME \W]\# "   //终端前的提示符
PATH=/bin:/sbin:/usr/bin:/usr/sbin		//路径
LD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATH
export PATH  LD_LIBRARY_PATH
```

###### (5)上电自动运行程序

```
示例：将编写的简单程序，编译后放到启动脚本/etc/init.d/rcS中即可开启自动运行
```



#### 4、制作虚拟磁盘RAMDISK√

```c
ramdisk //虚拟内存盘，把RAM模拟为硬盘来使用的技术
	//速度快，但掉电信息丢失（但也避免信息串改，把最简的rootfs内容做成ramdisk）
	
在内存里面构建硬盘一样的文件系统，具有易失的特性，访问速度快
虚拟磁盘的文件系统
```

##### ①制作RAMDISK√

```shell
$ cd /nfs											#准备创建磁盘
$ dd if=/dev/zero of=ramdisk.img bs=1k count=8192 #创建一个8M的空磁盘(8192需与内核一致)
$ sudo mkfs.ext2 -i 8192 ramdisk.img -d rootfs	 #拷贝rootfs内容到 ramdisk.img
  报错：大部分原因是 空间不够 
把比较大的库删除 
$ du -mh   rootfs/    大小要小于8M

$ gzip -9 -f ramdisk.img  #压缩
$ du -h ramdisk.img.gz  #查看大小
3.3M	ramdisk.img.gz

```

##### ②板子上加载RAMDISK

```shell
u-boot支持读sd卡上面的文件，而sd卡上有内核镜像和u-boot

# ext4load mmc 1:1 0x84000000 /boot/Image  //读ext4文件系统中的 /boot/Image 到内存 0x84000000
# ext4load mmc 1:1 83100000	  /boot/tegra210-p3448-0002-p3449-0000-b00.dtb
# pci enum;pci
# tftp 0xa0000000   ramdisk.img.gz //下载到内存中测试
         //0xa0000000是试出来的，主要不能覆盖别的地址范围
         
# setenv bootargs initrd=0xa0000000,0x800000 root=/dev/ram0 rw rootwait rootfstype=ext2
//bootargs 在启动嵌入式系统时，可以通过设置引导参数来配置系统的启动行为、内核参数和设备参数等

# booti 0x84000000 - 83100000 /*启动内核， 发现内核无信息输出
	## Flattened Device Tree blob at 83100000
	   Booting using the fdt blob at 0x83100000
	ERROR: reserving fdt memory region failed (addr=0 size=0)
	ERROR: reserving fdt memory region failed (addr=0 size=0)
	   Using Device Tree in place at 0000000083100000, end 000000008313ce38
	Can't find Ethernet MAC address in cboot DTB
	copying carveout for /host1x@50000000/dc@54200000...
	copying carveout for /host1x@50000000/dc@54240000...

	Starting kernel ...
```

##### ③失败原因分析

```c
//找线索
百度搜索 //加载RAMDISK无信息输出 -> u-boot 加载RAMDISK无信息输出
         //u-boot 加载RAMDISK无信息输出 停在Starting kernel 处

//可能原因	
ramdisk 问题 //制作的ramdisk格式对吗，找官方OK的
内核问题    //ramdisk是靠内核来加载的，内核要配置支持
参数 问题   //bootargs或  booti不对
u-boot 问题  //可能性很小

//排查
排序     //按可能性大快速验证的优先排查
替换法   //尽量优先用官方OK的镜像，限定范围，错误定位
排查关键 //你如何百分百确认，这个环节没问题
```

##### ④用官方OK的镜像

```c
# ext4load mmc 1:1 0x84000000 /boot/Image  //读ext 文件系统中的 /boot/Image 到内存 0x84000000
# ext4load mmc 1:1 83100000	  /boot/tegra210-p3448-0002-p3449-0000-b00.dtb
# ext4load mmc 1:1 0xa0000000   /boot/initrd  //官方提供初始最小ramdisk 
# setenv bootargs initrd=0xa0000000,0x800000 root=/dev/ram0 rw rootwait rootfstype=ext4
# booti 0x84000000 - 83100000 //发现内核还是无信息输出
```

##### ⑤内核需配置支持RAMDISK

```c
$ cd ~/kernel-4.9
$ make menuconfig
  General setup 
   [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support
   
  Device Driver 
   [*] Block devices
      <*>   RAM block device support   
      (16)    Default number of RAM disks 
      (8192)  Default RAM disk size (kbytes)  /*需与内核启动参数一致(0x800000 = 8192*1024 8M大小)
	initrd=addr,0x800000 root=/dev/ram rw 
	addr是根文件系统的下载地址；
	0x800000是根文件系统的大小，该大小需要和内核配置的ramdisk size 8192 kbytes相一致；
	/dev/ram是ramdisk的设备节点，rw表示根文件系统可读、可写；
*/
```

##### ⑥参数设置

```shell
# setenv bootargs initrd=0xa0000000,0x800000 root=/dev/ram0 rw  rootwait rootfstype=ext2 console=ttyS0,115200 init=/linuxrc ip=192.168.5.8
//最后发现，无信息输出，原因是 bootargs要加 console=ttyS0
//注意：init=/linuxrc ip=192.168.9.9 还是要加上，否则 ifconfig没有网卡的细腻

//自动化设置
# setenv ramdisk_bootcmd pci enum \; pci \; ext4load mmc 1:1 0x84000000 /boot/Image \; ext4load mmc 1:1 83100000	  /boot/tegra210-p3448-0002-p3449-0000-b00.dtb \; tftp 0xa0000000   ramdisk.img.gz \; booti 0x84000000 - 83100000

# run ramdisk_bootcmd 
```

##### ⑦存放到SD卡中

```c
//虚拟机端运行 
$ scp ramdisk.img.gz  yhbd@192.168.0.148:/home/yhbd/  //传文件到板子SD卡文件系统中

//重启板子停在u-boot阶段
# setenv bootargs initrd=0xa0000000,0x800000 root=/dev/ram0 rw  rootwait rootfstype=ext2 console=ttyS0,115200 init=/linuxrc ip=192.168.9.9
# saveenv
# ext4load mmc 1:1 0x84000000 /boot/Image
# ext4load mmc 1:1 83100000	  /boot/tegra210-p3448-0002-p3449-0000-b00.dtb
# ext4load mmc 1:1 0xa0000000 /home/yhbd/ramdisk.img.gz		
#	booti 0x84000000 - 83100000
尝试在里面创建内容    //注意重启后就消失了，

//设置自启动
# setenv ramdisk_bootcmd  ext4load mmc 1:1 0x84000000 /boot/Image \; ext4load mmc 1:1 83100000	  /boot/tegra210-p3448-0002-p3449-0000-b00.dtb \; ext4load mmc 1:1  0xa0000000 /home/yhbd/ramdisk.img.gz \; booti 0x84000000 - 83100000
# setenv bootcmd run ramdisk_bootcmd 	
# saveenv
# reset  
注 //因把ramdisk 放在sd卡里，系统启动是不需要网卡的，而且初始最简roofs做成ramdisk 即保证启动速度，也保证信息不被篡改
```



### 四、内核分析√

#### 1、基本概念√

##### ①Linux内核

![Linux内核](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\Linux内核.png)

```
Linux操作系统(OS)=kernel+文件系统(fs)
集内核 工具集 各种库 桌面管理器 应用程序为一体的发布包(ubuntu、CentOS)
内核层:进程管理、内存管理、文件系统、设备管理、网络协议
CPU:时间片轮转并发多任务
查看内核版本： cat /proc/version
```

##### ②Linux内核特性

![Linux内核特性](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\Linux内核特性.png)

##### ③Linux版本

##### ④Linux内核源码目录***

![Linux内核 源码目录](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\Linux内核 源码目录.png)

#### 2、内核启动分析√

##### ①内核启动流程***

![即](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\Linux内核启动流程.png)

```
三个阶段：引导、内核初始化、过渡到rootfs
head.S   start_kernel rest_init
```



##### ②源码跟踪 常用操作

```c
$ cd  kernel-4.9
//vim + cscope + ctags
$ ctags   -R    //生成符号关联
$ cscope -Rbkq  //生成索引库
$ vim  .   //编辑

Ctrl + ]  //调到定义处
Ctrl + o  //返回上一次位置
          //Ctrl + i  再返回
**g f	  //跳到光标停留的include的头文件里
d w  //删除个字符串
u   //可无限撤销
:cs f f driver.c   //搜索 driver.c 文件
g d   //选中当前光标处的字符串
      //再 n  查找下一个
ctrl shift  -  s  //查找光标处的字符串
                  // j:下一条  k:上一条  f:下一页  b：上一页  shift+g: 到末尾
:cs f s attach //全局 搜索字符串 attach
Ctrl+w v   //  垂直分割窗口
           //  Ctrl+w w 可在窗口间切换
ctrl +  变大字体
:e  .    //编辑当前目录

ctrl+z 返回界面
fg返回vim
:f 查看当前文件名

//vscode
搜索文件 //ctrl+p 
搜索字符串 //右键 -> 在文件夹下搜索 
```

##### ③跟踪线索

```c
//第一条指令位置
//System.map 函数 列表
{
ffffff8008080000 T _text  //第一条指令
ffffff8008081800 T vectors  //异常向量表
ffffff80096007f4 T start_kernel	 //内核初始化
}

$ aarch64-linux-gnu-addr2line ffffff8008080000 -e vmlinux -f //查找地址对应的文件位置
 /home/yhai/kernel-4.9/arch/arm64/kernel/head.S:83

$ aarch64-linux-gnu-addr2line ffffff8008081800 -e vmlinux -f
vectors
/home/yhai/kernel-4.9/arch/arm64/kernel/entry.S:393
 
$aarch64-linux-gnu-addr2line ffffff80096007f4 -e vmlinux -f
 start_kernel
 /home/yhai/kernel-4.9/init/main.c:482

//arch/arm64/kernel/vmlinux.lds.S  连接脚本：指定程序在代码段数据段中如何分配 
{
21 OUTPUT_ARCH(aarch64)
22 ENTRY(_text)  					//入口地址
110 SECTIONS
111 {
130     .head.text : {
131         _text = .;    			//代码段连接的时，第一条指令的位置
132         HEAD_TEXT
133     }
134     .text : {           		/* Real text segment        */
135         _stext = .;     		/* Text and read-only data  */
136             __exception_text_start = .;
137             *(.exception.text)
138             __exception_text_end = .;
139             IRQENTRY_TEXT
140             SOFTIRQENTRY_TEXT
141             ENTRY_TEXT
        }
    }
}	
```

##### ④入口

```c
/arch/arm64/kernel/head.S  入口
    __HEAD
_head:
	    //对应前面 ffffff8008080000 T _text
83    b   stext               // branch to kernel start, magic
ENTRY(stext)
    bl  preserve_boot_args  //保存u-boot传入的启动参数
    bl  el2_setup           //异常级别(权限)的设置：建议EL2级别，如不则下降到EL1 
                            //Drop to EL1, w0=cpu_boot_mode  
    bl  set_cpu_boot_mode_flag  // 按 ctrl+]  会跳到定义处，   按ctrl+o 会返回原位置
    bl  __create_page_tables //创建内存映射表
    bl  __cpu_setup         //初始化CPU(配置访问权限，内存地址划分)
    
                            //查找源码： vscode -> arch/arm64 -> 右键 在文件夹中查找 __cpu_setup -> mm/proc.S
    b   __primary_switch    //主切换
ENDPROC(stext)
```

###### (1)保存传入的启动参数

###### (2)异常级别（特权）设置

###### (3)设置CPU启动时的异常级别标志

###### (4)CPU初始化

###### (5)主切换

##### ⑤内核初始化***

```c
板子上电 打印日志dmesg
内核打印信息用 pr_notice()
强制保存：:w !sudo tee %
kernel-4.9/init/main.c:482--->start_kernel(void)
smp_setup_processor_id();---> Booting Linux on physical CPU 0x0

pr_notice("%s", linux_banner);-->Linux version 4.9.253

setup_arch(&command_line);-->Boot CPU: AArch64 Processor [411fd071]

pr_notice("Kernel command line: %s\n", boot_command_line);--->Kernel command line: tegraid=21.1.2.0.0
    
//系统调用初始化  
trap_init();

//内存管理初始化
mm_init()--->mem_init();---> Virtual kernel memory layout:

//内核调度初始化(多任务 并发调度)
sched_init(); 

//中断初始化
init_IRQ(); 

//创建初始进程
rest_init(); 

```

```c
//start_kernel: 内核启动初始化
asmlinkage __visible void __init start_kernel(void)
{
	char *command_line;
	char *after_dashes;

	set_task_stack_end_magic(&init_task);
    
	//1、日志: Booting Linux on physical CPU 0x0
	smp_setup_processor_id(); //  -> arch/arm64/kernel/setup.c  多核CPU ID的安装
    
	debug_objects_early_init();

    
	//2、日志: Linux version 4.9.253-tegra
	pr_notice("%s", linux_banner);
    
	//3、日志：Boot CPU: AArch64 Processor [411fd071]
	setup_arch(&command_line); //设置CPU体系架构 -> arch/arm64/kernel/setup.c
	                            //vim跟踪:  ctrl+] 跳转  ctrl+o 返回，   :f 查看当前文件路径
	mm_init_cpumask(&init_mm);
	setup_command_line(command_line); //安装命令行参数（u-boot传入的参数）
	setup_nr_cpu_ids();
	setup_per_cpu_areas();
	smp_prepare_boot_cpu();	/* arch-specific boot-cpu hooks */
	boot_cpu_hotplug_init();


  //4、日志: Kernel command line: tegraid=21.1.2.0.0 ddr_die=4096M@2048M section=512M memtype=0 vpr_resize usb_port_owner_info=0 lane_owner_info=0 emc_max_dvfs=0 touch_id=0@63 video=tegrafb no_console_suspend=1 console=ttyS0,115200n8 debug_uartport=lsport,4 earlyprintk=uart8250-32bit,0x70006000 maxcpus=4 usbcore.old_scheme_first=1 lp0_vec=0x1000@0xff780000 core_edp_mv=1075 core_edp_ma=4000 gpt  earlycon=uart8250,mmio32,0x70006000  root=/dev/mmcblk0p1 rw rootwait rootfstype=ext4 console=ttyS0,115200n8 console=tty0 fbcon=map:0 net.ifnames=0 quiet root=/dev/mmcblk0p1 rw rootwait rootfstype=ext4 console=ttyS0,115200n8 console=tty0 fbcon=map:0 net.ifnames=0 
	pr_notice("Kernel command line: %s\n", boot_command_line);   //命令行参数(u-boot传入)
	/* parameters may set static keys */
	jump_label_init();
	parse_early_param();
    
	trap_init(); //系统调用初始化
    
	/*4、日志:  Virtual kernel memory layout:   内存布局
[    0.000000]     modules : 0xffffff8000000000 - 0xffffff8008000000   (   128 MB)
[    0.000000]     vmalloc : 0xffffff8008000000 - 0xffffffbebfff0000   (   250 GB)
[    0.000000]       .text : 0xffffff8008080000 - 0xffffff8008f80000   ( 15360 KB)
[    0.000000]     .rodata : 0xffffff8008f80000 - 0xffffff8009610000   (  6720 KB)
[    0.000000]       .init : 0xffffff8009610000 - 0xffffff8009e80000   (  8640 KB)
[    0.000000]       .data : 0xffffff8009e80000 - 0xffffff800a163008   (  2957 KB)
[    0.000000]        .bss : 0xffffff800a163008 - 0xffffff800a1fc0b4   (   613 KB)
[    0.000000]     fixed   : 0xffffffbefe7fd000 - 0xffffffbefec00000   (  4108 KB)
[    0.000000]     PCI I/O : 0xffffffbefee00000 - 0xffffffbeffe00000   (    16 MB)
[    0.000000]     vmemmap : 0xffffffbf00000000 - 0xffffffc000000000   (     4 GB maximum)
[    0.000000]               0xffffffbf00000000 - 0xffffffbf03fc8000   (    63 MB actual)
[    0.000000]     memory  : 0xffffffc000000000 - 0xffffffc0ff200000   (  4082 MB)
	*/
	mm_init();  //内存管理初始化 -> mem_init() -> arch/arm64/mm/init.c
	/*
	 * Set up the scheduler prior starting any interrupts (such as the
	 * timer interrupt). Full topology setup happens at smp_init()
	 * time - but meanwhile we still have a functioning scheduler.
	 */
	sched_init(); //内核调度初始化(多任务 并发调度)
	/*
	 * Disable preemption - early bootup scheduling is extremely
	 * fragile until we cpu_idle() for the first time.
	 */
	preempt_disable(); //禁止抢占
	if (WARN(!irqs_disabled(),
		 "Interrupts were enabled *very* early, fixing it\n"))
		local_irq_disable();
	idr_init_cache();
	rcu_init();
    
  //日志: NR_IRQS:64 nr_irqs:64 0
	/* init some links before init_ISA_irqs() */
	early_irq_init(); //早期中断初始化: -> kernel/irq/irqdesc.c
    
	//日志: /interrupt-controller@60004000: 192 interrupts"
	init_IRQ(); //中断初始化: arch/arm64/kernel/irq.c	-> irqchip_init() -> drivers/of/irq.c   of_irq_init()   扫描设备树，匹配中断控制器节点
    
	tick_init(); //时钟事件(滴答)初始化: 每滴答一下，产生一个时间周期事件，通知系统
	rcu_init_nohz();
	init_timers(); //初始化定时器
	hrtimers_init();
	timekeeping_init();
	time_init();   //时间初始化

	console_init(); //控制台初始化


#ifdef CONFIG_X86_ESPFIX64
	/* Should be run before the first non-init thread is created */
	init_espfix_bsp();
#endif
	thread_stack_cache_init();
	cred_init();
	fork_init(); //进程初始化
	proc_caches_init();
	buffer_init();
	key_init();
	security_init();
	dbg_late_init();
	vfs_caches_init();
	signals_init(); //信号初始化


	/* Do the rest non-__init'ed, we're now alive */
	rest_init(); //创建初始进程
	             //各驱动模块的初始化: -> kernel_init-> kernel_init_freeable -> do_basic_setup -> do_initcalls()

	prevent_tail_call_optimization();
}
```

###### (1)体系架构安装

```c
/setup_arch: 设置CPU体系架构 和设备树
//arch/arm64/kernel/setup.c

void __init setup_arch(char **cmdline_p)
{
	pr_info("Boot CPU: AArch64 Processor [%08x]\n", read_cpuid_id());

	sprintf(init_utsname()->machine, UTS_MACHINE);

	setup_machine_fdt(__fdt_pointer);//设置 机器设备树

	if (acpi_disabled)
		unflatten_device_tree();   //解析设备树，存在全局变量of_root中，通过它可遍历整个设备树

}

//由u-boot通过寄存器x5 传递 设备树的地址dt_phys
static void __init setup_machine_fdt(phys_addr_t dt_phys)
{
	void *dt_virt = fixmap_remap_fdt(dt_phys);

	if (!dt_virt || !early_init_dt_scan(dt_virt)) { //检查设备树 幻数匹配否
		pr_crit("\n"
			"Error: invalid device tree blob at physical address %pa (virtual address 0x%p)\n"
			"The dtb must be 8-byte aligned and must not exceed 2 MB in size\n"
			"\nPlease check your bootloader.",
			&dt_phys, dt_virt);

		while (true)
			cpu_relax();
	}

  //获取机器 名字（单板）
	dump_stack_set_arch_desc("%s (DT)", of_flat_dt_get_machine_name());
}
```

###### (2)剩余的初始化

```c
//rest_init: 余下的初始化
static noinline void __ref rest_init(void)
{
	kernel_thread(kernel_init, NULL, CLONE_FS); //创建 1号进程(线程/任务):  init进程（kernel_init）
	pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES); //2号进程： 内核守护进程(kthreadd)

	//0号进程(当前任务): 空闲进程(即有事就就，没事idle空转待命)
	cpu_startup_entry(CPUHP_ONLINE); // cpu_idle_loop() kernel/sched/idle.c

// $ ps -aux  可查看 当前运行的所有进程
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.1 161068  5424 ?        Ss   09:56   0:12 /sbin/init 2   //init进程
root         2  0.0  0.0      0     0 ?        S    09:56   0:05 [kthreadd]     //内核守护进程
 // 0号进程 看不到，因它事内核进程，应用空间看不到
}

static int __ref kernel_init(void *unused)
{
	int ret;

	kernel_init_freeable();
	async_synchronize_full();
	rcu_end_inkernel_boot();
	 /* 如果有启动参数做为执行命令，就执行
	 如无则 第一备用：/sbin/init，第二备用：/etc/init，第三备用：/bin/init，第四备用：/bin/sh。
	 */
	if (execute_command) {
		ret = run_init_process(execute_command);/*execute_command是由u-boot里传入的参数bootargs中init来指定的，
		                                     如 setenv bootargs root=nfs nfsroot=192.168.9.120:/nfs/rootfs console=ttySAC2,115200 init=/linuxrc ip=192.168.9.9
		                                      这里init 是linuxrc （由busybox编译生成）  ，
		                                     linuxrc主要是负责解析/etc下配置文件 如启动脚本/etc/init.d/rcS */
		                                    
		if (!ret)
			return 0;
		panic("Requested init %s failed (error %d).",
		      execute_command, ret);
	}

	//从ps -aux知 运行init进程是/sbin/init
	if (!try_to_run_init_process("/sbin/init") || // ->run_init_process -> do_execve() 从内核态切换到应用态（单向的）
	    !try_to_run_init_process("/etc/init") ||
	    !try_to_run_init_process("/bin/init") ||
	    !try_to_run_init_process("/bin/sh"))
		return 0;

	panic("No working init found.  Try passing init= option to kernel. "
	      "See Linux Documentation/init.txt for guidance.");
}

static noinline void __init kernel_init_freeable(void)
{
	do_basic_setup();  //基本设置(如 设备驱动初始化）
                     //在体系结构相关设置已完成后进行
	/* Open the /dev/console on the rootfs, this should never fail */
	if (sys_open((const char __user *) "/dev/console", O_RDWR, 0) < 0) //打开输入输出终端
		pr_err("Warning: unable to open an initial console.\n");

	load_default_modules();
}

kernel_init_freeable();----> do_basic_setup(void)
    
static void __init do_basic_setup(void)  //基本设置(如 设备驱动初始化）
{
	cpuset_init_smp();
	shmem_init();
	driver_init();  //驱动 初始化 -> drivers/base/init.c
	init_irq_proc();
	do_ctors();
	usermodehelper_enable();
	do_initcalls(); //各驱动模块初始化
}
```

###### (3)驱动初始化***

```c
//driver_init: 驱动初始化(如/dev/  /sys/devices 文件系统）
/**
 * driver_init - initialize driver model.
 *
 * Call the driver model init functions to initialize their
 * subsystems. Called early from init/main.c.
 */
void __init driver_init(void)
{
	/* These are the core pieces */
	devtmpfs_init();   //设备文件系统初始化( /dev 所挂载的文件系统)
	devices_init(); /*设备初始化(创建 /sys/dev  /sys/devices ）
	->drivers/base/core.c
	int __init devices_init(void)
	{
		devices_kset = kset_create_and_add("devices", &device_uevent_ops, NULL);
		if (!devices_kset)
			return -ENOMEM;
		dev_kobj = kobject_create_and_add("dev", NULL);
		if (!dev_kobj)
			goto dev_kobj_err;
		sysfs_dev_block_kobj = kobject_create_and_add("block", dev_kobj);

		sysfs_dev_char_kobj = kobject_create_and_add("char", dev_kobj);
	}
	*/
	buses_init(); /*总线初始化(创建 /sys/bus 和 /sys/devices/system)
	drivers/base/bus.c     :set nonu取消行号
		int __init buses_init(void)
		{
		    bus_kset = kset_create_and_add("bus", &bus_uevent_ops, NULL);
		    if (!bus_kset)
		        return -ENOMEM;

		    system_kset = kset_create_and_add("system", NULL, &devices_kset->kobj);
		    if (!system_kset)
		        return -ENOMEM;

		    return 0;
		}
	*/
	classes_init(); //设备类的初始化(创建  /sys/class)
	firmware_init(); //固件初始化(创建 /sys/firmware)
	hypervisor_init();

	/* These are also core pieces, but must come after the
	 * core core pieces.
	 */
	platform_bus_init(); /*平台设备总线初始化
  drivers/base/platform.c
	int __init platform_bus_init(void)
	{
	    int error;

	    early_platform_cleanup();

	    error = device_register(&platform_bus);
	    if (error)
	        return error;
	    error =  bus_register(&platform_bus_type);
	    if (error)
	        device_unregister(&platform_bus);
	    of_platform_register_reconfig_notifier();
	    return error;
	}
	struct bus_type platform_bus_type = {
    .name       = "platform",
    .dev_groups = platform_dev_groups,
    .match      = platform_match,
    .uevent     = platform_uevent,
    .pm     = &platform_dev_pm_ops,
	};
  */
	cpu_dev_init();
	memory_dev_init();
	container_dev_init();
	of_core_init(); //设备树初始化（创建 /sys/firmware/devicetree)
}
```

###### (4)驱动模块初始化

```c
动因 //维护灾难: 手动在内核init程序中，添加自己模块初始化，会带来维护灾难
     //          而维护一个初始化函数数组，也是会眼花缭乱

办法 //在内核镜像文件中，自定义一个段，这个段里面专门用来存放这些初始化函数的地址，
    //编译时自动添加到自定义段 
    //内核启动时，会从该段地址处取出函数指针，逐个执行。

//rest_init -> kernel_init-> kernel_init_freeable -> do_basic_setup -> do_initcalls()
static void __init do_initcalls(void)
{
	int level;
        //遍历：逐个调用各驱动模块初始化 ->  避免手动添加的灾难
	for (level = 0; level < ARRAY_SIZE(initcall_levels) - 1; level++)
		do_initcall_level(level);
}
```

###### (5)声明驱动模块启动自动调用***

```c
//initcall使用实例
//从日志 切入
[    0.207540] Tegra Revision: A02 SKU: 0x8f CPU Process: 0 SoC Process: 1/* 源码跟踪
vscode搜寻：  
   drivers目录 右键 -> 在文件夹下查找  Tegra Revision: ->
   pr_info("Tegra Revision: %s SKU: 0x%x CPU Process: %d SoC Process: %d\n",
   early_initcall(tegra_init_fuse);
   
在system.map搜:   
  /tegra_init_fuse  ->
   ffffff8009639ba8 t tegra_init_fuse  -> 
      $ aarch64-linux-gnu-addr2line ffffff8009639ba8 -e vmlinux -f
       tegra_init_fuse
       /home/yhai/kernel-4.9/drivers/soc/tegra/fuse/fuse-tegra.c:330
   ffffff8009823498 t __initcall_tegra_init_fuseearly  -> 由来
	
源码跳转： 		
	early_initcall(tegra_init_fuse) -> ctrl+] ->
	#define early_initcall(fn)      __define_initcall(fn, early) -> ctrl+] ->
	
	#define __define_initcall(fn, id) \  
	static initcall_t __initcall_name(fn, id) __used \
	__attribute__((__section__(".initcall" #id ".init"))) = fn;  ->  ctrl+] ->
	
	#define __initcall_name(fn, id)   __initcall_##fn##id ->
	  __initcall_tegra_init_fuseearly
		
	*/
[    0.207556] DTS File Name: /dvs/git/dirty/git-master_linux/kernel/kernel-4.9/arch/arm64/boot/dts/../../../../../../hardware/nvidia/platform/t210/porg/kernel-dts/tegra210-p3448-0000-p3449-0000-b00.dts
/*跟踪
在system.map搜：
   __initcall_tegra_init_fuseearly的后面 
  __initcall_display_tegra_dts_infoearly  ->  /display_tegra_dts_info ->
  
  ffffff800963ae34 t display_tegra_dts_info ->
     $ aarch64-linux-gnu-addr2line ffffff800963ae34 -e vmlinux -f
		display_tegra_dts_info
		/home/yhai/kernel-4.9/drivers/soc/tegra/common.c:561	
		-> pr_info("DTS File Name: %s\n", dts_fname);
*/
```

##### ⑥启动日志

###### (1)版本信息

###### (2)内存布局

###### (3)基本初始化

```shell
[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=4, Nodes=1
[    0.000000] Preemptible hierarchical RCU implementation.
[    0.000000] 	Build-time adjustment of leaf fanout to 64.
[    0.000000] 	RCU restricting CPUs from NR_CPUS=64 to nr_cpu_ids=4.
[    0.000000] RCU: Adjusting geometry for rcu_fanout_leaf=64, nr_cpu_ids=4
//早期中断初始化：early_irq_init()   -> kernel/irq/irqdesc.c
[    0.000000] NR_IRQS:64 nr_irqs:64 0
//中断初始化： init_IRQ() -> arch/arm64/kernel/irq.c	-> irqchip_init() -> drivers/of/irq.c   of_irq_init()   扫描设备树，匹配中断控制器节点
[    0.000000] /interrupt-controller@60004000: 192 interrupts forwarded to /interrupt-controller

//线索：drivers 右键搜 clock and reset probe -> drivers/clk/tegra/clk-tegra210.c -> tegra210_clock_init()
[    0.000000] t210 clock and reset probe
//线索：drivers 右键搜 get_secure_pmc_setting -> drivers/soc/tegra/pmc.c -> get_secure_pmc_setting()
[    0.000000] tegra-pmc: get_secure_pmc_setting: done secure_pmc=1
[    0.000000] clk_cbus_recalc_rate: no gbus parent
[    0.000000] clk_cbus_recalc_rate: no gbus parent
[    0.000000] clk_cbus_recalc_rate: no gbus parent
[    0.000000] clk_cbus_recalc_rate: no gbus parent
[    0.000000] clk_cbus_recalc_rate: no gbus parent

[    0.000000] arm_arch_timer: Architected cp15 timer(s) running at 19.20MHz (phys).
[    0.000000] clocksource: arch_sys_counter: mask: 0xffffffffffffff max_cycles: 0x46d987e47, max_idle_ns: 440795202767 ns
[    0.000006] sched_clock: 56 bits at 19MHz, resolution 52ns, wraps every 4398046511078ns
[    0.001650] Console: colour dummy device 80x25
[    0.001662] console [tty0] enabled
[    0.001668] bootconsole [uart8250] disabled
[    0.001688] kmemleak: Kernel memory leak detector disabled
[    0.001707] Calibrating delay loop (skipped), value calculated using timer frequency.. 38.40 BogoMIPS (lpj=76800)
[    0.001718] pid_max: default: 32768 minimum: 301
[    0.002161] Security Framework initialized
[    0.002382] Mount-cache hash table entries: 8192 (order: 4, 65536 bytes)
[    0.002391] Mountpoint-cache hash table entries: 8192 (order: 4, 65536 bytes)
[    0.003486] ftrace: allocating 47077 entries in 184 pages
[    0.170896] sched-energy: CPU device node has no sched-energy-costs
[    0.170929] ASID allocator initialised with 65536 entries
[    0.207472] tegra-id: chipid=22117.
[    0.207485] tegra-id: opt_subrevision=0.
[    0.207502] Tegra Speedo/IDDQ fuse revision 4
[    0.207507] Tegra: CPU Speedo ID 9, SoC Speedo ID 0, GPU Speedo ID 2
[    0.207511] Tegra: CPU Process ID 0, SoC Process ID 1, GPU Process ID 0
[    0.207517] Tegra: CPU Speedo Value 2112, SoC Speedo Value 2007, GPU Speedo Value 2121
[    0.207521] Tegra: CPU IDDQ Value 2632, SoC IDDQ Value 2840, GPU IDDQ Value 3555
```

###### (4)驱动模块初始化

```
//do_initcalls: 各驱动模块初始化(自动逐个调用) ->  避免手动添加的灾难
//rest_init -> kernel_init-> kernel_init_freeable -> do_basic_setup -> do_initcalls()
//fuse模块初始化: early_initcall(tegra_init_fuse) -> drivers/soc/tegra/fuse/fuse-tegra.c
[    0.207540] Tegra Revision: A02 SKU: 0x8f CPU Process: 0 SoC Process: 1
[    0.207556] DTS File Name: /dvs/git/dirty/git-master_linux/kernel/kernel-4.9/arch/arm64/boot/dts/../../../../../../hardware/nvidia/platform/t210/porg/kernel-dts/tegra210-p3448-0000-p3449-0000-b00.dts
[    0.207563] DTB Build time: Jul 26 2021 12:16:29
[    0.257049] CPU1: Booted secondary processor [411fd071]
[    0.321015] Brought up 4 CPUs
```

###### (5)驱动模块列表一

```
{//pci0
[    1.582493] tegra-pcie 1003000.pcie: PCI host bridge to bus 0000:00
[    1.582506] pci_bus 0000:00: root bus resource [io  0x0000-0xffff]
[    1.582512] pci_bus 0000:00: root bus resource [mem 0x13000000-0x1fffffff]
[    1.582567] pci 0000:00:01.0: [10de:0fae] type 01 class 0x060400
[    1.582672] pci 0000:00:01.0: PME# supported from D0 D1 D2 D3hot D3cold

}
{//pwm-regulator(监管者)
[    1.584123] pwm-regulator pwm_regulators:pwm-regulator@0: PWM regulator registration passed
[    1.584486] hpd: state 7 (Takeover from bootloader), hpd 0, pending_hpd_evt 1
[    1.584493] hpd: switching from state 7 (Takeover from bootloader) to state 0 (Reset)
[    1.585489] vdd-gpu: applied init 1000000uV constraint
[    1.585498] vdd-gpu: 708 <--> 1323 mV at 997 mV
[    1.585907] pwm-regulator pwm_regulators:pwm-regulator@1: PWM regulator registration passed
}
{//uart驱动
[    1.589549] Serial: 8250/16550 driver, 4 ports, IRQ sharing disabled
[    1.589646] No Device Node present for smmu client: serial8250 !!
[    1.589657] platform serial8250: No iommus property found in DT node, got swgids from fixup(101004000)
[    1.589699] iommu: Adding device serial8250 to group 35
[    1.592121] console [ttyS0] disabled
[    1.592181] 70006000.serial: ttyS0 at MMIO 0x70006000 (irq = 63, base_baud = 25500000) is a Tegra
}
{//pci bus1
[    1.597968] pci_bus 0000:01: busn_res: [bus 01-ff] end is updated to 01
[    1.598170] pci 0000:02:00.0: [10ec:8168] type 00 class 0x020000
[    1.598202] pci 0000:02:00.0: reg 0x10: [io  0x0000-0x00ff]
[    1.598430] pci 0000:02:00.0: supports D1 D2
[    1.598434] pci 0000:02:00.0: PME# supported from D0 D1 D2 D3hot D3cold
}
{//uart设备文件
[    1.602429] console [ttyS0] enabled
[    1.603461] 70006040.serial: ttyTHS1 at MMIO 0x70006040 (irq = 64, base_baud = 0) is a TEGRA_UART
[    1.603753] serial-tegra 70006200.serial: RX in PIO mode
[    1.603847] 70006200.serial: ttyTHS2 at MMIO 0x70006200 (irq = 65, base_baud = 0) is a TEGRA_UART
}
{//pci bus2
[    1.604847] [drm] Initialized
[    1.606021] pci_bus 0000:02: busn_res: [bus 02-ff] end is updated to 02
[    1.606100] pci 0000:00:01.0: BAR 14: assigned [mem 0x13000000-0x130fffff]

[    1.615516] brd: module loaded
thermal-fan-est
[    1.622787] THERMAL EST: thz register success.
[    1.622951] THERMAL EST: end of probe, return err: 0
[    1.624190] sd: No Scsi addr parsed to reserve index
}
```

###### (6)驱动模块列表二

```
{//千兆以太网卡
[    1.635051] tun: Universal TUN/TAP device driver, 1.6
[    1.635060] tun: (C) 1999-2004 Max Krasnyansky <maxk@qualcomm.com>
[    1.636147] e1000e: Intel(R) PRO/1000 Network Driver - 3.2.6-k
[    1.636151] e1000e: Copyright(c) 1999 - 2015 Intel Corporation.
[    1.636205] igb: Intel(R) Gigabit Ethernet Network Driver - version 5.4.0-k
[    1.636208] igb: Copyright (c) 2007-2014 Intel Corporation.

[    1.637385] r8168 0000:02:00.0: enabling device (0000 -> 0003)
[    1.637418] r8168 Gigabit Ethernet driver 8.045.08-NAPI loaded
[    1.653204] r8168  Copyright (C) 2017  Realtek NIC software team <nicfae@realtek.com>
[    1.653809] PPP generic driver version 2.4.2
[    1.654204] PPP MPPE Compression module registered
[    1.654211] NET: Registered protocol family 24
}
{//usb
[    1.654287] usbcore: registered new interface driver r8152
[    1.654333] usbcore: registered new interface driver asix
[    1.654391] usbcore: registered new interface driver ax88179_178a
[    1.654432] usbcore: registered new interface driver cdc_ether
[    1.654766] VFIO - User Level meta-driver version: 0.3
[    1.656012] ehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver

[    1.663114] usbcore: registered new interface driver uas
[    1.663182] usbcore: registered new interface driver usb-storage
[    1.663350] usbcore: registered new interface driver usbserial
0x00050010
[    1.664483] tegra-xusb 70090000.xusb: irq 61, io mem 0x70090000
[    1.664689] usb usb1: New USB device found, idVendor=1d6b, idProduct=0002
[    1.664711] usb usb1: SerialNumber: 70090000.xusb
[    1.666656] usb usb2: Manufacturer: Linux 4.9.253-tegra xhci-hcd
[    1.666661] usb usb2: SerialNumber: 70090000.xusb
[    1.667160] tegra-xudc-new 700d0000.xudc: device count: 1
[    1.667187] hub 2-0:1.0: USB hub found
[    1.667226] hub 2-0:1.0: 4 ports detected
[    1.668285] tegra-xusb 70090000.xusb: Upgrade port 0 to USB3.0
[    1.770353] usb usb2: usb_suspend_both: status 0
}
{//rtc
[    1.790300] max77686-rtc max77620-rtc: rtc core: registered max77620-rtc as rtc0
[    1.792756] rtc rtc1: alarm rtc device
[    1.792777] tegra_rtc 7000e000.rtc: rtc core: registered 7000e000.rtc as rtc1
[    1.792807] tegra_rtc 7000e000.rtc: Tegra internal Real Time Clock
}
{//i2c
[    1.793675] i2c /dev entries driver
[    1.795580] i2c i2c-6: Added multiplexed i2c bus 7
[    1.795935] i2c i2c-6: Added multiplexed i2c bus 8
[    1.795943] i2c-mux-gpio cam_i2cmux: 2 port mux on Tegra I2C adapter adapter
}
{//camera摄像头 imx219 
[    1.796765] imx219 7-0010: tegracam sensor driver:imx219_v2.0.6
[    1.821814] imx219 8-0010: tegracam sensor driver:imx219_v2.0.6
[    1.845093] tegra-vii2c 546c0000.i2c: no acknowledge from address 0x10
[    1.845176] imx219 8-0010: imx219_board_setup: error during i2c read probe (-121)
[    1.852814] imx219 8-0010: board setup failed
[    1.857258] imx219: probe of 8-0010 failed with error -121
}
```

###### (7)驱动模块列表三

```
{//temperature  芯片温度管理
[    1.858690] max77620-power max77620-power: Event recorder REG_NVERC : 0x0
[    1.861520] tegra_soctherm 700e2000.soctherm: pllx_offset tz:0 max:14, min:2
[    1.861527] tegra_soctherm 700e2000.soctherm: pllx_offset tz:2 max:8, min:4

[    1.864488] tegra_soctherm 700e2000.soctherm: soctherm: trip temperature -2147483647 forced to -127000
[    1.866062] tegra_throttle_probe: probe successful. #cdevs=4
}
{//pwm fan
[    1.866884] FAN dev name: pwm-fan
[    1.866958] FAN:gpio request success.
[    1.867027] pwm_fan_driver pwm-fan: cap state:7, cap pwm:255
[    1.867345] pwm_fan_driver pwm-fan: got pwm for fan. polarity is normal
[    1.867529] pwm_fan_driver pwm-fan: fan tach request irq success
[    1.867540] pwm_fan_driver pwm-fan: tach period: 1000
}

{//wifi 蓝牙
[    4.413004] Intel(R) Wireless WiFi driver for Linux
[    4.413007] Copyright(c) 2003- 2015 Intel Corporation
[    4.413228] iwlwifi 0000:01:00.0: enabling device (0000 -> 0002)
[    4.849999] usbcore: registered new interface driver btusb
[    4.850701] iwlwifi 0000:01:00.0: Direct firmware load for iwlwifi-8265-26.ucode failed with error -2
[    4.851552] tegra_soctherm 700e2000.soctherm: soctherm: trip temperature -2147483647 forced to -127000
[    4.851572] cpu-throttle-alert cooling device registered.
[    4.851897] tegra_soctherm 700e2000.soctherm: soctherm: trip temperature -2147483647 forced to -127000
[    4.851913] gpu-throttle-alert cooling device registered.

[    4.852095] hot-surface-alert cooling device registered.
[    4.859938] iwlwifi 0000:01:00.0: Falling back to user helper
[    4.864559] Bluetooth: hci0: Firmware revision 0.1 build 226 week 17 2018
[    4.914260] Mass Storage Function, version: 2009/09/11
[    5.154918] usb0: HOST MAC 52:a8:94:e0:67:92
[    5.154949] usb0: MAC 52:a8:94:e0:67:93
[    5.154972] tegra-xudc-new 700d0000.xudc: exiting ELPG

[    8.744017] iwlwifi 0000:01:00.0: L1 Enabled - LTR Enabled
[    8.744333] iwlwifi 0000:01:00.0: L1 Enabled - LTR Enabled
[    8.798803] IPv6: ADDRCONF(NETDEV_UP): wlan0: link is not ready
[    8.953944] IPv6: ADDRCONF(NETDEV_UP): wlan0: link is not ready
[    9.716717] Bridge firewalling registered
[    9.754959] nf_conntrack version 0.5.0 (16384 buckets, 65536 max)
[   10.093559] Netfilter messages via NETLINK v0.30.
[   10.102276] ctnetlink v0.93: registering with nfnetlink.
[   10.375958] IPv6: ADDRCONF(NETDEV_UP): docker0: link is not ready
[   10.380186] tegradc tegradc.0: blank - powerdown
[   10.380195] tegradc tegradc.1: blank - powerdown
[   11.947271] fuse init (API version 7.26)
[   12.474020] wlan0: authenticate with 80:3f:5d:df:b5:d9
[   12.483951] wlan0: send auth to 80:3f:5d:df:b5:d9 (try 1/3)
[   12.491081] wlan0: authenticated
[   12.491834] wlan0: associating with AP with corrupt probe response
[   12.493897] wlan0: associate with 80:3f:5d:df:b5:d9 (try 1/3)
[   12.499289] wlan0: RX AssocResp from 80:3f:5d:df:b5:d9 (capab=0xc11 status=0 aid=3)
[   12.507986] wlan0: associated
[   12.622480] IPv6: ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
}
```

#### 3、内核调试方法√

##### ①打印信息

###### (1)打印级别√

```shell
/include/linux/kern_levels.h 
#define KERN_SOH    "\001"      /* ASCII Start Of Header */
 
#define KERN_EMERG  KERN_SOH "0"    /* system is unusable 系统崩溃前的信息*/
#define KERN_ALERT  KERN_SOH "1"    /* action must be taken immediately 需要立即处理的消息 */
#define KERN_CRIT   KERN_SOH "2"    /* critical conditions 严重情况*/
#define KERN_ERR    KERN_SOH "3"    /* error conditions 错误*/
#define KERN_WARNING    KERN_SOH "4"    /* warning conditions 警告*/
#define KERN_NOTICE KERN_SOH "5"    /* normal but significant condition 注意 */
#define KERN_INFO   KERN_SOH "6"    /* informational 普通信息*/
#define KERN_DEBUG  KERN_SOH "7"    /* debug-level messages 调试*/

printk(KERN_INFO "\n  INFO Level \n");  //指定打印的级别 （数字越小，优先级越高

//include/linux/printk.h
#ifndef pr_fmt
#define pr_fmt(fmt) fmt
#endif

#define pr_emerg(fmt, ...) \
    printk(KERN_EMERG pr_fmt(fmt), ##__VA_ARGS__)
#define pr_alert(fmt, ...) \
    printk(KERN_ALERT pr_fmt(fmt), ##__VA_ARGS__)
#define pr_crit(fmt, ...) \
    printk(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__)
#define pr_err(fmt, ...) \
    printk(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)
#define pr_warning(fmt, ...) \
    printk(KERN_WARNING pr_fmt(fmt), ##__VA_ARGS__)
#define pr_warn pr_warning
#define pr_notice(fmt, ...) \
    printk(KERN_NOTICE pr_fmt(fmt), ##__VA_ARGS__)
#define pr_info(fmt, ...) \
    printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)
    
#define pr_cont(fmt, ...) \
	printk(KERN_CONT fmt, ##__VA_ARGS__)

/* pr_devel() should produce zero code unless DEBUG is defined */
#ifdef DEBUG
#define pr_devel(fmt, ...) \
	printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)
#else
#define pr_devel(fmt, ...) \
	no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)
#endif
```

###### (2)控制信息输出√

```c
//问题：用从零制作的镜像，不断报	tegra-i2c 7000c400.i2c: no acknowledge from address 0x3c
# run usb_boot  //从u盘启动
$ sudo su
$ echo 0 > /proc/sys/kernel/printk //禁用内核信息输出(写8 表示输出所有信息)
echo 4 > /proc/sys/kernel/printk    
```

###### (3)屏蔽内核信息√

```c
$ setenv bootargs initrd=0xa0000000,0x800000 root=/dev/ram0 rw  rootwait rootfstype=ext2 console=ttyS0,115200 init=/linuxrc ip=192.168.5.8  loglevel=1
$ run ramdisk_bootcmd //发现内核信息无输出了	
   quiet  //相当于loglevel=4  (高于这个级别的，才输出)
   loglevel=8  //输出所有的信息
```

###### (4)输出文件名函数行号√***

```c
pr_notice("=============Dengzj: %s, %s,%d ---\n",__FILE__,__func__,__LINE__);

//虚拟机端
$ scp arch/arm64/boot/Image yhbd@192.168.0.148:/home/yhbd/ImageNew

重启后快速按enter 停下  	
# ext4ls mmc 1:1 /home/yhbd/  //注意要确定 ImageNew不是空的
  34418696 ImageNew  
# setenv ramdisk_bootcmd  ext4load mmc 1:1 0x84000000 /home/yhbd/ImageNew \; ext4load mmc 1:1 83100000	  /boot/tegra210-p3448-0002-p3449-0000-b00.dtb \; ext4load mmc 1:1  0xa0000000 /home/yhbd/ramdisk.img.gz \; booti 0x84000000 - 83100000
# saveenv //保存后，避免重复设置
# run ramdisk_bootcmd //测试内核信息输出  
```

###### (5)让内核输出信息，都带上文件名函数行号√***

```c
// 必须添加loglevel=8 输出所有信息，我们添加的文件名行号是KERN_DEBUG 级别也会显示出来
$ setenv bootargs initrd=0xa0000000,0x800000 root=/dev/ram0 rw  rootwait rootfstype=ext2 console=ttyS0,115200 init=/linuxrc ip=192.168.5.8  loglevel=8
$ run ramdisk_bootcmd

注 //注： 先在init/main.c里仿pr_notice的实现 自定义一个测试通过后
  // 再改 pr_notice 的实现，因很多文件都依赖它，如果有修改，会重编很长时间
  
{//init/main.c
#define yh_notice(fmt, ...) \
    do { printk(KERN_NOTICE pr_fmt(fmt),##__VA_ARGS__); printk(KERN_DEBUG "//yh notice:%s %s %d",__FILE__,__func__,__LINE__); } while (0)

yh_notice(" yh test %s",KERN_NOTICE);  

}

{//include/linux/printk.h 更改最底层的打印，加上文件名行号等
#define pr_emerg(fmt, ...) \
    do { printk(KERN_EMERG pr_fmt(fmt),##__VA_ARGS__); printk(KERN_DEBUG "//yh emerg:%s %s %d",__FILE__,__func__,__LINE__); } while (0)
#define pr_alert(fmt, ...) \
    do { printk(KERN_ALERT pr_fmt(fmt),##__VA_ARGS__); printk(KERN_DEBUG "//yh alert:%s %s %d",__FILE__,__func__,__LINE__); } while (0)
#define pr_crit(fmt, ...) \
    do { printk(KERN_CRIT pr_fmt(fmt),##__VA_ARGS__); printk(KERN_DEBUG "//yh cirt:%s %s %d",__FILE__,__func__,__LINE__); } while (0)
#define pr_err(fmt, ...) \
    do { printk(KERN_ERR pr_fmt(fmt),##__VA_ARGS__); printk(KERN_DEBUG "//yh err:%s %s %d",__FILE__,__func__,__LINE__); } while (0)
#define pr_warning(fmt, ...) \
    do { printk(KERN_WARNING pr_fmt(fmt),##__VA_ARGS__); printk(KERN_DEBUG "//yh warn:%s %s %d",__FILE__,__func__,__LINE__); } while (0)
#define pr_warn pr_warning
#define pr_notice(fmt, ...) \
    do { printk(KERN_NOTICE pr_fmt(fmt),##__VA_ARGS__); printk(KERN_DEBUG "//yh notice:%s %s %d",__FILE__,__func__,__LINE__); } while (0)
#define pr_info(fmt, ...) \
    do { printk(KERN_INFO pr_fmt(fmt),##__VA_ARGS__); printk(KERN_DEBUG "//yh infor:%s %s %d",__FILE__,__func__,__LINE__); } while (0)
}
```

##### ②点灯法√

```
打印信息(日志)需要前提，串口需要初始化，串口没准备好，就没有输出信息
在head.S汇编部分添加点灯汇编
```

##### ③内核异常OOP信息

```c
//drivers/memory/tegra/tegra210-emc.c  在驱动中制造内核异常
static __init int tegra_emc_therm_init(void)
{
    void *ret;
    int *ptr  =  NULL;
    pr_notice("============yhai 111\n");
   *ptr  = 0xff;
}
$ make Image

$ aarch64-linux-gnu-addr2line ffffff800968eac0 -e vmlinux -f  //从出错位置反向追踪源码位置 
                           //pc : [<ffffff800968eac0>]
	
//在 drivers/soc/tegra/fuse/fuse-tegra.c	的制造内核异常（会导致内核无任何输出）

注 //原因：在console_init 之前发生的内核异常，因输出信息，需console 准备好后才能输出
```

###### 内核崩溃日志

```c
[    5.465685] ============yhai 111
[    5.465703] //yh notice:drivers/memory/tegra/tegra210-emc.c tegra_emc_therm_init 2611
[    5.465704] Unable to handle kernel write to read-only memory at virtual address 00000000
[    5.465708] //yh alert:arch/arm64/mm/fault.c __do_kernel_fault 289
[    5.465709] Mem abort info:
[    5.465713] //yh alert:arch/arm64/mm/fault.c mem_abort_decode 109
[    5.465714]   ESR = 0x96000045
[    5.465719] //yh alert:arch/arm64/mm/fault.c mem_abort_decode 111
[    5.465720]   Exception class = DABT (current EL), IL = 32 bits
[    5.465723] //yh alert:arch/arm64/mm/fault.c mem_abort_decode 114
[    5.465724]   SET = 0, FnV = 0
[    5.465726] //yh alert:arch/arm64/mm/fault.c mem_abort_decode 117
[    5.465726]   EA = 0, S1PTW = 0
[    5.465729] //yh alert:arch/arm64/mm/fault.c mem_abort_decode 120
[    5.465729] Data abort info:
[    5.465732] //yh alert:arch/arm64/mm/fault.c data_abort_decode 87
[    5.465733]   ISV = 0, ISS = 0x00000045
[    5.465735] //yh alert:arch/arm64/mm/fault.c data_abort_decode 99
[    5.465735]   CM = 0, WnR = 1
[    5.465739] //yh alert:arch/arm64/mm/fault.c data_abort_decode 104
[    5.465740] [0000000000000000] user address but active_mm is swapper
[    5.465748] //yh alert:arch/arm64/mm/fault.c show_pte 139
[    5.465748] Internal error: Oops: 96000045 [#1] PREEMPT SMP
[    5.465755] //yh emerg:arch/arm64/kernel/traps.c __die 248
[    5.465757] Modules linked in:
[    5.465766] CPU: 3 PID: 1 Comm: swapper/0 Not tainted 4.9.253 #35
[    5.465769] Hardware name: NVIDIA Jetson Nano Developer Kit (DT)
[    5.465771] task: ffffffc0fa6f0000 task.stack: ffffffc0fa66c000
[    5.465791] PC is at tegra_emc_therm_init+0x54/0xc0
[    5.465793] LR is at tegra_emc_therm_init+0x44/0xc0
[    5.465796] pc : [<ffffff800968eac0>] lr : [<ffffff800968eab0>] pstate: 20400045
[    5.465797] sp : ffffffc0fa66fdb0
[    5.465801] x29: ffffffc0fa66fdb0 x28: ffffff800985baa0 
[    5.465805] x27: ffffff800969fc88 x26: ffffff8009627ed0 
[    5.465808] x25: ffffff800a187000 x24: ffffff80096304b0 
[    5.465811] x23: ffffff800969fc90 x22: 0000000000000007 
[    5.465815] x21: ffffffc0fa6f0000 x20: ffffff800953ffb0 
[    5.465817] x19: ffffff80090e4180 x18: 0000000000000001 
[    5.465820] x17: 0000000000000000 x16: 0000000000000000 
[    5.465823] x15: ffffffffffffffff x14: 322074696e695f6d 
[    5.465826] x13: 726568745f636d65 x12: 5f61726765742063 
[    5.465829] x11: 2e636d652d303132 x10: 61726765742f6172 
[    5.465832] x9 : 6765742f79726f6d x8 : 656d2f7372657669 
[    5.465835] x7 : 72643a656369746f x6 : ffffff800a18e0d9 
[    5.465837] x5 : 0000000000000000 x4 : 0000000000000000 
[    5.465840] x3 : ffffffffffffffff x2 : 00000000000000ff 
[    5.465843] x1 : 0000000000000000 x0 : 0000000000000001 
[    5.465844] 
[    5.465847] Process swapper/0 (pid: 1, stack limit = 0xffffffc0fa66c000)
[    5.465851] //yh emerg:arch/arm64/kernel/traps.c __die 259
[    5.465851] Call trace:
[    5.465856] [<ffffff800968eac0>] tegra_emc_therm_init+0x54/0xc0
[    5.465869] [<ffffff8008083b64>] do_one_initcall+0x44/0x130
[    5.465878] [<ffffff8009630e88>] kernel_init_freeable+0x1a0/0x268
[    5.465888] [<ffffff8008f8e190>] kernel_init+0x18/0x148
[    5.465891] [<ffffff80080838a0>] ret_from_fork+0x10/0x30
[    5.465904] ---[ end trace 64dab5e394328fba ]---
[    5.473760] //yh warn:kernel/panic.c print_oops_end_marker 502
[    5.473760] Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b
[    5.473760] 
[    5.473767] //yh emerg:kernel/panic.c panic 175
[    5.473768] SMP: stopping secondary CPUs
[    5.480453] //yh cirt:arch/arm64/kernel/smp.c smp_send_stop 1035
[    5.480453] Kernel Offset: disabled
[    5.480460] //yh emerg:arch/arm64/kernel/setup.c dump_kernel_offset 349
[    5.480460] Memory Limit: none
[    5.905924] //yh emerg:arch/arm64/mm/init.c dump_mem_limit 536
[    5.905924] Rebooting in 5 seconds..
[    5.915304] //yh emerg:kernel/panic.c panic 257 [0000.159] [L4T TegraBoot] (version 00.00.2018.01-l4t-8728f3cb) 
```

#### 4、板子上编译内核(推荐)√

##### ①远程登录√

```c
//远程登录(win10 vscode)
> ssh yhbd@192.168.0.148  /*远程登录板子(注意用户名，和ip地址，要和板子的一致)

/*首先虚拟机和板子先建立ssh，然后将虚拟机的.ssh文件拷贝到windows的.ssh文件中即可*/	
打开vscode 远程登录  
```

##### ②解压BSP开发框架√

```c
scp Jetson-210_Linux_R32.6.1_aarch64.tbz2 yhbd@192.168.0.148:/home/yhbd/bsp
> scp public_sources.tbz2  yhbd@192.168.0.148:/home/yhbd/bsp  //把源码传到板子上
$ cd ~/bsp
$ tar -xvf 	Jetson-210_Linux_R32.6.1_aarch64.tbz2
$ cd Linux_for_Tegra
$ tar -xvf public_sources.tbz2
$ cd Linux_for_Tegra/source/public
$ tar -xvf kernel_src.tbz2  //解压Linux内核(解压后生成 kernel  和 hardware )
                       			//hardware 是独立出来的硬件信息部分，包括设备树和头文件
$ gcc -v  //查看gcc版本信息，可知不用再装交叉编译工具链，它本身就是ARM平台   
```

##### ③编译内核√

```c
cd kernel/kernel-4.9 /*进入内核目录

$ pwd
 /home/yhbd/bsp/Linux_for_Tegra/source/public/kernel/kernel-4.9
$ cd ~
$ ln -s /home/yhbd/bsp/Linux_for_Tegra/source/public/kernel/kernel-4.9 .
$ cd kernel-4.9
*/
$ zcat /proc/config.gz > .config	 //导入当前板子内核的配置
$ sudo apt-get install build-essential libncurses5-dev  //安装后面make menuconfig需要的图形库
$ make menuconfig  //内核菜单配置页面（如报Your display is too small 放大点就可以了）
$ make prepare //做一些编译前准备
$ make modules_prepare
$ time make -j5 /*编译所有
 real    58m57.003s  编完需1小时左右
time是显示编译完后的时间   -j5 开启多核并行编译 节省时间
$ time make -j5 Image   指定编译内核（ 编译26分钟左右，比2G版快了一倍 )         
$ time make -j5 modules 指定编译模块(36分钟)
$ make dtbs  指定编译设备树
*/
```

##### ④运行调试

```shell
$ cd  /boot/extlinux/
$ sudo cp extlinux.conf  extlinux_yh.conf
$ sudo chmod 777 extlinux_yh.conf
$ vim extlinux_yh.conf  /*指定从新内核启动
 改 LINUX /boot/Image 
 为 LINUX /home/yhbd/kernel-4.9/arch/arm64/boot/Image 
 */
重启板子 快速停在u-boot阶段 
# setenv boot_syslinux_conf extlinux/extlinux_yh.conf  //指定启动配置文件为我们自定义的
                //原默认的是 boot_syslinux_conf=extlinux/extlinux.conf
                /home/yhbd/bsp/linux-4.9.253/arch/arm64/boot/Image
                /home/yhbd/kernel-4.9/arch/arm64/boot/Image
                /boot
                arch/arm64/boot/Image
    setenv boot_syslinux_conf extlinux/extlinux.conf           
# run distro_bootcmd //从tf卡启动
```

### 五、内核移植上√

#### 1、移植关键：变化√

##### ①溯源演化√

![内核移植_溯源演化](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\内核移植_溯源演化.png)

```
设备树里存放着外设的地址、设备信息
```

##### ②对比厂商的修改√

```c
/对比原版本，看移植OK的代码，到底更改那些地方

已移植OK的版本 //解压出 public_sources.tbz2 中的kernel_src.tbz2

原版本 //Makefile 顶部有原版本号 VERSION = 4 PATCHLEVEL = 9 SUBLEVEL = 253
       //官网 https://www.kernel.org/ ->
     // https://www.kernel.org/pub/->linux -> kernel->选linux-4.9.253.tar.gz下载

安装对比软件  //Beyond Compare

{//kernel-4.9/Makefile   发现英伟达 除了直接在内核上修改外，还把自己关键代码独立放在内核外面，只是编译时关联，
ifeq ($(KERNEL_OVERLAYS),)  //如果KERNEL_OVERLAYS为空，则定义
KERNEL_OVERLAYS :=
KERNEL_OVERLAYS += $(CURDIR)/../nvidia  //英伟达 内核的修改代码
KERNEL_OVERLAYS += $(CURDIR)/../nvgpu   //英伟达的gpu驱动
KERNEL_OVERLAYS += $(CURDIR)/../nvgpu-next
KERNEL_OVERLAYS += $(CURDIR)/../nvidia-t23x
else
override KERNEL_OVERLAYS := $(subst :, ,$(KERNEL_OVERLAYS))
endif
override KERNEL_OVERLAYS := $(abspath $(KERNEL_OVERLAYS))
export KERNEL_OVERLAYS

define set_srctree_overlay
  overlay_name := $(lastword $(subst /, ,$(overlay)))
  srctree.$(overlay_name) := $(overlay)
  export srctree.$(overlay_name)
endef
$(foreach overlay,$(KERNEL_OVERLAYS),$(eval $(value set_srctree_overlay)))	

VPATH		+= $(foreach overlay,$(KERNEL_OVERLAYS),:$(overlay)) //遍历KERNEL_OVERLAYS ，把它添加到内核编译源码树中
}
```

##### ③对比内核版本变化√

```c
注意 //不同分支在合并之前 都是独立发展的，分支间差异很大
     //移植时最好和方案提供商 给大版本一致。这样难度最小
     //但是有可能 该分支已停止维护，那只有切换到别的分支了

同分支对比 /*
https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=v4.9.305&id2=v4.9.253&dt=2
更改id=v4.9.305 和 id2=v4.9.253    可对比不同版本(同分支) 
绿条表示新增，红条表示删除
键文件 在新窗口打开  可查看文件对比的网址*/
   	     
文件对比 /*https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/arm64/kernel/head.S?id=v4.9.305&id2=v4.9.253
对比文件 arch/arm64/kernel/head.S*/
   	     
文件夹对比 /* https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/arm64/kernel/?id=v4.9.305&id2=v4.9.253
对比文件夹  arch/arm64/kernel/  */

不同分支对比 /* 
更改为 id=v5.16.13 和 id2=v4.9.304 可对比不同分支版本, 但因差异太多，很难显示完整，如下
https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=v5.16.13&id2=v4.9.253&dt=2
可尝试加文件夹限定 如  
https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/arm64/?id=v5.16.13&id2=v4.9.253&dt=2*/ 
```

#### 2、源码配置编译

##### ①意义

##### ②菜单配置

```c
//载入配置
$ make ARCH=arm64 tegra_defconfig  //导入官方配置
          //会从arch/arm64/configs下 查找tegra_defconfig，导入到当前目录，重命名为.config)
$ make menuconfig //在官方配置基础上进行配置
	
//从零配置
$ mv  .config .config.ago //如有，则改名 -> 清除当前配置(.config)
$ make  menuconfig ARCH=arm64 /*生成最初始配置界面（如不指定ARCH，默认的是x86的）
    当前目录有.config则导入,如无则用默认x86配置生成.config */

//保存配置
$ make savedefconfig //生成defconfig  (相比make  menuconfig 里的Save保存的配置，这是最简的)
$ cp defconfig arch/arm64/configs/yhai_defconfig //发布配置(原厂发布配置到内核就是该方式)
```

##### ③编译

```c
$ make  /*编译所有
 常需指定 交叉编译工具链 CROSS_COMPILE(如无默认采用 gcc)
方式一： make  CROSS_COMPILE=aarch64-linux-gnu-   直接指定
方式二： export CROSS_COMPILE=aarch64-linux-gnu-  导出环境变量
 */
$ make  all
$ make Image //只编译内核
$ make modules //只编译模块
$ make dtbs //只编译设备树

$ make install /*安装内核
 常需指定 安装路径 INSTALL_PATH
方式一： make install INSTALL_PATH=/tftpboot   直接指定
方式二： export INSTALL_PATH=/tftpboot  导出环境变量
 */
$ make modules_install /*安装模块
  常需指定 安装路径 INSTALL_MOD_PATH
方式一：make modules_install INSTALL_MOD_PATH=~/Linux_for_Tegra/rootfs   直接指定
方式二：export INSTALL_MOD_PATH=~/Linux_for_Tegra/rootfs  导出环境变量
 */
 
$ make clean      //清除编译中产生的临时文件(如.o)
$ make distclean  //清除所有(临时文件 + 配置)	
```

##### ④菜单配置的实现

###### (1)顶层配置

```c
{//Kconfig
//对应菜单信息 .config - Linux/arm64 4.9.253 Kernel Configuration
mainmenu "Linux/$ARCH $KERNELVERSION Kernel Configuration"

config SRCARCH
    string
    option env="SRCARCH"

source "arch/$SRCARCH/Kconfig" //导入子Kconfig
	
}

{//arch/arm64/Kconfig
source "init/Kconfig"  //gf  跳转到子配置
    
source "kernel/Kconfig.freezer"                                       
      
source "arch/arm64/Kconfig.platforms"                                 
      
menu "Bus support"                                                    
      
config PCI                                                            
    bool "PCI support"
    help                                                              
      This feature enables support for PCI bus system. If you say Y
      here, the kernel will include drivers and infrastructure code   
      to support PCI bus devices.   
source "drivers/pci/Kconfig"

endmenu

menu "Kernel Features"
menu "Boot options"
config CMDLINE
    string "Default kernel command string"
    default ""
    help
      Provide a set of default command-line options at build time by
      entering them here. As a minimum, you should specify the the
      root device (e.g. root=/dev/nfs).
      
source "net/Kconfig"

source "drivers/Kconfig" //gf跳转

source "drivers/firmware/Kconfig"
      	
}

{//init/Kconfig

menu "General setup"  //常规的内核选项安装

config CROSS_COMPILE
    string "Cross-compiler tool prefix"  //设置交叉编译工具链前缀
    help
      Same as running make CROSS_COMPILE=prefix-' but stored for
      default make runs in this kernel build directory.  You don't
      need to set this unless you want the configured kernel build
      directory to select the cross-compiler automatically.

config BLK_DEV_INITRD      //是否支持ramdisk 做引导roots
    bool "Initial RAM filesystem and RAM disk (initramfs/initrd) support"
}
```

###### (2)平台选择

```shell
//arch/arm64/Kconfig.platforms	  平台选择
menu "Platform selection"	
config ARCH_TEGRA
    bool "NVIDIA Tegra SoC Family"
    select ARCH_HAS_RESET_CONTROLLER
    select CLKDEV_LOOKUP
    select CLKSRC_MMIO
    select CLKSRC_OF
    select GENERIC_CLOCKEVENTS
    select GPIOLIB
    select PINCTRL
    select GENERIC_PINCONF
    select PM
    select PM_GENERIC_DOMAINS
    select RESET_CONTROLLER
    help
      This enables support for the NVIDIA Tegra SoC family
```

###### (3)驱动配置

```
{//drivers/Kconfig
menu "Device Drivers"

source "drivers/base/Kconfig"
source "drivers/net/Kconfig"

}

{//drivers/net/Kconfig
menuconfig NETDEVICES
    default y if UML
    depends on NET
    bool "Network device support"

source "drivers/net/ethernet/Kconfig"
	
}

{//drivers/net/ethernet/Kconfig
source "drivers/net/ethernet/realtek/Kconfig"
}

{//drivers/net/ethernet/realtek/Kconfig
config R8169   //对应Makefile里 $(CONFIG_R8169)
    tristate "Realtek 8169 gigabit ethernet support"
    depends on PCI
    select FW_LOADER
    select CRC32
    select MII
    ---help---
      Say Y here if you have a Realtek 8169 PCI Gigabit Ethernet adapter.

      To compile this driver as a module, choose M here: the module
      will be called r8169.  This is recommended.
	
}
```

###### (4)当前的配置文件

```
//Makefile在编译时通过读取.config文件的配置来选择要编译的文件
CONFIG_ARM64=y
CONFIG_MMU=y
CONFIG_CROSS_COMPILE=""
CONFIG_ROOT_NFS=y	
CONFIG_R8169=y
CONFIG_VIDEO_IMX219=y	
```

###### (5)配置头文件

```c
//include/generated/autoconf.h	配置头文件(编译后自动生成的 )
//通过该文件，可知 当前生效的配置是那些
#define CONFIG_R8169 1     //有线网卡
#define CONFIG_VIDEO_IMX219 1	 //排线摄像头
```

##### ⑤源码编译的实现

###### (1)顶层管理

```c
//Makefile : 顶层 Makefile,负责总体内核的编译链接

ARCH      ?= $(SUBARCH)  //指定arch（如传参 make  ARCH=arm64)，如不指定默认x86
			  //为避免重复输入，强制写死 如ARCH        ?= arm64
CROSS_COMPILE  ?= $(CONFIG_CROSS_COMPILE:"%"=%) //指定交叉编译工具链
              //(如传参 make  CROSS_COMPILE=aarch64-linux-gnu-)
              //强制写死CROSS_COMPILE   ?= aarch64-linux-gnu-

LD		= $(CROSS_COMPILE)ld
CC		= $(CROSS_COMPILE)gcc


//指定源码子目录
drivers-y   := drivers/ sound/ firmware/
core-y      += kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ block/	


srctree := .  //指定源码树顶层目录
objtree := .  //指定目标文件树顶层目录

 
include arch/$(SRCARCH)/Makefile //指定导入 arch的子Makefile
 
 
PHONY := _all //入口：默认的依赖目标: make时，递归查_all依赖文件,
	      //某文件不存在或有更改（时间最新），则把依赖它的文件都重新编译。
_all: all
               
all: modules //make all时，递归查modules的依赖



%config: scripts_basic outputmakefile FORCE
    $(Q)$(MAKE) $(build)=scripts/kconfig $@   //再脚本选择配置入口 如make menuconfig


KCONFIG_CONFIG  ?= .config  //读入当前配置文件
    	

modules: $(vmlinux-dirs) $(if $(KBUILD_BUILTIN),vmlinux) modules.builtin
	$(Q)$(AWK) '!x[$$0]++' $(vmlinux-dirs:%=$(objtree)/%/modules.order) 
	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost


distclean: mrproper    //慎用，它会把你前面的配置，全部清除掉
	@find $(srctree) $(RCS_FIND_IGNORE) \
		-o -name '.*.rej' -o -name '*%' 

help:
	@echo  'Cleaning targets:'
	@echo  '$(CROSS_COMPILE)'	 //查看变量CROSS_COMPILE的内容， 	 @表示不显示eho本身
```

###### (2)通用规则、脚本

```c
//scripts/kconfig/Makefile	
menuconfig: $(obj)/mconf
	$< $(silent) $(Kconfig) 		//导入Kconfig ,生成图形界面
```

###### (3)体系结构的管理

```c
{//arch/arm64/Makefile:  编译体系结构的子Makefile
//负责本体系结构的相关代码编译 生成内核镜像

//指定源码子目录
core-y		+= arch/arm64/kernel/ arch/arm64/mm/
core-$(CONFIG_NET) += arch/arm64/net/    //$(CONFIG_NET)是当配置后，会变为y,或m -> 实现界面配置 那些源码编译或不编译
```

###### (4)子文件的管理

```c
{//init/Makefile
obj-y                          := main.o version.o mounts.o
obj-$(CONFIG_BLK_DEV_INITRD)   += initramfs.o	
}

{//drivers/net/ethernet/realtek/Makefile
obj-$(CONFIG_8139CP) += 8139cp.o
obj-$(CONFIG_8139TOO) += 8139too.o
obj-$(CONFIG_ATP) += atp.o
obj-$(CONFIG_R8169) += r8169.o  //变量$(CONFIG_NET) 由配置时决定 -> 动态决定编译文件
}
```

#### 3、最简√

##### ①下载√

```c
//最简移植，使内核能运行,有信息输出即可

官网下载 //https://www.kernel.org/ 
        //下载与官方同版本，降低移植风险  -> 同分支最新稳定版 -> 主分支最新稳定版
> scp linux-4.9.253.tar.gz  yhai@192.168.0.148:/home/yhbd/bsp/  

$ ls -lh linux-4.9.253.tar.gz /*确认文件大小 -> 避免不完整，后面编译报错
    -rw-r--r-- 1 yhbd yhbd 136M Mar 15 02:50 linux-4.9.253.tar.gz*/

$ tar -xvf linux-4.9.253.tar.gz
```

##### ②最基本运行√

###### (1)编译内核

```c
注 //最简移植，使内核能运行,有信息输出即可
$ cd linux-4.9.253
$ vim Makefile /*直接指定ARCH  CROSS_COMPILE （写死的）
ARCH            = arm64
CROSS_COMPILE   = aarch64-linux-gnu-
在板子上直接编译可不指定CROSS_COMPILE ,因gcc本来就是arm64的*/

$ make tegra_defconfig  /*导入官方配置
  报错：Can't find default configuration "arch/arm64/configs/tegra_defconfig"!
  原因是 找不到配置，可以把官方的移植好的内核4.9里的配置拷贝过来     */

$ make Image -j5 /*只编译内核
  成功则会生成内核镜像  arch/arm64/boot/Image   */
```

###### (2)运行调试

```c
$ cd  /boot/extlinux/
$ sudo cp extlinux.conf  extlinux_yh.conf
$ sudo chmod 777 extlinux_yh.conf
$ vim extlinux_yh.conf  /*指定从新内核启动
 改	LINUX /boot/Image 
 为 LINUX /home/yhbd/bsp/linux-4.9.253/arch/arm64/boot/Image 
 */
重启板子 快速停在u-boot阶段 
# setenv boot_syslinux_conf extlinux/extlinux_yh.conf  //指定启动配置文件为我们自定义的
                //原默认的是 boot_syslinux_conf=extlinux/extlinux.conf
# run distro_bootcmd //从tf卡启动 
```

###### (3)对比找线索

```c
问题 //内核停住了，不能往下运行挂载rootfs	
原因 //内核没移植好，但具体是什么问题
 
//对比OK的日志 ->  看差异找线索
# setenv boot_syslinux_conf extlinux/extlinux.conf	
# run distro_bootcmd

//获取更多的内核信息
setenv boot_syslinux_conf extlinux/extlinux_q.conf
去掉extlinux.conf中的quiet
```

##### ③用最小系统辅助分析√

```shell
只产生单一变量Image
$ setenv ramdisk_bootcmd  ext4load mmc 1:1 0x84000000 /boot/Image \; ext4load mmc 1:1 83100000	  /boot/tegra210-p3448-0002-p3449-0000-b00.dtb \; ext4load mmc 1:1  0xa0000000 /home/yhbd/ramdisk.img.gz \; booti 0x84000000 - 83100000
$ run ramdisk_bootcmd  //用OK的内核能挂载rootfs成功，保存日志，用于分析

$ setenv ramdisk_bootcmd  ext4load mmc 1:1 0x84000000 /home/yhbd/bsp/linux-4.9.253/arch/arm64/boot/Image \; ext4load mmc 1:1 83100000	  /boot/tegra210-p3448-0002-p3449-0000-b00.dtb \; ext4load mmc 1:1  0xa0000000 /home/yhbd/ramdisk.img.gz \; booti 0x84000000 - 83100000
$ saveenv
$ run ramdisk_bootcmd  //用移植的内核挂载rootfs失败，保存日志
```

###### (1)添加文件名行号->跟踪源码位置

```c
改最底层的打印，加上文件名行号
/*include/linux/printk.h 
#define pr_emerg(fmt, ...) \
    do { printk(KERN_EMERG pr_fmt(fmt),##__VA_ARGS__); printk(KERN_DEBUG "//yh emerg:%s %s %d",__FILE__,__func__,__LINE__); } while (0)
#define pr_alert(fmt, ...) \
    do { printk(KERN_ALERT pr_fmt(fmt),##__VA_ARGS__); printk(KERN_DEBUG "//yh alert:%s %s %d",__FILE__,__func__,__LINE__); } while (0)
#define pr_crit(fmt, ...) \
    do { printk(KERN_CRIT pr_fmt(fmt),##__VA_ARGS__); printk(KERN_DEBUG "//yh cirt:%s %s %d",__FILE__,__func__,__LINE__); } while (0)
#define pr_err(fmt, ...) \
    do { printk(KERN_ERR pr_fmt(fmt),##__VA_ARGS__); printk(KERN_DEBUG "//yh err:%s %s %d",__FILE__,__func__,__LINE__); } while (0)
#define pr_warning(fmt, ...) \
    do { printk(KERN_WARNING pr_fmt(fmt),##__VA_ARGS__); printk(KERN_DEBUG "//yh warn:%s %s %d",__FILE__,__func__,__LINE__); } while (0)
#define pr_warn pr_warning
#define pr_notice(fmt, ...) \
    do { printk(KERN_NOTICE pr_fmt(fmt),##__VA_ARGS__); printk(KERN_DEBUG "//yh notice:%s %s %d",__FILE__,__func__,__LINE__); } while (0)
#define pr_info(fmt, ...) \
    do { printk(KERN_INFO pr_fmt(fmt),##__VA_ARGS__); printk(KERN_DEBUG "//yh infor:%s %s %d",__FILE__,__func__,__LINE__); } while (0)
*/
	  
$ make Image  -j5
// 添加loglevel=8 输出所有信息，我们添加的文件名行号是KERN_DEBUG 级别也会显示出来
$ setenv bootargs initrd=0xa0000000,0x800000 root=/dev/ram0 rw  rootwait rootfstype=ext2 console=ttyS0,115200 init=/linuxrc ip=192.168.5.8  loglevel=8
$ saveenv		
```

###### (2)对比OK异常的带行号的日志

```c
$ cd ~/linux-4.9.253
$ make Image -j5 /*编译可能问题
 $ ls -lh arch/arm64/boot/Image 查看大小发现为零，
 可尝试删除后重新编译
 $ rm -f arch/arm64/boot/Image
 $ rm -f  vmlinux
 $ make Image -j5
 */
$ cp arch/arm64/boot/Image ~/
$ ls -lh ~/Image  //注意确保 大小正确

$ setenv ramdisk_bootcmd  ext4load mmc 1:1 0x84000000 /home/yhbd/bsp/linux-4.9.253/arch/arm64/boot/Image \; ext4load mmc 1:1 83100000	  /boot/tegra210-p3448-0002-p3449-0000-b00.dtb \; ext4load mmc 1:1  0xa0000000 /home/yhbd/ramdisk.img.gz \; booti 0x84000000 - 83100000

$ run ramdisk_bootcmd/*
可能错误
 报错: Bad Linux ARM64 Image magic!
 原因：可能是tf卡 文件系统数据未同步
 建议重启后，rm -f arch/arm64/boot/Image 再重编一下make Image -j5
   cp arch/arm64/boot/Image ~/ 拷贝一次数据
   ls -lh ~/Image  看看内核大小对不对
 sync 命令同步一下 */

$ setenv ramdisk_bootcmd  ext4load mmc 1:1 0x84000000 /home/yhbd/kernel-4.9/arch/arm64/boot/Image \; ext4load mmc 1:1 83100000	  /boot/tegra210-p3448-0002-p3449-0000-b00.dtb \; ext4load mmc 1:1  0xa0000000 /home/yhbd/ramdisk.img.gz \; booti 0x84000000 - 83100000
$ run ramdisk_bootcmd
```

##### ④尝试1：屏蔽 导致异常的代码√

```c
异常：停在hctosys: unable to open rtc device 处

//屏蔽调hctosys
$ vim drivers/rtc/hctosys.c	/*
:38  
查看错误位置，发现 是加载模块 
late_initcall(rtc_hctosys); 时出了问题，
可尝试配置里取消该模块
:Ve  
打开 Kconfig  发现是
config RTC_HCTOSYS                                           
     bool "Set system time from RTC on startup and resume"
 */
$ make menuconfig /*配置 取消该模块
  Device Drivers  --->
       [*] Real Time Clock  --->
           [ ]   Set system time from RTC on startup and resume   
 */
$ sudo  reboot //用命令重启，它会做一下数据同步工作
 
$ setenv ramdisk_bootcmd  ext4load mmc 1:1 0x84000000 /home/yhbd/linux-4.9.253/arch/arm64/boot/Image \; ext4load mmc 1:1 83100000	  /boot/tegra210-p3448-0002-p3449-0000-b00.dtb \; ext4load mmc 1:1  0xa0000000 /home/yhbd/ramdisk.img.gz \; booti 0x84000000 - 83100000
$ saveenv
$ run ramdisk_bootcmd 

//发现还是会报内核异常 （irq 94: nobody cared (try booting with the "irqpoll" option)
初步确定不是 hctosys 模块导致的问题
```

##### ⑤尝试2：设备树移植√

```c
对比日志发现，设备树扫描有问题
//参考官方设备树，移植过来

原则 //尽量少改动
//官方的设备树和驱动是，独立在外的，只是编译时关联进来

$ cd /home/yhbd/bsp/Linux_for_Tegra/source/public/kernel
$ mv ~/bsp/linux-4.9.253  .   //让源码目录，放在kernel-4.9旁，可不用修改，编译到独立在外设备树，驱动等源码
$ cd 	linux-4.9.253
$ mv Makefile Makefile.org //备份原来的
$ cp ../kernel-4.9/Makefile . //借用，英伟达的能独立编译外部设备树的Makefile
同理把 arch/arm64/Makefile  arch/arm64/boot/Makefile arch/arm64/boot/dts/Makefile  拷贝过来

$ make dtbs  /*编译设备树
  报错 recipe-for */
$ mv scripts scripts.org 
$ cp ../kernel-4.9/scripts .
$ make dtbs

$ cp arch/arm64/boot/dts/tegra210-p3448-0002-p3449-0000-b00.dtb  ~/

$ setenv ramdisk_bootcmd  ext4load mmc 1:1 0x84000000 /home/yhbd/linux-4.9.253/arch/arm64/boot/Image \; ext4load mmc 1:1 83100000	  /home/yhbd/tegra210-p3448-0002-p3449-0000-b00.dtb \; ext4load mmc 1:1  0xa0000000 /home/yhbd/ramdisk.img.gz \; booti 0x84000000 - 83100000
$ saveenv
$ run ramdisk_bootcmd

 //发现错误还在  OF: fdt:Reserved memory: failed to reserve memory for node 'fb0_carveout'
```

##### ⑥挑战

```
先尝试解决一下，看能否解决挂载ramdisk 失败得问题。 （难度挺大）
如何还不行，也可换个内核版本，试试
```

#### 4、从零开始√

##### ①下载

```
//可换个内核版本试试 -> 交叉验证	
//以4.9分支的最新版本为例，作业,用最新的内核稳定版本试试
官网下载 //https://www.kernel.org/ -> 选同分支的，最新稳定版本
> scp linux-4.9.307.tar.xz yhbd@192.168.0.148:/home/yhbd/bsp/	
```

##### ②最基本输出***

```c
$ tar -xvf linux-4.9.307.tar.gz
$ cd linux-4.9.307
$ vim Makefile /* 指定ARCH，交叉编译工具链
257 ARCH        ?= arm64
258 CROSS_COMPILE   = aarch64-linux-gnu-	*/	

$ make menuconfig  //生成配置（默认会载入arch/arm64/defconfig)  不配置，保存退出                 
$ make Image -j5 /*只编译内核
 成功则会生成内核镜像  arch/arm64/boot/Image */

$ cp arch/arm64/boot/Image  ~/  //拷贝内核到验证位置

# setenv yhai_bootcmd  ext4load mmc 1:1 0x84000000 /home/yhbd/Image \; booti 0x84000000 
# run yhai_bootcmd  //运行自定义的启动命令
           //发现没有没任何信息输出，请先思考一下原因，再往下看
```

###### (1)没任何信息输出原因

```c
//1、先验证需bootargs 内核
# setenv bootargs console=ttyS0,115200 
//2、使用ok的内核验证一下是不是对的
setenv yhai_bootcmd  ext4load mmc 1:1 0x84000000 /boot/Image \; booti 0x84000000 
//3、需设备树信息(如串口的地址)
# setenv yhai_bootcmd  ext4load mmc 1:1 0x84000000 /home/yhbd/Image \; ext4load mmc 1:1 83100000 /boot/tegra210-p3448-0002-p3449-0000-b00.dtb \;  booti 0x84000000 - 83100000
//4、再换成ok版本的内核，添加设备树，继续验证
  setenv yhai_bootcmd  ext4load mmc 1:1 0x84000000 /boot/Image \; ext4load mmc 1:1 83100000 /boot/tegra210-p3448-0002-p3449-0000-b00.dtb \;  booti 0x84000000 - 83100000
```

###### (2)借用方OK的配置

```c
$ cp ~/kernel-4.9/.config  .  //直接拷当前配置过来呢
$ make menuconfig  //激活导入配置（如果跳过这步，直接make Image,会弹出很多询问，因你篡改了.config
$ make Image  -j5
```

###### (3)解决编译问题

```c
drivers/built-in.o: In function `max77620_wdt_remove':
/home/yhbd/bsp/linux-4.9.307/drivers/watchdog/max77620_wdt.c:199: undefined reference to `watchdog_unregister_device'
drivers/built-in.o: In function `max77620_wdt_probe':
/home/yhbd/bsp/linux-4.9.307/drivers/watchdog/max77620_wdt.c:185: undefined reference to `watchdog_register_device'
Makefile:1020: recipe for target 'vmlinux' failed
make: *** [vmlinux] Error 1
	
//解决编译错误，尽量不要改源码和Makefile,而是通过menuconfig里取消配置的方式
将编译好的Image重启后再来测试
```

###### (4)裁剪到最小配置（内核有输出）

```
采用做减法方式，从借用OK得配置，不断删减配置，找到最终营销串口信息输出得，最简配置
去掉非常不相干得 /*如
           Bus support  --->      
      Firmware Drivers  --->       
          File systems  --->               
      [ ] Virtualization  ----
  Security options  --->             
      [ ] Cryptographic API  ----
          Library routines  --->   
	*/
把无关驱动去掉 /*	
  Misc devices
  I2C support  ---
  PPS support
   Sonics Silicon Backplane
   Graphics support
   HID support
   LED Support
	*/
 最后仅保留
我的裁剪后的配置，见百度网盘.config.ramdisk.ko
```

##### ③支持RAMDISK

```c
$ make menuconfig  /*配置支持RAMDISK
General setup  --->
	[*] Initial RAM filesystem and RAM disk (initramfs/initrd) support
Platform selection  ---> 
  取消其它，只保留
  [*] NVIDIA Tegra SoC Family
Device Drivers  --->  
	[*] Block devices  --->
	    <*>   RAM block device support
	        (16)    Default number of RAM disks (NEW) 
	        (8192)  Default RAM disk size (kbytes)   要设为8192 和前面ramdisk匹配  	
          注意：做的ramdisk不匹配，则启动时仍然会出现kernel panic内核恐慌，提示ramdisk格式不正确，挂载不上ramdisk。
File systems  --->
  <*> Second extended fs support   对应ramdisk的 ex2格式 */	
$ make Image -j5 //只编译内核
```

###### 运行测试

```c
$ setenv bootargs initrd=0xa0000000,0x800000 root=/dev/ram0 rw  rootwait rootfstype=ext2 console=ttyS0,115200 init=/linuxrc ip=192.168.5.8 

$ setenv ramdisk_bootcmd  ext4load mmc 1:1 0x84000000 /home/yhbd/Image \; ext4load mmc 1:1 83100000	  /boot/tegra210-p3448-0002-p3449-0000-b00.dtb \; ext4load mmc 1:1  0xa0000000 /home/yhbd/ramdisk.img.gz \; booti 0x84000000 - 83100000

$ run ramdisk_bootcmd
```

##### ④挑战

```
1. 用最新的内核稳定版本，试试从零移植

2. 尝试裁剪到最小配置

3. 尝试看去解决ramdisk挂不上问题 （难度极大，可跳过）
```

### 六、设备树

#### 1、切入

##### ①承前

##### ②灵魂拷问

![设备树](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\设备树.png)

###### (1)什么是设备树

![什么是设备树](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\什么是设备树.png)

```
一种描述硬件 连接信息的数据结构
采用结点（node）和属性（property）嵌套构成树形结构
```

###### (2)为什么要用设备树

```c
问题  //内核里充斥大量 描述板级细节的垃圾代码 如arch/arm/mach-xxx
解决  //用设备树集中描述硬件细节 -> 分离好维护
面试工作 //设备树 已变成移植的核心，不再是芯片手册，设备树是移植和驱动开发的核心关键
```

###### (3)如何学设备树，关键点，难点在那

```c
结合板子实例讲解（纯讲语法规则，太虚）
难点  //设备树描述凌乱晦涩，不同设备不一样，要根据具体设备，查对应文档 
关键点  //学会根据具体设备树文档，查芯片手册，会改对应设备树，这是移植关键
```

##### ③参考资源

###### (1)官网

```c
官网 //https://www.devicetree.org/  
     //可下载pdf手册  devicetree-specification-v0.4-rc1.pdf
     //https://github.com/devicetree-org/devicetree-specification/tree/main/source  可网页翻译
```

###### (2)指导文档

```
Documentation/devicetree/bindings 指导如果编写设备树的协议文档
```

###### (3)示例源码

```
示例源码 //厂商BSP中提供的设备树	
         //内核中发布的设备树
```

#### 2、编译运行

##### ①编译

```
$ cd linux-4.9.307	
$ make dtbs /* 编译生成设备树dtb
  DTC     arch/arm64/boot/dts/nvidia/tegra210-p2371-0000.dtb
  DTC     arch/arm64/boot/dts/nvidia/tegra210-p2371-2180.dtb
  DTC     arch/arm64/boot/dts/nvidia/tegra210-p2571.dtb
  DTC     arch/arm64/boot/dts/nvidia/tegra210-smaug.dtb
  */
{//arch/arm64/boot/dts/nvidia/Makefile
dtb-$(CONFIG_ARCH_TEGRA_132_SOC) += tegra132-norrin.dtb
dtb-$(CONFIG_ARCH_TEGRA_210_SOC) += tegra210-p2371-0000.dtb
dtb-$(CONFIG_ARCH_TEGRA_210_SOC) += tegra210-p2371-2180.dtb
dtb-$(CONFIG_ARCH_TEGRA_210_SOC) += tegra210-p2571.dtb
dtb-$(CONFIG_ARCH_TEGRA_210_SOC) += tegra210-smaug.dtb  //指定编译的设备树名

always      := $(dtb-y)    
clean-files := *.dtb	
}

tegra210-smaug.dts  //描述开发板
tegra210.dtsi  //描述cpu

注 //内核里发布的设备树，和厂商BSP给的有差异，以BSP里为准 （原因可能是厂商未同步发布到新版内核中）

```

##### ②运行

```
# setenv bootargs initrd=0xa0000000,0x800000 root=/dev/ram0 rw  rootwait rootfstype=ext2 console=ttyS0,115200 init=/linuxrc ip=192.168.9.9 loglevel=8
# setenv yhai_bootcmd  ext4load mmc 1:1 0x84000000 /home/yhbd/Image \; ext4load mmc 1:1 83100000	  /home/yhbd/tegra210-smaug.dtb \; ext4load mmc 1:1  0xa0000000 /home/yhbd/ramdisk.img.gz \; booti 0x84000000 - 83100000
# mw  83100000  0  50     //注意：必须把设备树拷贝到的内存地址 清零，避免用之前残留的(否则会发现，用不存在或有问题的dtb文件也能启动内核)      
# run  yhai_bootcmd  //运行（注：如发现和期望不一致，可手动的ext4load 下载每个文件看大小，甚至用md命令看二进制的值）
# cat /sys/firmware/devicetree/base/compatible  //查看实际加载的设备树的名字
```

##### ③不匹配的呢

```
//换个不匹配的dtb试试 -> 不匹配的不能运行，而前面的dtb能运行，从而确信它 是 和内核cpu匹配的

$ vim arch/arm64/boot/dts/nvidia/Makefile /*  强势编译生成一个和cpu不匹配的dtb
 dtb-$(CONFIG_ARCH_TEGRA_132_SOC) += tegra132-norrin.dtb
 改为
 dtb-y += tegra132-norrin.dtb 
 */		
$ make dtbs
$ cp  arch/arm64/boot/dts/nvidia/tegra132-norrin.dtb  ~
重启板子
# setenv yhai_bootcmd  ext4load mmc 1:1 0x84000000 /home/yhbd/Image \; ext4load mmc 1:1 83100000	  /home/yhbd/tegra132-norrin.dtb \; ext4load mmc 1:1  0xa0000000 /home/yhbd/ramdisk.img.gz \; booti 0x84000000 - 83100000
# mw  83100000  0  50	
# run yhai_bootcmd  //发现 start kernel 后没有任何信息输出 -> 是我们期望的，
     //可能原因：内核启动有检测dtb匹不匹配(如不匹配，不会启动输出内核版本信息)
      //        或，设备树里面设置有问题 如 serial0 = &uarta;  而uarta里地址设置不对，串口设置 不对，当然没有信息输出

```

#### 3、加载解析

##### ①U-BOOT与内核匹配检查

```
# bd  /*查看板子信息结构体	
arch_number = 0x0000000000000000  机器码(板子id) -> 在uboot和内核之间进行比对适配
   内核启动后start kernel 报检测id错误Error: unrecognized/unsupported machine ID，就是不匹配导致。 
boot_params = 0x0000000080000100  启动参数bootargs的存放地址
fdt_blob    = 0x00000000fc5fa380
*/	
# booti 0x84000000 - 83100000  //0x84000000为内核地址  -表示忽略ramdisk地址  83100000为设备树的地址
 
arm32 //启动有fdt addr时，会 dtb中的 compatible 属性与内核 DT_MACHINE_START 列表匹配，有则匹配能启动
      //没有fdt addr时，则检测 机器ID 与 MACHINE_START(老版本)
arm64 //取消匹配检查 
```



##### ②内核的设备树安装

```c
//arch/arm64/kernel/setup.c
void __init setup_arch(char **cmdline_p)
{
    pr_info("Boot CPU: AArch64 Processor [%08x]\n", read_cpuid_id());
    setup_machine_fdt(__fdt_pointer); //设备树安装(__fdt_pointer 是 DTB位于内存中的物理地址 )
    
    unflatten_device_tree();//非扁平化，也就是把dtb构造成树的结构(避免每次都扫描dtb，慢）
}

static void __init setup_machine_fdt(phys_addr_t dt_phys)
{
    const char *name;
    void *dt_virt = fixmap_remap_fdt(dt_phys); /*因MMU已打开，要转为内核中能访问的虚地址
    
    void *__init fixmap_remap_fdt(phys_addr_t dt_phys)
     {
	void *dt_virt;
	int size;

	dt_virt = __fixmap_remap_fdt(dt_phys, &size, PAGE_KERNEL_RO);
	if (!dt_virt)
	   return NULL;

	memblock_reserve(dt_phys, size); 把这片内存给保留起来 -> 后续的内存分配中就不会使用DTB占用的内存
	return dt_virt;
    }

        */
    if (!dt_virt || !early_init_dt_scan(dt_virt)) { //dtb扫描，完成早期初始化
        pr_crit("\n"     //blob: 是一种二进制数据格式
            "Error: invalid device tree blob at physical address %pa (virtual address 0x%p)\n"
            "The dtb must be 8-byte aligned and must not exceed 2 MB in size\n"
            "\nPlease check your bootloader.",
            &dt_phys, dt_virt);
    
        while (true)
            cpu_relax();
    }
    //更改了  dump_stack_set_arch_desc("%s (DT)", of_flat_dt_get_machine_name); 为下面方式添加了机器名的输出
    name = of_flat_dt_get_machine_name(); /*获取设备的机器名(对应设备树里的model 和 compatible)
	 const char * __init of_flat_dt_get_machine_name(void)
	 {
		const char *name;
		unsigned long dt_root = of_get_flat_dt_root();

		name = of_get_flat_dt_prop(dt_root, "model", NULL);
		if (!name)
		   name = of_get_flat_dt_prop(dt_root, "compatible", NULL);
		return name;
	}
      */
    if (!name){
       pr_info("of_flat_dt_get_machine_name fail\n"); 
        return;
    }
    pr_info("Machine model: %s\n", name); //输出设备名：如  NVIDIA Jetson Nano Developer Kit（对应设备树里的model） -> 看到该信息，才说明设备树加载成功
    dump_stack_set_arch_desc("%s (DT)", name); 
    
}

```

##### ③内核对设备树扫描和检测

```c
//drivers/of/fdt.c
bool __init early_init_dt_scan(void *params)
{
    bool status;

    status = early_init_dt_verify(params); //设备树合法性验证
    if (!status)
        return false;

    early_init_dt_scan_nodes(); /* 设备树的节点扫描 完成早期初始化
	void __init early_init_dt_scan_nodes(void)
	{
	   //扫描 /chosen 节点信息 （把bootargs属性值拷贝到boot_command_line）
	   of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);

	   //扫描根节点的属性信息 {size,address}-cells  
	   of_scan_flat_dt(early_init_dt_scan_root, NULL);

	   //扫描 memory节点，完成内存配置初始化  
	   of_scan_flat_dt(early_init_dt_scan_memory, NULL);
	}       
     */
    return true;
}

bool __init early_init_dt_verify(void *params)
{
    if (!params)
        return false;

    /* check device tree validity */
    if (fdt_check_header(params)) /*检查dtb的头信息
        int fdt_check_header(const void *fdt)
	{
	   if (fdt_magic(fdt) == FDT_MAGIC) { //检查dtb的幻数
		//define FDT_MAGIC   0xd00dfeed  必须和前面dtb 开始二级制的值一致（00000000: d00d feed）

	    if (fdt_version(fdt) < FDT_FIRST_SUPPORTED_VERSION)
		return -FDT_ERR_BADVERSION;
	    if (fdt_last_comp_version(fdt) > FDT_LAST_SUPPORTED_VERSION)
		return -FDT_ERR_BADVERSION;
	    } else if (fdt_magic(fdt) == FDT_SW_MAGIC) {

		if (fdt_size_dt_struct(fdt) == 0)
		   return -FDT_ERR_BADSTATE;
	        } else {
		return -FDT_ERR_BADMAGIC;
	        }   

		 return 0;
	    }
         */
        return false;

    /* Setup flat device-tree pointer */
    initial_boot_params = params;  //把DTB基地址放入到initial_boot_params
    of_fdt_crc32 = crc32_be(~0, initial_boot_params, //计算crc32校验码
                fdt_totalsize(initial_boot_params));
    return true;
}

```

###### 查看DTB二进制

```c
$ vim -b arch/arm64/boot/dts/nvidia/tegra210-smaug.dtb
:%!xxd	 //转换为十六进制显示,如
%!xxd -r //返回原显示

//对应结构体
struct fdt_header {
    fdt32_t magic;           /* magic word FDT_MAGIC */
    fdt32_t totalsize;       /* total size of DT block */
    fdt32_t off_dt_struct;       /* offset to structure */
    fdt32_t off_dt_strings;      /* offset to strings */
    fdt32_t off_mem_rsvmap;      /* offset to memory reserve map */
    fdt32_t version;         /* format version */
};

```

#### 4、裁剪到最简

##### ①裁剪到支持RAMDISK

```c
//用条件编译来裁剪
#if 0  
#endif 

//编译运行
$ make dtbs //编译后重启
# setenv bootargs //清除bootargs,使用设备树里chosen指定的
# setenv yhai_bootcmd  ext4load mmc 1:1 0x84000000 /home/yhbd/Image \; ext4load mmc 1:1 83100000	 /home/yhbd/linux-4.9.307/arch/arm64/boot/dts/nvidia/board.dtb \; ext4load mmc 1:1  0xa0000000 /home/yhbd/ramdisk.img.gz \; booti 0x84000000 - 83100000
# saveneenv
# mw  83100000  0  50 
# run  yhai_bootcmd //发现串口能正常输出信息	
```

###### (1)板子的描述

```c
//arch/arm64/boot/dts/nvidia/board.dts	
/dts-v1/;
#include <dt-bindings/input/input.h>
#include <dt-bindings/mfd/max77620.h>
#include <dt-bindings/pinctrl/pinctrl-tegra.h>

#include "cpu.dtsi"

/ {
	model = "Google Pixel C";
	compatible = "nvidia,tegra210";

	aliases {
	    serial0 = &uarta;
	};
	chosen {
	    bootargs = "earlycon";
	    stdout-path = "serial0:115200n8";
	};
	memory {
	    device_type = "memory";
	    reg = <0x0 0x80000000 0x0 0xc0000000>;
	};    
	serial@70006000 {
	  status = "okay";
	};
	clocks {
		compatible = "simple-bus";
		#address-cells = <1>;
		#size-cells = <0>;

		clk32k_in: clock@0 {
			compatible = "fixed-clock";
			reg = <0>;
			#clock-cells = <0>;
			clock-frequency = <32768>;
		};
	};
};	
```

###### (2)CPU的描述

```c
//arch/arm64/boot/dts/nvidia/cpu.dtsi
#include <dt-bindings/clock/tegra210-car.h>
#include <dt-bindings/gpio/tegra-gpio.h>
#include <dt-bindings/memory/tegra210-mc.h>
#include <dt-bindings/pinctrl/pinctrl-tegra.h>
#include <dt-bindings/interrupt-controller/arm-gic.h>
#include <dt-bindings/thermal/tegra124-soctherm.h>

/ {
	compatible = "nvidia,tegra210";
	interrupt-parent = <&lic>;
	#address-cells = <2>;
	#size-cells = <2>;

	gic: interrupt-controller@50041000 {
		compatible = "arm,gic-400";
		#interrupt-cells = <3>;
		interrupt-controller;
		reg = <0x0 0x50041000 0x0 0x1000>,
		      <0x0 0x50042000 0x0 0x2000>,
		      <0x0 0x50044000 0x0 0x2000>,
		      <0x0 0x50046000 0x0 0x2000>;
		interrupts = <GIC_PPI 9
			(GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>;
		interrupt-parent = <&gic>;
	};

	lic: interrupt-controller@60004000 {
		compatible = "nvidia,tegra210-ictlr";
		reg = <0x0 0x60004000 0x0 0x40>, /* primary controller */
		      <0x0 0x60004100 0x0 0x40>, /* secondary controller */
		      <0x0 0x60004200 0x0 0x40>, /* tertiary controller */
		      <0x0 0x60004300 0x0 0x40>, /* quaternary controller */
		      <0x0 0x60004400 0x0 0x40>, /* quinary controller */
		      <0x0 0x60004500 0x0 0x40>; /* senary controller */
		interrupt-controller;
		#interrupt-cells = <3>;
		interrupt-parent = <&gic>;
	};

	tegra_car: clock@60006000 {
		compatible = "nvidia,tegra210-car";
		reg = <0x0 0x60006000 0x0 0x1000>;
		#clock-cells = <1>;
		#reset-cells = <1>;
	};
    
#if 1
	apbdma: dma@60020000 {
		compatible = "nvidia,tegra210-apbdma", "nvidia,tegra148-apbdma";
		reg = <0x0 0x60020000 0x0 0x1400>;
		interrupts = <GIC_SPI 104 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 105 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 106 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 128 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 132 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 133 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 134 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
			     <GIC_SPI 143 IRQ_TYPE_LEVEL_HIGH>;
		clocks = <&tegra_car TEGRA210_CLK_APBDMA>;
		clock-names = "dma";
		resets = <&tegra_car 34>;
		reset-names = "dma";
		#dma-cells = <1>;
	};

#endif
#if 1
	apbmisc@70000800 {
		compatible = "nvidia,tegra210-apbmisc", "nvidia,tegra20-apbmisc";
		reg = <0x0 0x70000800 0x0 0x64>,   /* Chip revision */
		      <0x0 0x7000e864 0x0 0x04>;   /* Strapping options */
	};
#endif

	uarta: serial@70006000 {
		compatible = "nvidia,tegra210-uart", "nvidia,tegra20-uart";
		reg = <0x0 0x70006000 0x0 0x40>;
		reg-shift = <2>;
		interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
		clocks = <&tegra_car TEGRA210_CLK_UARTA>;
		clock-names = "serial";
		resets = <&tegra_car 6>;
		reset-names = "serial";
#if 1
		dmas = <&apbdma 8>, <&apbdma 8>;
		dma-names = "rx", "tx";
#endif
		status = "disabled";
	};

	pmc: pmc@7000e400 {
		compatible = "nvidia,tegra210-pmc";
		reg = <0x0 0x7000e400 0x0 0x400>;
		clocks = <&tegra_car TEGRA210_CLK_PCLK>, <&clk32k_in>;
		clock-names = "pclk", "clk32k_in";
#if 1
		powergates {
			pd_audio: aud {
				clocks = <&tegra_car TEGRA210_CLK_APE>,
					 <&tegra_car TEGRA210_CLK_APB2APE>;
				resets = <&tegra_car 198>;
				#power-domain-cells = <0>;
			};

			pd_sor: sor {
				clocks = <&tegra_car TEGRA210_CLK_SOR0>,
					 <&tegra_car TEGRA210_CLK_SOR1>,
					 <&tegra_car TEGRA210_CLK_CSI>,
					 <&tegra_car TEGRA210_CLK_DSIA>,
					 <&tegra_car TEGRA210_CLK_DSIB>,
					 <&tegra_car TEGRA210_CLK_DPAUX>,
					 <&tegra_car TEGRA210_CLK_DPAUX1>,
					 <&tegra_car TEGRA210_CLK_MIPI_CAL>;
				resets = <&tegra_car TEGRA210_CLK_SOR0>,
					 <&tegra_car TEGRA210_CLK_SOR1>,
					 <&tegra_car TEGRA210_CLK_CSI>,
					 <&tegra_car TEGRA210_CLK_DSIA>,
					 <&tegra_car TEGRA210_CLK_DSIB>,
					 <&tegra_car TEGRA210_CLK_DPAUX>,
					 <&tegra_car TEGRA210_CLK_DPAUX1>,
					 <&tegra_car TEGRA210_CLK_MIPI_CAL>;
				#power-domain-cells = <0>;
			};

			pd_xusbss: xusba {
				clocks = <&tegra_car TEGRA210_CLK_XUSB_SS>;
				resets = <&tegra_car TEGRA210_CLK_XUSB_SS>;
				#power-domain-cells = <0>;
			};

			pd_xusbdev: xusbb {
				clocks = <&tegra_car TEGRA210_CLK_XUSB_DEV>;
				resets = <&tegra_car 95>;
				#power-domain-cells = <0>;
			};

			pd_xusbhost: xusbc {
				clocks = <&tegra_car TEGRA210_CLK_XUSB_HOST>;
				resets = <&tegra_car TEGRA210_CLK_XUSB_HOST>;
				#power-domain-cells = <0>;
			};
		};
#endif
	};

	cpus {
		#address-cells = <1>;
        #size-cells = <0>;

		cpu@0 {
			device_type = "cpu";
			compatible = "arm,cortex-a57";
			reg = <0>;
		};

		cpu@1 {
			device_type = "cpu";
			compatible = "arm,cortex-a57";
			reg = <1>;
		};

		cpu@2 {
			device_type = "cpu";
			compatible = "arm,cortex-a57";
			reg = <2>;
		};

		cpu@3 {
			device_type = "cpu";
			compatible = "arm,cortex-a57";
			reg = <3>;
		};
	};

	timer {
		compatible = "arm,armv8-timer";
		interrupts = <GIC_PPI 13
				(GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
			     <GIC_PPI 14
				(GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
			     <GIC_PPI 11
				(GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
			     <GIC_PPI 10
				(GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>;
		interrupt-parent = <&gic>;
	};

};
```

##### ②裁剪到支持串口输出

```c
$ make dtbs //编译后重启
# run  yhai_bootcmd //发现串口能正常输出信息	
```

###### (1)板子的描述

```c
//arch/arm64/boot/dts/nvidia/board.dts		
/dts-v1/;
#include "cpu.dtsi"

/ {
    model = "Google Pixel C";
    compatible = "nvidia,tegra210";

    aliases {
        serial0 = &uarta;
    };
    chosen {
        bootargs = "earlycon";
        stdout-path = "serial0:115200n8";
    };
    memory {
        device_type = "memory";
        reg = <0x0 0x80000000 0x0 0xc0000000>;
    };    
    serial@70006000 {
	status = "okay";  //打开uarta
    };
};	
```

###### (2)CPU的描述

##### ③合并成一个文件

```c
//arch/arm64/boot/dts/board.dts	  
/dts-v1/;
#include <dt-bindings/clock/tegra210-car.h>
#include <dt-bindings/interrupt-controller/arm-gic.h>
/dts-v1/;
/ {
	model = "yhai jetson nano";
	compatible = "yhai,tegra210";
	#address-cells = <2>;
	#size-cells = <2>;
	cpus {
	    #address-cells = <1>;
	    #size-cells = <0>;
	    cpu@0 {
	        device_type = "cpu";
	        compatible = "arm,cortex-a57";
	        reg = <0>;
	    };   

	    cpu@1 {
	        device_type = "cpu";
	        compatible = "arm,cortex-a57";
	        reg = <1>;
	    };
	               
	};      

	chosen {
	    bootargs = "earlycon";
	    stdout-path = "serial0:115200n8";
	};

	memory {
	    device_type = "memory";
	    reg = <0x0 0x80000000 0x0 0xc0000000>;
	};    

	gic: interrupt-controller@50041000 {
		compatible = "arm,gic-400";
		#interrupt-cells = <3>;
		interrupt-controller;
		reg = <0x0 0x50041000 0x0 0x1000>,
		      <0x0 0x50042000 0x0 0x2000>,
		      <0x0 0x50044000 0x0 0x2000>,
		      <0x0 0x50046000 0x0 0x2000>;
		interrupts = <GIC_PPI 9
			(GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>;
		interrupt-parent = <&gic>;
	};

	tegra_car: clock@60006000 {
		compatible = "nvidia,tegra210-car";
		reg = <0x0 0x60006000 0x0 0x1000>;
		#clock-cells = <1>;
		#reset-cells = <1>;
	};

	timer {
		compatible = "arm,armv8-timer";
		interrupts = <GIC_PPI 13
				(GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
			     <GIC_PPI 14
				(GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
			     <GIC_PPI 11
				(GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
			     <GIC_PPI 10
				(GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>;
		interrupt-parent = <&gic>;
	};

	pmc: pmc@7000e400 {
		compatible = "nvidia,tegra210-pmc";
		reg = <0x0 0x7000e400 0x0 0x400>;
	};

	aliases {
	    serial0 = &uarta;
	};

	uarta: serial@70006000 {
		compatible = "nvidia,tegra210-uart", "nvidia,tegra20-uart";
		reg = <0x0 0x70006000 0x0 0x40>;
		reg-shift = <2>;
		interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
		clocks = <&tegra_car TEGRA210_CLK_UARTA>;
		clock-names = "serial";
		resets = <&tegra_car 6>;
		reset-names = "serial";
		status = "okay";
	};

};
```

#### 5、从零开始

##### ①最小

```c
//arch/arm64/boot/dts/nvidia/yhai.dts  自定义设备树
/dts-v1/;  //设备树文件的版本
#include <dt-bindings/clock/tegra210-car.h>
#include <dt-bindings/interrupt-controller/arm-gic.h>
/ { //根节点名"/" , 节点内容由 { } 包起来 
	model = "NVIDIA Jetson Nano Developer Kit"; //机器名（把板子看成一个设备机器）
	compatible = "nvidia,tegra210"; //兼容性: 厂商(nvidia)+ 设备型号(tegra210) -> 驱动 和设备树节点的查找匹配
	                                
	#address-cells = <2>; //设置子节点"reg"属性的 首地址 占2个单位(1个cell单位，占32位)
	#size-cells = <2>;    //设置子节点"reg"属性的 地址长度 占2个单位
	                      //子节点会继承属性设置， 如果有同名的，则会覆盖（如子节点里有 #size-cells = <0>）
	cpus { //子节点名 "cpus"
		#address-cells = <1>;
		#size-cells = <0>;

		//4核CPU
		cpu@0 { //孙节点名 "cpu@0" (由名字@地址 组成)
			device_type = "cpu"; //节点的设备类型 cpu
			compatible = "arm,cortex-a57";
			reg = <0>;  //节点的首地址为0
		};   

		cpu@1 {
			device_type = "cpu";
			compatible = "arm,cortex-a57";
			reg = <1>;
		};   

		cpu@2 {
			device_type = "cpu";
			compatible = "arm,cortex-a57";
			reg = <2>;
		};

		cpu@3 {
			device_type = "cpu";
			compatible = "arm,cortex-a57";
			reg = <3>;
		};	 
	            
	};  //每个节点结束，或属性的结束，都需加分号   

	memory {
	    device_type = "memory"; //节点的设备类型 为内存
	    reg = <0x0 0x80000000 0x0 0xc0000000>; //节点的首地址为 0x0 0x80000000 ，长度范围为0x0 0xc0000000
	};    
};
```

###### (1)编译

```c
$ cd linux-4.9.307	
$ vim  arch/arm64/boot/dts/nvidia/Makefile /*指定编译文件
添加指定编译文件
dtb-y += yhai.dtb 
*/

$ make dtbs /* 编译生成设备树dtb
 报错：
    yhai.dts:58.2-59.1 syntax error
   arch/arm64/Makefile:123: recipe for target 'dtbs' failed
 答案： 少了分号  
*/
```

###### (2)运行

```shell
# setenv yhai_bootcmd  ext4load mmc 1:1 0x84000000 /home/yhbd/Image \; ext4load mmc 1:1 83100000	  /home/yhbd/linux-4.9.307/arch/arm64/boot/dts/nvidia/yhai.dtb \; ext4load mmc 1:1  0xa0000000 /home/yhbd/ramdisk.img.gz \; booti 0x84000000 - 83100000
# saveneenv
# mw  83100000  0  50    
# run  yhai_bootcmd  //运行无串口输出 （正常，这是最小的基本dts框架，紧编译OK，尚不支持串口）
```

##### ②时钟

```
tegra_car: clock@60006000 { //时钟和复位控制器节点   -> 文档  Documentation/devicetree/bindings/clock/nvidia,tegra210-car.txt
	compatible = "nvidia,tegra210-car";  
	reg = <0x0 0x60006000 0x0 0x1000>; //首地址0x0 0x60006000  见2.1 System Address Map的 Clock and Reset (CAR) 6000:6000
	                                   //长度  0x0 0x1000      = 0xAddress End -  Address Start
	#clock-cells = <1>; //时钟ID号(CLK_OUT_ENB) 占1个单位
	#reset-cells = <1>; //复位ID号( CLK_RST_CONTROLLER_RST_DEVICES_ ) 占1个单位
};
```

##### ③串口

```
uarta: serial@70006000 { //串口节点 -> Documentation/devicetree/bindings/serial/nvidia,tegra20-hsuart.txt
  compatible = "nvidia,tegra210-uart", "nvidia,tegra20-uart"; //兼容匹配的设备列表
  reg = <0x0 0x70006000 0x0 0x40>;  //首地址0x0 0x70006000  见2.1 System Address Map的 UART-A 7000:6000
                     //长度  0x0 0x40      =  Address End -  Address Start
  reg-shift = <2>; 
  interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>; /* 中断源指定
     详见 Documentation/devicetree/bindings/interrupt-controller/arm,gic.txt
    域名(0:spi 1:ppi) + 中断索引(36) + 触发方式(高电平触发）     
    36由来 -> 见 3.2 Interrupt Mapping     Global Interrupt Number
     用3个数描述一个中断，因其父中断控制器里的interrupt-cells 为3
  	     */  
  	                                  
  clocks = <&tegra_car TEGRA210_CLK_UARTA>;    // ctrl+] -> tegra210-car.h  的 CLK_OUT_ENB    ->  5.2.5 CLK_RST_CONTROLLER_CLK_OUT_ENB_L_0 的6号
              // &tegra_car 等价于完整路径 &{/clock@60006000} 
  clock-names = "serial";
  resets = <&tegra_car 6>; // 6  ->   5.2.2 CLK_RST_CONTROLLER_RST_DEVICES_L_0  ->  6  SWR_UARTA_RST: Reset UARTA Controller
  reset-names = "serial";
  status = "okay";  //设备状态  "okay":正在运行  "disabled":禁止状态   "fail":CPU 无法运行或不存在
        //详见 https://github.com/devicetree-org/devicetree-specification/blob/main/source/chapter3-devicenodes.rst
};	
```

###### (1)基础



###### (2)时钟和复位

###### (3)中断

##### ④启动参数

```
chosen {
    bootargs = "earlycon";
    stdout-path = "serial0:115200n8";
};
aliases {
    serial0 = &uarta;
};
```

##### ⑤中断

```c
interrupt-parent = <&lic>;	
	
gic: interrupt-controller@50041000 { //根中断控制器节点
   compatible = "arm,gic-400";
   #interrupt-cells = <3>; //设置子节点的"interrupts"属性 占3个单位
		                       //详见Documentation\devicetree\bindings\interrupt-controller\interrupts.txt
   interrupt-controller; //声明是中断控制器
   reg = <0x0 0x50041000 0x0 0x1000>, //reg属性: 描述了设备资源在其父总线定义的地址空间内的地址,这里是分段描述
	//0x0 0x50041000 表示首地址( -> 2.1 System Address Map -> ARM Interrupt Distributor)
	// 0x0 0x1000表示长度
	 <0x0 0x50042000 0x0 0x2000>, //0x0 0x50042000 表示另一段的起始地址，0x0 0x0100表示长度
	 //reg可以连续写多个，类似数组
	 <0x0 0x50044000 0x0 0x2000>,
	 <0x0 0x50046000 0x0 0x2000>;
   interrupts = <GIC_PPI 9
		(GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>; 
   interrupt-parent = <&gic>;  //声明其父中断控制器是自己 -> 根
};	

lic: interrupt-controller@60004000 { //子中断控制器 (用于启动和电源管理Legacy Interrupt Controller )
    compatible = "nvidia,tegra210-ictlr";
    reg = <0x0 0x60004000 0x0 0x40>, /* primary controller  ->  2.1 System Address Map的  Primary ICTLR ->
 3.2 Interrupt Mapping Table 7: Primary Interrupt Controller (PRI_ICTLR) Mapping*/ 
	  <0x0 0x60004100 0x0 0x40>, /* secondary controller */
	  <0x0 0x60004200 0x0 0x40>, /* tertiary controller */
	  <0x0 0x60004300 0x0 0x40>, /* quaternary controller */
	  <0x0 0x60004400 0x0 0x40>, /* quinary controller */
	  <0x0 0x60004500 0x0 0x40>; /* senary controller */ 
    interrupt-controller;
    #interrupt-cells = <3>;
    interrupt-parent = <&gic>; //声明其父中断控制器是gic(标签的引用)  -> 可形成级联树
};

```

##### ⑥定时器

```
timer {
	compatible = "arm,armv8-timer";
	interrupts = <GIC_PPI 13
			(GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
		     <GIC_PPI 14
			(GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
		     <GIC_PPI 11
			(GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
		     <GIC_PPI 10
			(GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>;
	interrupt-parent = <&gic>;
};
```



##### ⑦电源管理控制

```c
pmc: pmc@7000e400 {
	compatible = "nvidia,tegra210-pmc";
	reg = <0x0 0x7000e400 0x0 0x400>;
};
```

##### ⑧完整版

```
# setenv yhai_bootcmd  ext4load mmc 1:1 0x84000000 /home/yhbd/Image \; ext4load mmc 1:1 83100000	  /home/yhbd/linux-4.9.307/arch/arm64/boot/dts/nvidia/board.dtb \; ext4load mmc 1:1  0xa0000000 /home/yhbd/ramdisk.img.gz \; booti 0x84000000 - 83100000
# run yhai_bootcmd

//linux-4.9.307/arch/arm64/boot/dts/nvidia/Makefile  里添加 dtb-y += board.dtb  编译
```



#### 6、示例借鉴:内核发布的设备树

##### ①阅读工具

```
//编辑用vscode ,阅读跟踪用vim
vscode //安装devicetree 插件
       //ctrl+p  -> vscode搜索文件名	

//折叠控制
$ ctags -R
$ cscope -Rbkq

https://www.jianshu.com/p/16e0b822b682 Vim 折叠	
$ vim ~/.vimrc //在末尾追加 set foldmethod=indent	
zo  //展开本层
zc  //折叠本层
zR  //全部展开
zM  //全部折叠	

ctrl +d  ctrl+ u  //上下翻半页  （因ctrl+f ctrl+b 与vscode 有快捷键冲突）
ctrl + ^   //返回到原目录(或:Rex :b#)
           //ctrl+^ 和vscode有冲突时，可用:Rex代替
-  //返回上级目录 

:Ve -> shift + D  //删除光标处的文件（如.swp)

$ vim ~/.vimrc  /* gf 跳转头文件
在末尾添加头文件的搜索路径
set path +=.,~/kernel-4.9/include/**  
*/
```



##### ②板子描述

```c
//arch/arm64/boot/dts/nvidia/tegra210-smaug.dts  板子描述
/dts-v1/; //设备树的版本

#include <dt-bindings/input/input.h>  //gf 可跳转（如不能需添加头文件搜索路径 如set path +=.,~/kernel-4.9/include/**) 
#include "tegra210.dtsi" //gf可跳转 (dtsi 是提取的通用部分)
                   
/ { //根节点名"/" , 节点内容由 { } 包起来 ,结束时需加分号
    //属性：描述设备信息，分通用属性，和自定义属性，每个属性结束需加分号
    model = "Google Pixel C"; //model属性：指定唯一标识系统板型号的字符串。推荐的格式是“制造商，型号”. 如"NVIDIA Jetson Nano" 
    compatible = "google,smaug-rev8", //compatible属性: 指定与此设备兼容的平台列表 -> 用于 驱动 和设备 查找匹配 
                 "nvidia,tegra210"; //推荐的格式是“制造商，型号”，可多个，按先后逐个优先匹配。
       //必须的#address-cells等属性，它放在dtsi中，编译后会叠加组合在一起。
    aliases {//别名节点:定义了一个或多个别名属性
        serial0 = &uarta; //定义serial0 做uarta标签的别名,
                          //属性值也可直接用节点路径名 如 serial0 = /serial@70006000;
    };

    chosen {//挑选节点: 描述了运行时的参数（不代表真实设备）
    	    //解析见内核源码 early_init_dt_scan_chosen
        bootargs = "earlycon"; //引导参数属性：设为earlycon，表示设为早期串口初始化（即在console_init之前可输出信息)
        stdout-path = "serial0:115200n8";//标准输出路径属性：用serial0做控制台输出的设备，115200n8表示其串口的波特率
  //也可用旧版合一的方式 bootargs = "root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0,115200";
  //注：如u-boot里有设置bootargs，则优先使用u-boot的，其次是设备树的chosen，最后才是内核配置中指定的bootargs
         
    };
    
    memory {//内存节点: 描述物理内存布局(如是多个，可创建多个节点，或多个reg段)
    	    //解析见内核源码 early_init_dt_scan_memory,
        device_type = "memory"; //设备的类型为"memory"
        reg = <0x0 0x80000000 0x0 0xc0000000>; /*
首地址为 0x0 0x80000000  占2个单元 (因父节点 address-cells 设为2)
         长度大小为 0x0 0xc0000000 占2个单元 (因父节点 size-cells 设为2)
        两段内存时 用一个节点，多个reg段方式
         memory@0 {   
	   device_type = "memory";
	   reg = <0x000000000 0x00000000 0x00000000 0x80000000
	         0x000000001 0x00000000 0x00000001 0x00000000>;
	};
	或  多个节点方式
	memory@0 {   
	   device_type = "memory";
	   reg = <0x000000000 0x00000000 0x00000000 0x80000000>;
	};
	memory@100000000 {
	   device_type = "memory";
	   reg = <0x000000001 0x00000000 0x00000001 0x00000000>;
	};          
            
        */                                                                                   
    };

    host1x@50000000 {
        dpaux: dpaux@545c0000 { /*图像显示接口的辅助通道
   DP接口(DisplayPort)是一种图像显示接口,AUX 是辅助通道     	
        	  */
            status = "okay";   //启用dpaux设备
        };
    }
    
    pinmux: pinmux@700008d4 {//板子管脚复用配置（重点：移植关注）
     ...
    }
    
    serial@70006000 {
        status = "okay"; //启动该串口设备
    };
 
     clocks {//时钟源
	compatible = "simple-bus";  //  compatible 为 "simple-bus"，会使其子节点也转换为 platform_device.
	#address-cells = <1>;
	#size-cells = <0>;

         clk32k_in: clock@0 { //设置0号时钟源为：固定的输入时钟源  32.768 KHZ
	   compatible = "fixed-clock";
	   reg = <0>;  //节点id
	   #clock-cells = <0>;
	   clock-frequency = <32768>; //时钟频率设为 32768 HZ
	   };
     };        
};
```

###### (1)设备树叠加

```
//注：解析时，把include导入的多个设备树文件叠加，同名节点不同名属性追加在一起，同名的属性顶层覆盖底层。
//    查看叠加后的设备树 dtc -I dtb -O dts tegra210-smaug.dtb > final.dts   
//   (需 sudo apt-get install device-tree-compiler)   
```



###### (2)必备属性和节点

###### (3)非必备节点

##### ③CPU描述

```c
//arch/arm64/boot/dts/nvidia/tegra210.dtsi   SOC描述
#include <dt-bindings/clock/tegra210-car.h>
#include <dt-bindings/gpio/tegra-gpio.h>

/ {
    compatible = "nvidia,tegra210";
    interrupt-parent = <&lic>; //设置父中断节点是 lic
    #address-cells = <2>;  //设置子节点"reg"属性的 首地址 占2个单元格数 (1个cell单元 有32位)
    #size-cells = <2>; 	   //设置子节点"reg"属性的 长度大小 占2个单元格数
	                         //子节点会继承属性设置， 如果有同名的，则会覆盖
    host1x@50000000 { //主机控制器: 图形 视频和显示的控制器(见手册 的CHAPTER 14: HOST SUBSYSTEM)
        compatible = "nvidia,tegra210-host1x", "simple-bus";
        reg = <0x0 0x50000000 0x0 0x00034000>;
        interrupts = <GIC_SPI 65 IRQ_TYPE_LEVEL_HIGH>, /*中断源属性: 域名(0:spi 1:ppi) + 中断索引+ 触发方式 */
                 <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>; /* general */
        clocks = <&tegra_car TEGRA210_CLK_HOST1X>; //时钟源设置
        clock-names = "host1x";
        resets = <&tegra_car 28>;  //复位源设置
        reset-names = "host1x";

        #address-cells = <2>;
        #size-cells = <2>;
        //ranges属性：父子地址空间的映射转换  <子总线地址， 父总线地址,长度>
        ranges = <0x0 0x54000000 0x0 0x54000000 0x0 0x01000000>; 
        vi@54080000 {//视频输入节点(详见 31.4 VGP (GPIO) Interface)
            compatible = "nvidia,tegra210-vi";
            reg = <0x0 0x54080000 0x0 0x00040000>;  //首地址+ 长度 (详见2.1 System Address Map  的 VI)
            interrupts = <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>;
            status = "disabled"; //禁用状态
        };
        
        vic@54340000 {//视频图像合成器（见CHAPTER 15: VIDEO IMAGE COMPOSITOR (VIC))
            compatible = "nvidia,tegra210-vic";
            reg = <0x0 0x54340000 0x0 0x00040000>;
            status = "disabled";        	
        };
        
        nvdec@54480000 {//视频解码
        };

        nvenc@544c0000 {//视频编码
        };       
        dsi@54400000 {//显示串行接口（见   CHAPTER 26: DISPLAY INTERFACES: MIPI-DSI）-> 接LCD屏
        };         
        dpaux: dpaux@545c0000 { //图像显示接口的辅助通道: DP接口(DisplayPort)是一种图像显示接口,AUX 是辅助通道     	
        };
   }

   gic: interrupt-controller@50041000 { //根中断控制器节点
   };	

   lic: interrupt-controller@60004000 { //子中断控制器 (专用于启动和电源管理Legacy Interrupt Controller )
   };

    gpu@57000000 {//图形处理器
    };
    
    //注： 时钟和定时器的区别，时钟是提供固定的脉冲方波，做参考基准
    //     而定时器是 基于时钟之上，设置计数器，时间到发出中断信号
    timer@60005000 { //定时器(见CHAPTER 8: TIMERS，包含RTC WDT 通用定时器等)
    };
    
		tegra_car: clock@60006000 { //时钟和复位控制器
		};
		    
    flow-controller@60007000 {//流控：硬件电源状态排序
    } 
    apbdma: dma@60020000 {//APB总线的DMA控制器
    }

    gpio: gpio@6000d000 {//GPIO控制器(见 CHAPTER 9)
    	                   //devicetree/bindings/gpio/nvidia,tegra186-gpio.txt
    };
    pinmux: pinmux@700008d4 {//管脚复用(见 CHAPTER 9)
        compatible = "nvidia,tegra210-pinmux";
        reg = <0x0 0x700008d4 0x0 0x29c>, /* Pad control registers */
              <0x0 0x70003000 0x0 0x294>; /* Mux registers */
    };    
    
    
    cpus { //CPU容器节点（不代表真实设备）
        #address-cells = <1>;
        #size-cells = <0>;

        //4核cpu
        cpu@0 {//cpu节点
            device_type = "cpu"; //设备类型为cpu
            compatible = "arm,cortex-a57"; 
            reg = <0>;  //它为CPU节点，定义了唯一id (多核并行是，cpu线程唯一识别id)
        };
    };	  
	                          
    uarta: serial@70006000 {//串口节点
    }; 	
    ....
    pwm: pwm@7000a000 { //pwm脉冲宽度调制
    };    
    
    i2c@7000c000 { //i2c总线（见CHAPTER 35: I2C CONTROLLER）
    	             //Documentation/devicetree/bindings/i2c/nvidia,tegra20-i2c.txt
    };  
    spi@7000d400 {//spi总线
    };    
    rtc@7000e000 {//rtc实时时钟
    }          
           
    pmc: pmc@7000e400 {//电源管理(CHAPTER 12: POWER MANAGEMENT CONTROLLER)
    }
    
    fuse@7000f800 {//用户空间文件系统
    }
    mc: memory-controller@70019000 {//存储控制（接EMC 内存等）
    }
    hda@70030000 {//High-Definition Audio engine
    } 
    
    usb@70090000 { //usb节点
    };    
    padctl: padctl@7009f000 { //xusb的焊盘控制
        usb2{
        }
        pcie {
        }
        sata{
        }
    }        
    
    
    mipi: mipi@700e3000 {//移动工业处理器接口(如 CHAPTER 29: MIPI-CSI (CAMERA SERIAL INTERFACE))      
    };    
    
};
```

###### (1)主机控制器

###### (2)其它设备节点

#### 7、示例借鉴:厂商BSP包中提供的设备树

##### ①移植厂商设备树过来	

```c
$ cd ~/linux-4.9.307/arch/arm64/boot/dts/nvidia	
$ cp ~/bsp/Linux_for_Tegra/source/public/hardware/nvidia/  -rf .   //把厂商bsp的设备树 拷贝过来(方便源码搜索)
$ cd ~/linux-4.9.307
$ vim ~/.vimrc  /* gf 跳转头文件
在末尾添加头文件的搜索路径
set path +=.,~/linux-4.9.307/include/**,~/linux-4.9.307/arch/arm64/boot/dts/nvidia/**
*/

//反向 生成 完整的设备树
$ sudo dtc -I dtb -O dts /sys/firmware/fdt > ~/now.dts  
或
$ cd ~/bsp/Linux_for_Tegra/kernel/dtb
$ dtc -I dtb -O dts tegra210-p3448-0000-p3449-0000-b00.dtb > now.dts

//如何知道 匹配哪个设备树dtb(有多个dtb)？   
$ cat /sys/firmware/devicetree/base/compatible //查看当前系统 使用的设备树的名字
  //nvidia,p3449-0000-b00+p3448-0000-b00nvidia,jetson-nanonvidia,tegra210 
  //内核启动信息,可能有设备树名DTS File Name: hardware/nvidia/platform/t210/porg/kernel-dts/tegra210-p3448-0000-p3449-0000-b00.dts
```

##### ②框架宏观认识

```c
分三层 	//开发板配置
        //板子通用功能
        //SOC通用功能
```

##### ③开发板配置(入口)

```c
//路径： platform/t210/porg/kernel-dts/tegra210-p3448-0000-p3449-0000-b00.dts
#include "tegra210-porg-p3448-common.dtsi" //通用功能
#include "porg-platforms/tegra210-porg-camera-rbpcv3-dual-imx477.dtsi"
#include "porg-platforms/tegra210-porg-camera-rbpcv2-dual-imx219.dtsi" //摄像头控制
#include "porg-platforms/tegra210-porg-pinmux-p3448-0000-b00.dtsi"  //管脚复用
#include "porg-platforms/tegra210-porg-gpio-p3448-0000-b00.dtsi"  //GPIO控制
#include "porg-platforms/tegra210-porg-p3448-emc-a00.dtsi"    
    //external-memory-controller  接内存等（见soc框图emc0 emc1)

/ {
	model = "NVIDIA Jetson Nano Developer Kit";
	compatible = "nvidia,p3449-0000-b00+p3448-0000-b00", "nvidia,jetson-nano", "nvidia,tegra210";
	nvidia,dtsfilename = __FILE__;
}
```

##### ④板子通用功能

```c
//platform/t210/porg/kernel-dts/tegra210-porg-p3448-common.dtsi
/dts-v1/;  //设备树文件的版本
/memreserve/ 0x80000000 0x00020000;  // 指定保留内存0x80000000(起始)  0x00020000(长度)，内核不会使用保留内存

#include <t210-common-platforms/tegra210-common.dtsi>  //soc通用功能
#include <tegra210-soc/tegra210-sdhci.dtsi>  //sd卡和emmc(flash)控制
#include <t210-common-platforms/tegra210-thermal-nct72-p2530.dtsi> //温度控制
#include <tegra210-soc/tegra210-thermal-Tboard-Tdiode.dtsi> 
#include "porg-platforms/tegra210-porg-power-tree-p3448-0000-a00.dtsi" //电源树管理
#include "porg-platforms/tegra210-pinmux-drive-sdmmc-common.dtsi" //驱动sdmmc的管脚配置
#include "porg-platforms/tegra210-porg-pwm-fan.dtsi" //pwm 风扇控制
#include <t210-common-platforms/tegra210-ers-hdmi-e2190-1100-a00.dtsi> //hdmi控制
#include <t210-common-platforms/tegra210-dp.dtsi> //显示口控制
#include <t210-common-platforms/tegra210-thermal-userspace-alert.dtsi>
#include "porg-platforms/tegra210-porg-thermal.dtsi"
#include "porg-platforms/tegra210-porg-thermal-fan-est.dtsi"
#include "porg-platforms/tegra210-porg-keys-p3448-0000-a00.dtsi"
#include <dt-bindings/iio/meter/ina3221x.h>
#include <tegra210-soc/tegra210-audio.dtsi>  /*音频控制（见CHAPTER 23: AUDIO PROCESSING ENGINE）
  APE: 音频处理引擎
  aconnect: 音频的连接总线
       */
#include "porg-platforms/tegra210-porg-cpufreq.dtsi" //cpu频率的控制
#include "porg-platforms/tegra210-porg-powermon-p3448-0000-a00.dtsi"
#include "porg-plugin-manager/tegra210-porg-eeprom-manager.dtsi"
#include "porg-plugin-manager/tegra210-porg-plugin-manager.dtsi"
#include <tegra210-soc/mods-simple-bus.dtsi>  /*simple bus管理  -> 子节点都转换为平台设备
  DT中的simple-bus，可以其所有的子节点都作为platform device注册进kernel。
  默认情况下，of_platform_populate是不会将node中的child nodes注册的。 
  */
#include "porg-platforms/tegra210-porg-extcon-p3448-0000-a00.dtsi"
#include "porg-platforms/tegra210-porg-pcie.dtsi"  /*pcie控制( 见CHAPTER 34: PCI EXPRESS (PCIe) CONTROLLER)
               千兆有线网卡  wifi      
                    */
#include "porg-platforms/tegra210-porg-prods.dtsi" 
#include "porg-platforms/tegra210-porg-super-module-e2614.dtsi"
/{
}
```

##### ⑤SOC通用功能

```c
#include <tegra210-soc/tegra210-soc-shield.dtsi>  //cpu护罩（启动需要节点，保护未启用的）
#include <dt-bindings/interrupt-controller/arm-gic.h>  //arm通用的gic中断控制器
#include <dt-bindings/gpio/tegra-gpio.h> 
#include <tegra210-soc/tegra210-prods.dtsi>
#include <t210-common-platforms/tegra210-platform-common-padvoltage-default.dtsi>
#include <t210-common-platforms/tegra210-ers-touch-e1937-1000-a00.dtsi>
#include <tegra210-soc/tegra210-modem-common.dtsi>
#include <tegra210-soc/tegra210-trusty.dtsi>

{//tegra210-soc-shield.dtsi  cpu护罩-> 启动需要节点，保护未启用的
}
{//tegra210-soc-base.dtsi   CPU基础配置(dtsi：提取出的共性)
}
```

### 七、内核移植下

#### 1、网卡移植

##### ①切入

###### (1)承前√

###### (2)意义

```
根据实际要求移植，原厂是千兆网卡Realtek RTL8168，根据实际需求只需要普通网卡10/100M，因此就需要移植
```

![网卡移植](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\网卡移植.png)

##### ②菜单配置

###### (1)参考

```c
以官方BSP配置或其它内核里的配置或百度搜索

如同网卡或其它网卡配置如dm9000
如百度搜 "Linux r8169 网卡移植" "Linux 千兆网卡移植" 搜不到 则搜 "Linux 网卡移植"
发现最多的是dm9000 的移植，虽然芯片驱动不一样，但上层网络协议，文件系统等配置是可以做参考的。
```

###### (2)从零配置

```c
$ cd linux-4.9.307
$ make menuconfig /*配置
借鉴ok的kernel-4.9里配置
   Device Drivers  --->
发现没有Network device support 选项
原来是需在上级目录，先选择
     [*] Networking support   --->		
	才会有
		
再		
   Device Drivers  --->
	[*] Network device support  --->
	   [*]   Ethernet driver support  --->				
发现没有 "Realtek 8169 gigabit ethernet support" 的菜单选项


看 drivers/net/ethernet/realtek/Kconfig 发现
     depends on PCI 需要依赖于PCI的选项
如何找PCI菜单选项？

.config 里搜PCI  发现
384 #
385 # Bus support
386 #
387 CONFIG_PCI=y
 
对应菜单里     
	Bus support  --->
		[*] PCI support    先只选择它，如果后面网卡有问题，可以参考OK版本把 [ ] PCI Express Port Bus support等选择尽量做一致 
	     
再
  Device Drivers  --->
    [*] Network device support  --->
        [*]   Ethernet driver support  --->         
	      取消其它所有无关驱动的选项，只选中
	      [*]   NVIDIA devices (NEW)    保留，我们用的是英伟达的板子，取消有导致一些功能用不了的风险
	      [*]   Realtek devices (NEW)
	      [*]     Realtek 8169 gigabit ethernet support (NEW)

注：为什么这么麻烦。 
    一是： 采用这种最简依赖方式，能裁剪出最简的内核， 而不是臃肿内核       
    而是： 我不像很多培训做的，只是给最终的答案，而是给出 底层逻辑推导链条。
           这样才不会，给个新的板子或模块，移不来了
	*/
$ make Image -j5
```

###### (3)验证环境准备

```
$ setenv bootargs  root=/dev/nfs rw nfsroot=192.168.9.119:/nfs/rootfs,v3 console=ttyS0,115200 init=/linuxrc ip=192.168.9.9 
$ setenv yh_nfs  pci enum \; pci \; ext4load mmc 1:1 0x84000000 /boot/Image \; ext4load mmc 1:1 83100000 /boot/tegra210-p3448-0002-p3449-0000-b00.dtb \; booti 0x84000000 - 83100000
$ saveenv
$ run  yh_nfs	//启动后，验证，保证用移植号的内核，设备树，是能nfs挂载成功的

//重启改为我们自己移植的内核，来进行验证（只是内核不确定，其它的都是OK的）
$ setenv yh_nfs  pci enum \; pci \; ext4load mmc 1:1 0x84000000 /home/yhbd/Image \; ext4load mmc 1:1 83100000 /boot/tegra210-p3448-0002-p3449-0000-b00.dtb \; booti 0x84000000 - 83100000
$ saveenv
$ run  yh_nfs //发现异常报错

//可对比ramdisk ok的日志看看
$ setenv bootargs initrd=0xa0000000,0x800000 root=/dev/ram0 rw  rootwait rootfstype=ext2 console=ttyS0,115200 init=/linuxrc ip=192.168.9.9  
$ setenv ramdisk_bootcmd  ext4load mmc 1:1 0x84000000 /home/yhbd/Image \; ext4load mmc 1:1 83100000	  /boot/tegra210-p3448-0002-p3449-0000-b00.dtb \; ext4load mmc 1:1  0xa0000000 /home/yhbd/ramdisk.img.gz \; booti 0x84000000 - 83100000
$ run ramdisk_bootcmd
```

##### ③排查思路

```
//一：找线索
百度搜索 //错误信息搜索 如 "VFS: Cannot open root device "nfs" or unknown"
         //描述异常搜索 如 "linux 网卡移植 nfs挂载失败"

参考OK示例  //1.日志对比（对移植成功的日志对比，分析原因)   
            //2.源码对比（看移植成功内核源码里改了那些地方）
 
启动源码分析 //跟踪内核对有线网卡驱动的加载过程，设备树解析过程，
            //看哪个地方卡住了异常。逐个分析             

//二：可能原因	
环境问题    //已替换法测试，不是环境，u-boot参数，设备树的问题
内核问题    //内核配置有问题， 
            //内核源码有问题（如pci部分代码有问题，rtl8169驱动有问题）

//三：排查方法
替换法   //尽量优先用官方OK的镜像，限定范围，错误定位
排序     //按可能性大快速验证的优先排查
排查关键 //关键你如何百分百确认，这个环节没问题
```

###### (1)

###### (2)

##### ④DM9000网卡移植

###### (1)

###### (2)

#### 2、内核版本升级

##### ①版本管理

```
github  //版本控制和协作的代码托管平台	
        //官网： https://github.com/   
        //入门教程：https://docs.github.com/cn/get-started/quickstart/hello-world  	
        //注册登录  用户名:yzglintian@163.com

gitee  //码云：国内的仿造，github的平台，有些github下载慢，可以看看它上面有镜像没

```

###### (1)动因

```
通过英伟达脚本发现下载不了源码仓库

通过git观察英伟达内核，每个版本更新了什么，
$ cd  Linux_for_Tegra/
$ ./source_sync.sh  /*脚本方式,git更新	
SOURCE_INFO="
 63 k:kernel/kernel-4.9:nv-tegra.nvidia.com/linux-4.9.git:
 64 k:kernel/nvgpu:nv-tegra.nvidia.com/linux-nvgpu.git:
 65 k:kernel/nvidia:nv-tegra.nvidia.com/linux-nvidia.git:
 66 k:hardware/nvidia/soc/t18x:nv-tegra.nvidia.com/device/hardware/nvidia/soc/t18x.git:
*/	
采用从脚本里的网址信息，找到git库，再导入到github上自己的库里，再下 //可能需要翻墙
```



###### (2)导入现有仓库

```
Import repository -> Your old repository’s clone URL 下面，输入要导入的源码库  //如 https://nv-tegra.nvidia.com/r/linux-nvidia.git
  -> Repository Name  下填入名字 //如 	linux-nvidia 
  
同理导入  
https://nv-tegra.nvidia.com/r/linux-4.9.git   命名为linux-tegra-4.9  
https://nv-tegra.nvidia.com/r/linux-nvgpu.git  命名为nvgpu
https://nv-tegra.nvidia.com/r/device/hardware/nvidia/soc/t18x.git  命名为hardware/nvidia/soc/t18x

导入官方内核版本  https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/
```



###### (3)下载源码仓库

```shell
$ git clone https://github.com/yzglintian/linux.git	
   //如报错：GnuTLS recv error (-110): The TLS connection was non-properly terminated  
   //解决：git clone --recursive https://github.com/yzglintian/linux.git
$ cd  linux
$ git checkout remotes/origin/linux-4.9.y //切换到指定分支
$ git log  // 搜索4.9.253 查找对应哈希值
$ git branch 4.9.253 8db42574fc93d05e7f1f5fbd88af55f4f69ff586 //为指定版本创建新分支
$ git checkout 4.9.253 //切换到新分支
	
$ git clone https://github.com/yzglintian/linux-tegra-4.9.git
$ linux-tegra-4.9	
$ git branch -a
$ git checkout remotes/origin/l4t/l4t-r32.6.1-4.9	

$ git clone https://github.com/yzglintian/linux-nvidia.git
//打开bcompare  可对比差异  

```

###### (4)查看修改历史(网页版)

```
网页打开 https://github.com/yzglintian/linux-tegra-4.9	
点 代码 下面的 多少次提交 // 可查看项目 历史修改 	（不能搜索关键字，不能一步跳到最后)
打开文件 点 history  //查看文件的历史修改
切换默认分支 // Setttings ->	Branches -> Default branch -> 选linux 4.9  -> update

对比不同版本 //https://github.com/yzglintian/linux/compare/ae62da6ae3f..b53085
	    //在后面添加 compare/版本1哈希值..版本2哈希值
```

###### (5)查看源码修改(命令版)

```c
$ cd  linux-tegra-4.9
$ git branch -a //查看所有的分支 （*号 指向的为当前分支）
$ git checkout remotes/origin/l4t/l4t-r32.6.1 //切换分支

$ git log  //简略查看修改历史
           //  f：下翻页  b:上翻页  q退出
           //  /pci  搜索pci 
$ git log --stat //查看修改历史 ，并显示修改那些文件
$ git log -p -2  //查看最近两次提交的差异内容
$ git log --oneline -3  //显示最近3次的最简信息（仅含简写哈希值，和提交说明
$ git log --pretty=format:"%h - %s: %ad" --grep pci --stat /*
        指定格式显示 “简写哈希值 - 提交说明: 日期”  
	              --grep pci : 仅显示含pci字符串的信息
	              --stat : 显示修改那些文件
	              */    
$ git show 4313f4cf073d  //查看指定哈希值 的修改的内容	              
$ git log -p -2 -- init/main.c //查看指定文件的最近两次的修改	

```

##### ②创建内核版 分支

```c
//基于	4.9.307版本创建的分支（要升级到的)，实现最基本功能，串口有输出内核信息
```

###### (1)创建指定版本的分支

```shell
$ cp -rf  linux linux_now	
$ cd 	linux_now
$ git checkout remotes/origin/linux-4.9.y //切换到指定分支
$ git log  // 搜索4.9.307 查找对应哈希值
$ git branch 4.9.307 1e6730483a6edd8f31becef8df0d0f9e2b258ae3	
$ git checkout 4.9.307
```

###### (2)添加自己的第一个版本

```c
//实现串口有输出内核信息
$ vim Makefile /* 指定ARCH，交叉编译工具链
257 ARCH        ?= arm64
258 CROSS_COMPILE   = aarch64-linux-gnu-
*/	
$ cp ~/.config.ramdisk.ok  .config
$ make menuconfig  //不更改，保存退出，目的是激活.config （否则会不断询问配置）
$ make Image -j4

//提交新版本
$ git status //查看当前状态，有那些文件修改
$ git diff    //查看当前没有add 的内容修改
            //git diff  版本1哈希值 版本2哈希值    对比两个版本的差异
            //git diff  2da595c daea1d6 --name-only    仅 对比两个版本 差异的文件列表         
$ git config --global user.email "yzglintian@163.com"
$ git config --global user.name "yzglintian"

$ git add . //添加到暂存区，才能commit提交               
$ git commit -m "uart can output linux version "  //提交内容
          //$ git checkout .  可撤销未commit提交的内容
$ git log //查看版本日志
$ git status

```

###### (3)对比差异

```c
//打开bcompare  对比linux_now 和 linux-tegra-4.9	差异  
点 Filters -> Exclude file  -> 输入 *.o  *.cmd *.mod.c   //过滤到无关文件
              Exclude folders  -> .git  //过滤无关的文件夹    
```

##### ③创建BSP版 分支

```shell
$ cd 	linux_now
$ git log  // 搜索4.9.253 的哈希值
$ git checkout 8db42574fc93  //切换到指定哈希值的 版本
$ git checkout -b jetson_nano //创建并切换到新分支（是基于当前的4.9.253的版本创建的）
```

###### (1)并入BSP内容的版本

```
//用bcompare 把linux-tegra-4.9 把内容有选择并入 
 左面选linux_now   右面 linux-tegra-4.9    // 是把右面，有选择并入左面（尽量只并入与英伟达有关内容）
                   //注意：.git 目录不能动 ，还有文件有更改要点Refresh 刷新
 ctrl+a  -> 选compare contents -> 对比完后，点Diffs
 arch/arm64  右键  点copy to left 
 arch/Kconfig  右键  点copy to left
 除了arch目录外，其它文件以此类推  
  
//撤销更改用  git checkout  .
```



###### (2)验证后提交新版本

```c
//编译源码
$ vim Makefile /*直接指定ARCH  CROSS_COMPILE （写死的）
#ARCH           ?= $(SUBARCH)
ARCH            = arm64
#CROSS_COMPILE  ?= $(CONFIG_CROSS_COMPILE:"%"=%)
CROSS_COMPILE   = aarch64-linux-gnu-
*/
$ export LOCALVERSION=-tegra //导入配置前需设置它，
    //否则后面安装 modules_install后, rootfs/lib/modules下不是4.9.253-tegra 而是4.9.253，
    //导致内核模块.ko 都不能加载, 启动后用lsmod可查看是空的
$ make tegra_defconfig  /*
 报错： drivers/net/ethernet/nvidia/Kconfig:30: can't open file "drivers/net/ethernet/nvidia/eqos/Kconfig"
 原因：是英伟达把部分 驱动代码独立出来了
 解决： 
 $  cd ..
 $  git clone https://github.com/yzglintian/linux-nvidia.git
 $  ln -s linux-nvidia/ nvidia 
 再编译即可
 */
$ make menuconfig  
$ make  -j4
//传到板子上运行 验证

//验证后提交正式
$ git commit -m "to linux-tegra-4.9.253"  //提交内容（只是本地提交，远程服务器端 源码仓库并未改变）
$ git log

```



###### (3)提交异常



##### ④分支合并

###### (1)选择分支并入

```shell
$ git branch /*查看当前的分支
  4.9.253
  4.9.307
* jetson_nano   这是当前的分支
  linux-2.6.11.y
  master
  */
$ git merge 4.9.307  //把4.9.307分支内容，并入当前分支
         //$ git reset --hard HEAD  //恢复到merge前的状态
```

###### (2)冲突解决

```
//解决冲突(用bycompare解决git merge冲突内容)	
$ git config --global diff.tool bc3 	
$ git config --global merge.tool bc3   //将bc设置为默认mergetool
$ git config --global mergetool.bc3 trustExitCode true   //设置退出bc时完成merge	
$ git diff /*查看冲突的内容
diff --cc arch/arm64/include/asm/futex.h
index e69df2816ae4,bdf5ec2b8356..000000000000
--- a/arch/arm64/include/asm/futex.h
+++ b/arch/arm64/include/asm/futex.h
@@@ -21,12 -21,20 +21,19 @@@
  #include <linux/futex.h>
  #include <linux/uaccess.h>
  
 -#include <asm/alternative.h>
 -#include <asm/cpufeature.h>
  #include <asm/errno.h>
 -#include <asm/sysreg.h>
  
+ #define FUTEX_MAX_LOOPS       
+ 
  #define __futex_atomic_op(insn, ret, oldval, uaddr, tmp, oparg)            \
  do {                                                                  \
++<<<<<<< HEAD
当前分支添加的内容
 +      uaccess_enable();                                               \
++=======
待并入分支的内容
+       unsigned int loops = FUTEX_MAX_LOOPS;                           \
+                                                                       \
++>>>>>>> 4.9.307
        asm volatile(  ) 
  }  

*/
$ git mergetool  //会启动bycompare软件，会循环逐个对比
         //中间窗口是源头版本，  如4.9.253  
         //左窗口是当前的分支    如tegra 4.9.253  它是BSP版本(英伟达基于4.9.253修改的用于r32.6.1版本的bsp包)
         //右窗口时远方的分支    如4.9.307    它是内核版本( 内核官方发布的新的内核版本，基于4.9.253发展而来） 
       
     //注：如果不确定用哪个，用BSP版本，因要优先保证能在板子上运行,但可能导致编译错误，需反复调整   
         点  Left  -> 关闭 -> yes  //选择左侧的bsp版本
    

```



###### (3)查看历史修改

```c
//当有冲突时，看git上该文件的历史修改，确定合并哪一个的
https://github.com/yzglintian/linux-tegra-4.9/commits/l4t/l4t-r32.6.1-4.9/arch/arm64/include/asm/futex.h
	点history
	

注 //分支合并 是难点，很容易出问题，最好和功能发布者一起进行合并
```

#### 3、有串口输出

```shell
$ tar -xvf linux-4.9.253.tar.gz
$ cd linux-4.9.253
$ patch -Np1 < ../linux-tegra-final.patch  //打上厂商的BSP补丁
     注意补丁包 在 云盘 嵌入式AI班资料的9.系统移植里
$ vim Makefile /*直接指定ARCH  CROSS_COMPILE （写死的）
#ARCH           ?= $(SUBARCH)
ARCH            = arm64
#CROSS_COMPILE  ?= $(CONFIG_CROSS_COMPILE:"%"=%)
CROSS_COMPILE   = aarch64-linux-gnu-
在板子上直接编译可不指定  CROSS_COMPILE ,因gcc 本来就是arm64的
*/

$ make tegra_defconfig  //导入官方配置

$ make Image -j5 //只编译内核

$ make dtbs //编译生成设备树

$ ln -s  arch/arm64/boot/dts/nvidia_bsp/platform/t210/porg/kernel-dts  dts

$ scp arch/arm64/boot/dts/yhai.dtb   yhbd@192.168.10.237:/home/yhbd/
$ scp arch/arm64/boot/Image   yhbd@192.168.10.237:/home/yhbd/

# setenv out_bootcmd  ext4load mmc 1:1 0x84000000 /home/yhbd/Image \; ext4load mmc 1:1 83100000	/home/yhbd/yhai.dtb \; booti 0x84000000 - 83100000
# run  out_bootcmd //能成功看到内核信息输出
                   //后面发现会复位正常的，因后面还没移植
```



##### ①编译报错问题解决

```
编译报错：fatal error: ../../../nvidia/include/trace/events/nvhost_pva.h: No such file or directory
解决： 需建立软链接
   $ cd ..
   $ ln -s  linux-4.9.253/vender/nvidia/  .
   再编译即可解决
```



#### 4、支持RAMDISK

```shell
$ make menuconfig /*内核菜单配置
  General setup 
   [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support
   
  Device Driver 
   [*] Block devices
      <*>   RAM block device support   
      (16)    Default number of RAM disks 
      (8192)  Default RAM disk size (kbytes)	
  */
$ make Image -j5 //只编译内核
$ scp arch/arm64/boot/Image   yhbd@192.168.10.237:/home/yhbd/ 
      
# setenv bootargs initrd=0xa0000000,0x800000 root=/dev/ram0 rw  rootwait rootfstype=ext2 console=ttyS0,115200 init=/linuxrc ip=192.168.9.9  

# setenv ramdisk_bootcmd  ext4load mmc 1:1 0x84000000 /home/yhbd/Image \; ext4load mmc 1:1 83100000 /home/yhbd/yhai.dtb \; ext4load mmc 1:1  0xa0000000 /home/yhbd/ramdisk.img.gz \; booti 0x84000000 - 83100000


# run  ramdisk_bootcmd //成功(如果 最后网络等很久，原因时ramdisk里启动脚本 /sbin/ifconfig eth0 192.168.9.18 会设置有些网卡，而网卡还不支持)
   
```

##### ①验证1



##### ②验证2

##### ③补录：内核中途异常复位

```
报错  //error reading nvidia,ddc-i2c-bus node  内核启动到中途异常中途复位	

需在设备树 //arch/arm64/boot/dts/nvidia_bsp/platform/t210/common/kernel-dts/t210-common-platforms/tegra210-ers-hdmi-e2190-1100-a00.dtsi
      //添加     nvidia,ddc-i2c-bus = <&i2c4>;     后面讲hdmi时会提到原因

另需配置
  File systems  ---> 
    <*> The Extended 3 (ext3) filesystem 
    -*- The Extended 4 (ext4) filesystem
    [*]   Use ext4 for ext2 file systems 
    [*]   Ext4 POSIX Access Control Lists 
    [*]   Ext4 Security Labels	
```



#### 5、有线网卡移植

##### ①PCIE架构概述

##### ②内核菜单配置

##### ③设备树设置



##### ④验证测试

#### 6、SD卡移植

##### ①内核菜单配置

##### ②设备树设置

##### ③驱动

##### ④验证测试

#### 7、无线网卡移植

##### ①内核菜单配置

##### ②设备树设置

##### ③驱动

##### ④验证测试

#### 8、HDMI移植

##### ①内核菜单配置

##### ②设备树设置

##### ③验证测试

## 肆、驱动初级

### 一、内核模块

#### 1、内核驱动意义

![内核驱动的意义](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\内核驱动的意义.png)

##### ①Linux内核驱动值得学吗

##### ②如何学Linux内核驱动，核心关键在那

##### ③Linux内核驱动课程设计初衷

#### 2、宏内核 VS 微内核

![宏内核和微内核](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\宏内核和微内核.png)

#### 3、用内核模块的意义

![内核模块的意义](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\内核模块的意义.png)

#### 4、编辑阅读源码工具SourceInsight

#### 5、内核三要素

```c
//led.c
#include <linux/kernel.h>
#include <linux/module.h>


static int led_init(void)
{
    printk("led init yhai 1\n");
    return 0;
}

static void led_exit(void)
{
    printk("led exit\n");
}

module_init(led_init); //模块加载入口声明
module_exit(led_exit); //模块卸载入口声明
MODULE_LICENSE("GPL"); //模块免费开源声明
MODULE_AUTHOR("chendu yhai"); //模块作者声明(可选)
```

##### Makefile

```shell
//Makefile
ifeq ($(KERNELRELEASE),)
KERNELDIR ?= ~/linux 
PWD := $(shell pwd)

all:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules

clean:
	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions Module* modules* a.out 

else
    obj-m := led.o
endif
```

#### 6、共享文件

#### 7、NFS测试环境

```shell
# setenv bootargs  root=/dev/nfs rw nfsroot=192.168.9.119:/nfs/rootfs,v3 console=ttyS0,115200 init=/linuxrc ip=192.168.9.9
# setenv nfsboot ext4load mmc 1:1 0x84000000 /boot/Image \; ext4load mmc 1:1 83100000 /boot/tegra210-p3448-0002-p3449-0000-b00.dtb \; booti 0x84000000 - 83100000
# pri bootcmd /*备份原来的，方便恢复
   bootcmd=run distro_bootcmd
    */
# set bootcmd run nfsboot  
# saveenv
# run nfsboot  //能nfs挂载成功	
```

#### 8、验证测试

```shell
$ make              //编译生成 模块文件 led.ko
$ file led.ko       //查看一下格式，看编译的是 电脑的， 还是板子的（ARM)

# insmod led.ko     /*加载模块 
提示： loading out-of-tree module taints kernel    -> 提示内核污染，出问题时你自己驱动的问题，不是内核的问题。方便内核开放者排查 
可添加   MODULE_INFO(intree, "Y"); 去除提示，但最好别这样做                
                     */
# lsmod  /*查看已加载模块列表 -> 检测是否已加载
		等效于 cat /proc/modules
     */
# rmmod  led         //卸载模块     
  
# dmesg      //查看内核日志
```

### 二、字符设备

#### 1、基本概念

##### ①设备驱动的分类

![设备驱动的分类](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\设备驱动的分类.png)

##### ②设备驱动框架

![设备驱动的框架](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\设备驱动的框架.png)

##### ③一切皆文件

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char **argv)
{
	int fd;
	char buff[]=" let's go\n";

	fd = open("/home/yhai/log", O_RDWR);
	if (fd < 0) {
		perror("open");
		exit(1);
	}

	write (fd, buff, sizeof(buff));
	memset(buff,'\0',sizeof(buff));
	close(fd);

	fd = open("/home/yhai/log", O_RDWR);
	if (fd < 0) {
		perror("open");
		exit(1);
	}
	read (fd, buff, sizeof(buff) - 1);
	printf("read buf is %s\n",buff);
	close(fd);

	return 0;
}


$ gcc main.c
$ ./a.out  //成功可看到信息	 read buf is  let's go
```



##### ④字符设备框架的由来

#### 2、注册设备号

```c
//led.c
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/fs.h>	  //for MKDEV register_chrdev_region

#define LED_MA 500  //主设备号 用于区分不同种类的设备  
                    //某些主设备号已经静态地分配给了大部分公用设备。见Documentation/devices.txt 。 
#define LED_MI 0   //次设备号 用于区分同一类型的多个设备
#define LED_NUM 1  //有多少个设备


static int led_init(void)
{
	dev_t devno = MKDEV(LED_MA, LED_MI); 
	int ret;

	ret = register_chrdev_region(devno, LED_NUM, "yhai_led");   /*注册字符设备号(静态分配)
	   为一个字符驱动获取一个或多个设备编号
	   dev_id:       分配的起始设备编号(常常是0）
	   DEVICE_NUM：  请求的连续设备编号的总数(不能太大，避免别的主设备号冲突)
	   DEVICE_NAME： 是应当连接到这个编号范围的设备的名字 
	   alloc_chrdev_region  可进行动态分配                                           
                                                    */
	if (ret < 0) {
		printk("register_chrdev_region\n");
		return ret;
	}

	printk("led init\n");

	return 0; //返回值  0:成功   负值:失败
}

static void led_exit(void)
{
	dev_t devno = MKDEV(LED_MA, LED_MI);
	unregister_chrdev_region(devno, LED_NUM);  //取消注册
	printk("led exit\n");
}

module_init(led_init); //模块加载入口声明
module_exit(led_exit); //模块卸载入口声明
MODULE_LICENSE("GPL"); //模块免费开源声明
```

```c
//验证测试
insmod led.ko
cat /proc/devices //有yhai_led 表示该注册成功
```



##### 主设备号

#### 3、初始化字符设备

```c
//led.c
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/fs.h>	  //for MKDEV register_chrdev_region
#include <linux/cdev.h>  //字符设备头文件

#define LED_MA 500  //主设备号 用于区分不同种类的设备  
                    //某些主设备号已经静态地分配给了大部分公用设备。见Documentation/devices.txt 。
#define LED_MI 0   //次设备号 用于区分同一类型的多个设备
#define LED_NUM 1  //有多少个设备


struct cdev cdev; //定义字符设备

static int  led_open(struct inode *inode, struct file *file)
{
  printk("driver led  open\n");
  return 0;
}
	
static int  led_release(struct inode *inode, struct file *file)
{
  printk("driver led  close\n");
  return 0;
}

struct file_operations  led_fops = { //文件操作(一切皆文件)
	.owner = THIS_MODULE,
	.open =  led_open,
	.release =  led_release,
};

static int led_init(void)
{
	dev_t devno = MKDEV(LED_MA, LED_MI); 
	int ret;

	ret = register_chrdev_region(devno, LED_NUM, "yhai_led");   /*注册字符设备号(静态分配)
		    为一个字符驱动获取一个或多个设备编号
		    dev_id:       分配的起始设备编号(常常是0）
		    DEVICE_NUM：  请求的连续设备编号的总数(不能太大，避免别的主设备号冲突)
		    DEVICE_NAME： 是应当连接到这个编号范围的设备的名字 
		    alloc_chrdev_region  可进行动态分配                                           
                                                    */
	if (ret < 0) { //要进行异常判断
		printk("register_chrdev_region\n");
		return ret;
	}

	cdev_init(&cdev, & led_fops);//字符设备初始化
	ret = cdev_add(&cdev, devno, LED_NUM); //添加字符设备到系统中
	if (ret < 0) {
		printk("cdev_add\n");
		return ret;
	}

	printk("led init\n");

	return 0; //返回值  0:成功   负值:失败
}

static void led_exit(void)
{
	dev_t devno = MKDEV(LED_MA, LED_MI);
	unregister_chrdev_region(devno, LED_NUM);  //取消注册
	printk("led exit\n");
}

module_init(led_init); //模块加载入口声明
module_exit(led_exit); //模块卸载入口声明
MODULE_LICENSE("GPL"); //模块免费开源声明
```

##### ①应用程序

```c
//app.c  
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/ioctl.h>


int main(int argc, char **argv)
{
	int fd;

	fd = open("/dev/led", O_RDWR);
	if (fd < 0) {
		perror("open");
		exit(1);
	}
	printf("open led ok\n");  //注意要加\n 否则打印信息可能没有

	return 0;
}		
```



##### ②验证测试

```
$ make
$ aarch64-linux-gnu-gcc app.c  //编译应用程序，生成a.out
$ cp led.ko a.out /nfs/rootfs

# mknod /dev/led c 500 0  //创建设备文件，应用才能访问它. ( ls -l /dev 可以看到很多其它设备文件) 
#./a.out  //运行 成功可看到  open led ok   
```

#### 4、实现定制文件操作

```
#include <linux/kernel.h>
#include <linux/module.h>  //模块的头文件 (for module_init MODULE_LICENSE)
#include <linux/fs.h>	  //for MKDEV register_chrdev_region
#include <linux/cdev.h>  //字符设备头文件

#include <asm/io.h>   //io操作的头文件(for  ioremap readl)


#define LED_MA 500  //主设备号 用于区分不同种类的设备  
                    //某些主设备号已经静态地分配给了大部分公用设备。见Documentation/devices.txt 。
#define LED_MI 0   //次设备号 用于区分同一类型的多个设备
#define LED_NUM 1  //有多少个设备

struct cdev cdev; //定义字符设备


#define LED_MAGIC 'L'   //幻数：0~0xff的数。用于区分不同的驱动, 见Documentation/ioctl/ioctl-number.txt
#define LED_ON	_IOW(LED_MAGIC, 0, int)   //加幻数方式来定义命令，防止不同驱动间命令错乱
#define LED_OFF	_IOW(LED_MAGIC, 1, int)

#define GPIO3  	0x6000D200 //第3个Bank GPIO 的基地址 (GPIO3_PJ.07)
#define CNF	0x04  //配置寄存器 (0:GPIO  1:SFIO)  偏移量
#define OE   	0x14  //输出使能寄存器 (1:使能 0:关闭)
#define OUT  	0x24  //输出寄存器（1：高电平 0：低电平）
#define MSK_CNF 0x84  //配置屏蔽寄存器(高位1:屏蔽 高位0:不屏蔽   低位1:GPIO模式 低位0:SFIO模式)
#define MSK_OE   0x94  //输出使能屏蔽寄存器(高位1:禁止写   低位1:使能)
#define MSK_OUT 0xA4  //输出屏蔽寄存器(高位1:禁止写   低位1:高电平)
#define  PINMUX_AUX_DAP4_SCLK_0  0x70003150   //管脚复用设置

unsigned char *gpio_base;
unsigned char *gpio_pinmux;


//查看相关寄存器的内容->方便查BUG
void show_reg(void)
{
	printk(" cnf =%x\n",readl(gpio_base+CNF)); //通过基地址加偏移量，来访问对应的配置寄存器
	printk(" oe =%x\n",readl(gpio_base+OE));
	printk(" out =%x\n",readl(gpio_base+OUT));
	printk("mask cnf =%x\n",readl(gpio_base+MSK_CNF));
	printk("mask oe =%x\n",readl(gpio_base+MSK_OE));
	printk("mask out =%x\n",readl(gpio_base+MSK_OUT));
	printk("gpio_pinmux  =%x\n",readl(gpio_pinmux));
}

static int  led_open(struct inode *inode, struct file *file)
{
	printk("driver led  open ok\n");
	show_reg();
	return 0;
}
	
static int  led_release(struct inode *inode, struct file *file)
{
 	printk("driver led  close ok\n");
	show_reg();
	return 0;
}

//开灯
void led_on(void)
{
  	writel(readl(gpio_base+OUT) | 1 << 7, gpio_base+OUT); //引脚输出高电平，点亮灯
	printk("out put high ,led on 输出高电平，点亮灯\n");
}

//关灯
void led_off(void)
{
  	writel(readl(gpio_base+OUT) & ~(1 << 7), gpio_base+OUT);  //引脚输出低电平，灭灯
	printk("out put low, led off 输出低电平，灭灯\n");
}


//ioctl 用于定制操作				
static long  led_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	switch (cmd) {
	case LED_ON:
		led_on();
		break;
	case LED_OFF:
               led_off();
		break;
	default: //异常处理
		printk("no found this cmd =%d",cmd);
		return -1;
	}

	return 0;
}

//3.实现需要的文件操作
// file_operations 中 定义了针对文件的一系列操作方法   不是每个都需实现	
struct file_operations  led_fops = { //文件操作(一切皆文件)
	.owner = THIS_MODULE,
	.open =  led_open,
	.release =  led_release,
	.unlocked_ioctl =  led_ioctl,
};

static int led_init(void)
{
	dev_t devno = MKDEV(LED_MA, LED_MI); 
	int ret;

       //1.注册设备号
	ret = register_chrdev_region(devno, LED_NUM, "yhai_led");   /*注册字符设备号(静态分配)
		    为一个字符驱动获取一个或多个设备编号
		    dev_id:       分配的起始设备编号(常常是0）
		    DEVICE_NUM：  请求的连续设备编号的总数(不能太大，避免别的主设备号冲突)
		    DEVICE_NAME： 是应当连接到这个编号范围的设备的名字 
		    alloc_chrdev_region  可进行动态分配                                           
                                                    */
	if (ret < 0) { //要进行异常判断
		printk("register_chrdev_region\n");
		return ret;
	}

       //2.初始化字符设备
	cdev_init(&cdev, & led_fops);//字符设备初始化
	ret = cdev_add(&cdev, devno, LED_NUM); //添加字符设备到系统中
	if (ret < 0) {
		printk("cdev_add\n");
		goto err1;
	}

      //硬件初始化(成功可看到灯亮)
      //a.管脚复用的设置，设置做GPIO功能
	gpio_pinmux = ioremap(PINMUX_AUX_DAP4_SCLK_0, 8);  /*从物理地址PINMUX_AUX_DAP4_SCLK_0开始，映射 8字节长度的空间到内核空间
	       动态映射 物理地址 到内核虚拟地址
		 phys_addr  起始物理地址
		 size       映射范围大小，单位字节
		返回值     映射后的内核虚拟地址 
		*/	
	if (gpio_pinmux == NULL) {
		printk("ioremap gpio_pinmux error\n");
		goto err3;
	}
  	writel((readl(gpio_pinmux) & ~(1 << 4))|1, gpio_pinmux); /*管脚复用配置用于 GPIO
                  1:0 I2S4B    PM: 0 = I2S4B 1 = RSVD1 2 = RSVD2  3 = RSVD3 
                  设为非0，表示不用作I2S功能，则默认用做GPIO功能

                  4 TRISTATE TRISTATE:   0 = PASSTHROUGH  1 = TRISTATE
                  设为0，设为直通状态才能驱动外面的设备

              见 9.5.1 Per Pad Options
     Tristate     高阻态 -> 与外界是断开的，默认启动设为高阻太，避免驱动影响外面的设备             
     passthrough  直通态 -> 才能驱动外面设备   
	       */

	//b. 做GPIO功能时的内部配置
	gpio_base = ioremap(GPIO3, 0xFF); 
	if (gpio_base == NULL) {
		printk("ioremap gpio_base error\n");
		goto err2;
	}

	writel(readl(gpio_base+CNF) | 1 << 7, gpio_base+CNF);   //配置引脚GPIO3_PJ.07 为 GPIO模式
	writel(readl(gpio_base+OE) | 1 << 7, gpio_base+OE);	//使能引脚(7号)
        writel(readl(gpio_base+OUT) | 1 << 7, gpio_base+OUT); //输出高电平，点亮灯
	writel(readl(gpio_base+MSK_CNF) | 1 << 7, gpio_base+MSK_CNF); //取消对GPIO模下引脚的屏蔽
	writel(readl(gpio_base+MSK_OE) | 1 << 7, gpio_base+MSK_OE);  //取消引脚 使能屏蔽

       
	printk("led init ok\n");
	return 0; //返回值  0:成功   负值:失败

	//goto 出错处理， 顺序申请，逆序释放，避免资源回收不完全（如内存泄露）
err3:
	iounmap(gpio_base);
err2:
	cdev_del(&cdev);
err1:
	unregister_chrdev_region(devno, LED_NUM);
	return ret;
}

static void led_exit(void)
{
      //要配对释放资源,逆序释放资源
	dev_t devno = MKDEV(LED_MA, LED_MI);
	iounmap(gpio_base); //取消映射 
	iounmap(gpio_pinmux); 
	cdev_del(&cdev);  //从系统中移除该设备
	unregister_chrdev_region(devno, LED_NUM);  //取消注册
	printk("led exit ok\n");
}

module_init(led_init); //模块加载入口声明
module_exit(led_exit); //模块卸载入口声明
MODULE_LICENSE("GPL"); //模块免费开源声明

```

##### ①应用程序

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/ioctl.h>

#define LED_MAGIC 'L'  //幻数

#define LED_ON	_IOW(LED_MAGIC, 0, int)   //用幻数加密控制命令
#define LED_OFF	_IOW(LED_MAGIC, 1, int)

int main(int argc, char **argv)
{
	int fd;

	fd = open("/dev/led", O_RDWR);  //打开设备文件
	if (fd < 0) {
		perror("open");
		exit(1);
	}

	while(1)
	{
		ioctl(fd, LED_ON);  //发送控制命令 LED_ON
		usleep(100000);
		ioctl(fd, LED_OFF); //发送控制命令 LED_OFF
		usleep(100000);
	}

	return 0;
}
```



##### ②验证测试

```
$ make
$ aarch64-linux-gnu-gcc app.c  //编译应用程序，生成a.out
$ cp led.ko a.out /nfs/rootfs
# insmod led.ko
# mknod /dev/led c 500 0  //创建设备文件
#./a.out  //运行 成功可看到  灯闪烁
```



##### ③定制操作命令

```c
#define LED_MAGIC 'L'   //幻数：0~0xff的数。用于区分不同的驱动, 见Documentation/ioctl/ioctl-number.txt
#define LED_ON	_IOW(LED_MAGIC, 0, int)   //加幻数方式来定义命令，防止不同驱动间命令错乱
#define LED_OFF	_IOW(LED_MAGIC, 1, int)

//ioctl 用于定制操作				
static long  led_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	switch (cmd) {
	case LED_ON:
		led_on();
		break;
	case LED_OFF:
                led_off();
		break;
	default: //异常处理
		printk("no found this cmd =%d",cmd);
		return -1;
	}

	return 0;
}

struct file_operations  led_fops = { //文件操作(一切皆文件)
	.unlocked_ioctl =  led_ioctl,
};	
```

##### ④硬件控制

```c
//电路连接
地线   //接 40pin 接口的40脚 gnd	
控制线 //接 40pin 接口的12脚   ->  管脚转换表 -> 电路图 -> 芯片手册 	

#define GPIO3  	0x6000D200 // 第3个Bank GPIO 的基地址
#define CNF     0x04  //配置寄存器 (0:GPIO  1:SFIO)  偏移量
#define OE   	0x14  //输出使能寄存器 (1:使能 0:关闭)
#define OUT  	0x24  //输出寄存器（1：高电平 0：低电平）
#define MSK_CNF 0x84  //配置屏蔽寄存器(高位1:屏蔽 高位0:不屏蔽   低位1:GPIO模式 低位0:SFIO模式)
#define MSK_OE  0x94  //输出使能屏蔽寄存器(高位1:禁止写   低位1:使能)
#define MSK_OUT 0xA4  //输出屏蔽寄存器(高位1:禁止写   低位1:高电平)
#define  PINMUX_AUX_DAP4_SCLK_0  0x70003150   //管脚复用设置

unsigned char *gpio_base;
unsigned char *gpio_pinmux;

//开灯
void led_on(void)
{
        writel(readl(gpio_base+OUT) | 1 << 7, gpio_base+OUT); //引脚输出高电平，点亮灯
	printk("out put high ,led on 输出高电平，点亮灯\n");
}

//关灯
void led_off(void)
{
        writel(readl(gpio_base+OUT) & ~(1 << 7), gpio_base+OUT);  //引脚输出低电平，灭灯
	printk("out put low, led off 输出低电平，灭灯\n");
}

static int led_init(void)
{
     //硬件初始化(成功可看到灯亮)
     //a.管脚复用的设置，设置做GPIO功能
     gpio_pinmux = ioremap(PINMUX_AUX_DAP4_SCLK_0, 8);  /*从物理地址PINMUX_AUX_DAP4_SCLK_0开始，映射 8字节长度的空间到内核空间
    动态映射 物理地址 到内核虚拟地址
	phys_addr  起始物理地址
	size       映射范围大小，单位字节
		返回值     映射后的内核虚拟地址 
	*/	
    if (gpio_pinmux == NULL) {
	printk("ioremap gpio_pinmux error\n");
	goto err3;
    }
    writel((readl(gpio_pinmux) & ~(1 << 4))|1, gpio_pinmux); /*管脚复用配置用于 GPIO
        1:0 I2S4B    PM: 0 = I2S4B 1 = RSVD1 2 = RSVD2  3 = RSVD3 
        设为非0，表示不用作I2S功能，则默认用做GPIO功能

        4 TRISTATE TRISTATE:   0 = PASSTHROUGH  1 = TRISTATE
        设为0，设为直通状态才能驱动外面的设备

        见 9.5.1 Per Pad Options
     Tristate     高阻态 -> 与外界是断开的，默认启动设为高阻太，避免驱动影响外面的设备             
     passthrough  直通态 -> 才能驱动外面设备   
	*/

    //b. 做GPIO功能时的内部配置
    gpio_base = ioremap(GPIO3, 0xFF); 
    if (gpio_base == NULL) {
	printk("ioremap gpio_base error\n");
	goto err2;
    }

    writel(readl(gpio_base+CNF) | 1 << 7, gpio_base+CNF);   //配置引脚GPIO3_PJ.07 为 GPIO模式
    writel(readl(gpio_base+OE) | 1 << 7, gpio_base+OE);	  //使能引脚(7号)
    writel(readl(gpio_base+OUT) | 1 << 7, gpio_base+OUT); //输出高电平，点亮灯
    writel(readl(gpio_base+MSK_CNF) | 1 << 7, gpio_base+MSK_CNF); //取消对GPIO模下引脚的屏蔽
    writel(readl(gpio_base+MSK_OE) | 1 << 7, gpio_base+MSK_OE);  //取消引脚 使能屏蔽

}
```

##### ⑤顺序申请，逆序释放

```c
static int led_init(void)
{
	ret = cdev_add(&cdev, devno, LED_NUM);
	if (ret < 0) {
		printk("cdev_add\n");
		goto err1;
	}

	gpio_base = ioremap(GPIO3, 0xFF); 
	if (gpio_base == NULL) {
		printk("ioremap gpio_base error\n");
		goto err2;
	}
	gpio_pinmux = ioremap(PINMUX_AUX_DAP4_SCLK_0, 8);
	if (gpio_pinmux == NULL) {
		printk("ioremap gpio_pinmux error\n");
		goto err3;
	}
	
err3:
	iounmap(gpio_base);
err2:
	cdev_del(&cdev);
err1:
	unregister_chrdev_region(devno, LED_NUM);
	return ret;
}

```



##### ⑥小总结



##### ⑦挑战

#### 5、实现读写文件操作

##### ①应用程序

```
//app.c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <string.h>

int main(int argc, char **argv)
{
	int fd;
	char buff[]=" let's go ";

	fd = open("/dev/led", O_RDWR);
	if (fd < 0) {
		perror("open");
		exit(1);
	}

	write (fd, buff, sizeof(buff));
	memset(buff,'\0',sizeof(buff));
	read (fd, buff, sizeof(buff) - 1);
	printf("read buf is %s\n",buff);

	return 0;
}
```



##### ②驱动程序添加

```c
//led.c
#include <asm/uaccess.h>  //for read write

#define C_BUF_LEN 64
char c_buf[C_BUF_LEN];

//返回值  正数：成功写入的字节数  负值：错误码  0:无数据成功写入
static ssize_t led_write (struct file *file, const char __user *buf, //file: 文件指针  buf:用户空间的缓冲区
		  size_t count, loff_t *  f_pos)  //count: 数据长度 f_pos: 文件位置
{
  ssize_t ret = 0;  
  printk ("Writing %ld bytes\n", count); 
  
  if (count > C_BUF_LEN -1) 
  	return -ENOMEM; 
  if (count<0) 
  	return -EINVAL; 
   /*应用空间的buf不能直接拷贝到内核空间
   while(count--)
   {

      *c_buf++ = buf++
   }
   */  
  if (copy_from_user (c_buf, buf, count)) {	 /*从用户空间拷贝数据到内核空间
  	 unsigned long copy_from_user(void * to, const void __user * from, unsigned long n) 
  	  to：内核空间的目标缓冲区
  	  from: 应用空间源缓冲区
  	  n:  拷贝的长度   
  	  返回值  0： 成功   正数：没有拷贝成功的字节数
  	  */
     ret = -EFAULT;  
   } else {  
      c_buf[63]='\0';    
       printk ("Received: %s\n", c_buf);   
       ret = count;   
   }  
   return ret;
}

static ssize_t  led_read(struct file *file, char *buff, 
		   size_t count, loff_t *offp)
{
  ssize_t result = 0; 
  if(count > C_BUF_LEN -1 )  
  	count = C_BUF_LEN -1; 
  if(count < 0) 	  
  	return -EINVAL;  
  if (copy_to_user(buff,c_buf, count))       
  	result = -EFAULT; 
  else    
  	printk ("read %ld bytes\n", count);  
  
  result = count;  
  return result;
}


struct file_operations  led_fops  ={
	.write = led_write,
	.read = led_read,
};

```



##### ③验证测试

```c
$ make
$ aarch64-linux-gnu-gcc app.c
$ cp a.out led.ko /nfs/rootfs	
# setenv bootargs  root=/dev/nfs rw nfsroot=192.168.9.119:/nfs/rootfs,v3 console=ttyS0,115200 init=/linuxrc ip=192.168.9.9
# setenv nfsboot ext4load mmc 1:1 0x84000000 /boot/Image \; ext4load mmc 1:1 83100000 /boot/tegra210-p3448-0002-p3449-0000-b00.dtb \; booti 0x84000000 - 83100000
# run nfsboot //成功 可看到 read buf is  let's go ，即读出的数据和写入的一致

```

#### 6、总结

### 三、平台设备

![平台设备框架](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\平台设备框架.png)

#### 1、最简

##### ①

##### ②

##### ③

##### ①内核：配置支持NFS

##### ②设备树：描述设备的硬件信息

##### ③驱动

##### ④编译文件

##### ⑤验证测试

##### 

#### 2、实例：改造字符设备成平台设备

```c
#include <linux/platform_device.h>
#include <linux/of.h>
struct resource *res1;
struct resource *res2;	

//把硬件地址剥离到设备树中，间接访问
//#define  PINMUX_AUX_DAP4_SCLK_0  0x70003150   //管脚复用设置

//#define GPIO3  	0x6000D200 // 第3个Bank GPIO 的基地址
	
//led_probe里添加	
	res1 = platform_get_resource(pdev, IORESOURCE_MEM, 0); 
	if (res1 == NULL) {
		printk("res1 platform_get_resource fail \n");
		return -ENODEV;
	}
	printk("res1->start=%llx\n",res1->start);
	res2 = platform_get_resource(pdev, IORESOURCE_MEM, 1);
	if (res2 == NULL) {
		printk("res2 platform_get_resource fail\n");
		return -ENODEV;
	}	 	
	
	PINMUX_AUX_DAP4_SCLK_0 //替换为res2->start
	GPIO3 //res1->start

    { .compatible = "yhai-plat", },	 //要和设备树里节点名字一致


//自动创建设备节点( 无需再mknod /dev/led c 500 0)
struct class *led_class;	
led_probe{
	led_class = class_create(THIS_MODULE, "yhai_dev_class");
	if (IS_ERR(led_class)) {
		printk("Err: failed in creating class.\n");
		goto err6;
	}

	/* register your own device in sysfs, and this will cause udevd to create corresponding device node */
	device_create(led_class,NULL, devno, NULL,"led");      
}
led_remove{
  device_destroy(led_class, devno);	
  class_destroy(led_class);
}
```

##### 修改后的完整代码

```c
//led.c 改造后的OK代码， -> 好处时，如果你换了管脚，更改设备树地址即可，驱动少变甚至不变
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>  
#include <asm/io.h>   //io操作的头文件(for  ioremap readl)
#include <asm/uaccess.h>  //for copy_to_user
#include <linux/platform_device.h>
#include <linux/of.h>
struct resource *res1;
struct resource *res2;
struct class *led_class;	


#define LED_MA   500  //定义主设备号(区分不同的类别)

#define LED_MI   0  //次设备号

struct cdev cdev; //定义字符设备


#define LED_MAGIC   'L'  //幻数
#define  LED_ON   _IOW(LED_MAGIC,1,int)  //点亮灯
#define  LED_OFF  _IOW(LED_MAGIC,2,int)   //灭灯

//把硬件地址剥离到设备树中，间接访问
//#define  PINMUX_AUX_DAP4_SCLK_0  0x70003150   //管脚复用设置

//#define GPIO3  	0x6000D200 // 第3个Bank GPIO 的基地址
#define CNF     0x04  //配置寄存器 (0:GPIO  1:SFIO)  偏移量
#define OE   	0x14  //输出使能寄存器 (1:使能 0:关闭)
#define OUT  	0x24  //输出寄存器（1：高电平 0：低电平）
#define MSK_CNF 0x84  //配置屏蔽寄存器(高位1:屏蔽 高位0:不屏蔽   低位1:GPIO模式 低位0:SFIO模式)
#define MSK_OE  0x94  //输出使能屏蔽寄存器(高位1:禁止写   低位1:使能)
#define MSK_OUT 0xA4  //输出屏蔽寄存器(高位1:禁止写   低位1:高电平)

 

unsigned char *gpio_pinmux;
unsigned char * gpio_base;

int led_open (struct inode * inode, struct file * file){

    printk(" led open go\n");
    return 0;
}

int led_release(struct inode *inode, struct file * file){
    printk(" led release go\n");
    return 0;
}

//开灯
void led_on(void)
{
        writel(readl(gpio_base+OUT) | 1 << 7, gpio_base+OUT); //引脚输出高电平，点亮灯
	printk("out put high ,led on 输出高电平，点亮灯\n");
}

//关灯
void led_off(void)
{
        writel(readl(gpio_base+OUT) & ~(1 << 7), gpio_base+OUT);  //引脚输出低电平，灭灯
	printk("out put low, led off 输出低电平，灭灯\n");
}


long led_ioctl(struct file *inode, unsigned int cmd , unsigned long args)
{
      printk("cmd=%d\n",cmd);
   	switch(cmd)
   	{
	case LED_ON:
		led_on();
		break;   	
	case LED_OFF:
		led_off();
	default:
		printk("no fond cmd =%d\n",cmd);
		return -1;
   	}
   	return 0;
}



 struct file_operations led_fops={//实现需要的文件操作
    .owner = THIS_MODULE,
    .unlocked_ioctl = led_ioctl,
};	


static int led_probe(struct platform_device *pdev)
{
     int  devno = MKDEV(LED_MA,LED_MI); //合并主次设备号，生成设备ID
     int  ret; 

    //1.注册设备号
      ret = register_chrdev_region(devno,1,"yhai_led");
     if(ret<0){
	 	printk("register_chrdev_region fail \n");
		return ret;
     }

    //2.初始化字符设备
    cdev_init(&cdev,&led_fops);  //字符设备的初始化

    ret =cdev_add(&cdev,devno,1); 
     if(ret<0){
	 	printk("cdev_add fail \n");
		goto err1;
     }

	res1 = platform_get_resource(pdev, IORESOURCE_MEM, 0); 
	if (res1 == NULL) {
		printk("res1 platform_get_resource fail \n");
		goto err4;
	}
	printk("res1->start=%llx\n",res1->start);
	res2 = platform_get_resource(pdev, IORESOURCE_MEM, 1);
	if (res2 == NULL) {
		printk("res2 platform_get_resource fail\n");
		goto err5;
	}	 

     //硬件控制
     //a. 管脚复用的配置，配置为GPIO功能
     //内核驱动里不能直接操作硬件地址，必须映射转化
     	// *PINMUX_AUX_DAP4_SCLK_0 = 0x45;
	// *gpio_out  =0x1
      gpio_pinmux = ioremap(res2->start,8); /*从物理地址PINMUX_AUX_DAP4_SCLK_0开始，映射 8字节长度的空间到内核空间
    动态映射 物理地址 到内核虚拟地址
	phys_addr  起始物理地址
	size       映射范围大小，单位字节
		返回值     映射后的内核虚拟地址 
	*/	
     	if(gpio_pinmux ==NULL){
		printk("ioremap  gpio_pinmux faile \n");		
		goto err2;
     	}
       writel((readl(gpio_pinmux) & ~(1 << 4))|1, gpio_pinmux); /*管脚复用配置用于 GPIO
        1:0 I2S4B    PM: 0 = I2S4B 1 = RSVD1 2 = RSVD2  3 = RSVD3 
        设为非0，表示不用作I2S功能，则默认用做GPIO功能

        4 TRISTATE TRISTATE:   0 = PASSTHROUGH  1 = TRISTATE
        设为0，设为直通状态才能驱动外面的设备

        见 9.5.1 Per Pad Options
     Tristate     高阻态 -> 与外界是断开的，默认启动设为高阻太，避免驱动影响外面的设备             
     passthrough  直通态 -> 才能驱动外面设备   
	*/


       //b.GPIO功能的内部设置
	    gpio_base = ioremap(res1->start, 0xFF); 
	    if (gpio_base == NULL) {
		printk("ioremap gpio_base error\n");
		goto err3;
	    }

	writel(readl(gpio_base+CNF) | 1 << 7, gpio_base+CNF);   //配置引脚GPIO3_PJ.07 为 GPIO模式
      writel(readl(gpio_base+OE) | 1 << 7, gpio_base+OE);	  //使能引脚(7号)
      writel(readl(gpio_base+OUT) | 1 << 7, gpio_base+OUT); //输出高电平，点亮灯
     writel(readl(gpio_base+MSK_CNF) | 1 << 7, gpio_base+MSK_CNF); //取消对GPIO模下引脚的屏蔽
     writel(readl(gpio_base+MSK_OE) | 1 << 7, gpio_base+MSK_OE);  //取消引脚 使能屏蔽


	led_class = class_create(THIS_MODULE, "yhai_dev_class");
	if (IS_ERR(led_class)) {
		printk("Err: failed in creating class.\n");
		goto err6;
	}

	/* register your own device in sysfs, and this will cause udevd to create corresponding device node */
	device_create(led_class,NULL, devno, NULL,"led");     
		
	printk("platform led probe 1\n");
	return 0;

	//goto 实现 顺序申请，逆序释放
err6:	
err5:	
err4:	
err3:
	iounmap(gpio_pinmux);
err2:
	cdev_del(&cdev);
err1:
	unregister_chrdev_region(devno,1);
	return ret;
	
}

static int led_remove(struct platform_device *pdev)

{
      //配对
      //注销设备
      int  devno = MKDEV(LED_MA,LED_MI); 
      //顺序申请，逆序释放
      
      	device_destroy(led_class, devno);
	class_destroy(led_class);
	iounmap(gpio_pinmux); 
	iounmap(gpio_base);
       cdev_del(&cdev);
       unregister_chrdev_region(devno,1);
	printk("platform led exit 1\n");
	return 0;
}



static const struct of_device_id of_led_match[] = {
    { .compatible = "yhai-plat", },
    {},  
};
MODULE_DEVICE_TABLE(of, of_led_match);

static struct platform_driver led_driver = {
    .driver = {
        .name   = "yhai platform led" ,
        .owner = THIS_MODULE,
        .of_match_table = of_led_match,
    },   
    .probe = led_probe,
    .remove = led_remove,
};

module_platform_driver(led_driver);

MODULE_DESCRIPTION(" cdev to platform device ");
MODULE_AUTHOR("chendu yhai"); //模块作者声明(可选)
MODULE_LICENSE("GPL"); //模块免费开源声明
```

#### 3、控制GPIO 通用化

##### ①设备树

##### ②驱动

##### ③编译

##### ④验证测试

#### 4、设备树自定义属性

#### 5、统一设备模型

#### 6、GPIO子系统

![GPIO子系统](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\GPIO子系统.png)

##### ①暴露给应用层

##### ②最简读写文件(在/SYS下)

##### ③读写多个属性文件（在SYS下）

##### ④GPIO驱动（由嵌入式工程师开发）

##### ⑤GPIO库（对上统一操作接口）

##### ⑥GPIO设备树

##### ⑦GPIO芯片驱动( 由原厂开发)

##### ⑧点多个灯(官方示例）

#### 7、管脚控制子系统

#### 8、PWM子系统

#### 9、总结

### 四、I2C设备

![I2C设备](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\I2C设备.png)

#### 1、溯源

```c
//开发场景
 各种传感器 指纹模块、蓝牙模块、WIFI模块，都用到，
 如温度传感器，陀螺仪（重力加速度传感器），OLED屏幕
 图像传感器问题 //如我在调试IMX258 传感器，想实现动态调试16bit寄存器，但是i2cget，i2cset，i2cdump都不能用。
               //https://forums.developer.nvidia.com/t/i2c-tool-reads-sensor-error/69412
 摄像头模块i2c 问题 //https://forums.developer.nvidia.com/t/csi-ov2710-camera-module-driver/44262/12
 摄像头输入帧问题   //https://forums.developer.nvidia.com/t/jetson-sensor-frame-row-mismatch/158150

# i2cdetect -l /* 查看i2c总线使用情况*/
i2c-3   i2c             7000c700.i2c                            I2C adapter
i2c-1   i2c             7000c400.i2c                            I2C adapter
i2c-8   i2c             i2c-6-mux (chan_id 1)                   I2C adapter
i2c-6   i2c             Tegra I2C adapter                       I2C adapter
i2c-4   i2c             7000d000.i2c                            I2C adapter
i2c-2   i2c             7000c500.i2c                            I2C adapter
i2c-0   i2c             7000c000.i2c                            I2C adapter
i2c-7   i2c             i2c-6-mux (chan_id 0)                   I2C adapter
i2c-5   i2c             7000d100.i2c                            I2C adapter	
```

#### 2、框架源码

##### ①设备树帮助文档

```c
//i2c总线（见芯片手册 CHAPTER 35: I2C CONTROLLER）
//Documentation/devicetree/bindings/i2c/nvidia,tegra20-i2c.txt
VIDIA Tegra20/Tegra30/Tegra114 I2C controller driver.

Required properties:
- compatible : must be 
  "nvidia,tegra20-i2c".  For Tegra30, must be "nvidia,tegra30-i2c".
  or tegra210.
  
  nvidia,tegra20-i2c: Tegra20 has 4 generic I2C controller. This can support
    master and slave mode of I2C communication. The i2c-tegra driver only
    support master mode of I2C communication. Driver of I2C controller is
    only compatible with "nvidia,tegra20-i2c".
  with "nvidia,tegra114-i2c".
- reg: Should contain I2C controller registers physical address and length.
- interrupts: Should contain I2C controller interrupts.
- address-cells: Address cells for I2C device address.
- size-cells: Size of the I2C device address.
- clocks: Must contain an entry for each entry in clock-names.
  See ../clocks/clock-bindings.txt for details.
- clock-names: Must include the following entries:
  Tegra20/Tegra30:
  - div-clk
  - fast-clk
  Tegra114:
  - div-clk
- resets: Must contain an entry for each entry in reset-names.
  See ../reset/reset.txt for details.
- reset-names: Must include the following entries:
  - i2c
- dmas: Must contain an entry for each entry in clock-names.
  See ../dma/dma.txt for details.
- dma-names: Must include the following entries:
  - rx
  - tx
- print-rate-limit: Limit the error print rate
```

##### ②设备树

```c
//：/home/dengzj/linux-4.9.253/arch/arm64/boot/dts/nvidia_bsp/soc/t210/kernel-dts/tegra210-soc 设备树
//vim tegra210-soc-base.dtsi

i2c1: i2c@7000c000 {
	#address-cells = <1>;
	#size-cells = <0>;
	compatible = "nvidia,tegra210-i2c";
	reg = <0x0 0x7000c000 0x0 0x100>;
	interrupts = <0 38 0x04>;
	iommus = <&smmu TEGRA_SWGROUP_PPCS>;
	status = "disabled";
	clock-frequency = <400000>;
	dmas = <&apbdma 21>, <&apbdma 21>;
	dma-names = "rx", "tx";
	clocks = <&tegra_car TEGRA210_CLK_I2C1>, <&tegra_car TEGRA210_CLK_PLL_P>;
	clock-names = "div-clk", "parent";
	resets = <&tegra_car 12>;
	reset-names = "i2c";
};

i2c2: i2c@7000c400 {
	#address-cells = <1>;
	#size-cells = <0>;
	compatible = "nvidia,tegra210-i2c";
	reg = <0x0 0x7000c400 0x0 0x100>;
	interrupts = <0 84 0x04>;
	iommus = <&smmu TEGRA_SWGROUP_PPCS>;
	status = "disabled";
	clock-frequency = <100000>;
	dmas = <&apbdma 22>, <&apbdma 22>;
	dma-names = "rx", "tx";
  clocks = <&tegra_car TEGRA210_CLK_I2C2>, <&tegra_car TEGRA210_CLK_PLL_P>;
	clock-names = "div-clk", "parent";
  resets = <&tegra_car 54>;
  reset-names = "i2c";
};
```

##### ③I2C总线驱动

```c
//drivers/i2c/busses/i2c-tegra.c  i2c总线驱动
	
//定义设备类	
struct tegra_i2c_dev {
	struct device *dev;
	struct i2c_adapter adapter; //I2C适配器: 是I2C控制器的软件抽象
	const struct i2c_algorithm *bit_algo; //I2C算法: I2C的通讯方法
	struct i2c_msg *msgs;	//I2C的通讯的数据包(包括地址，长度，数据buf)
}	
static const struct of_device_id tegra_i2c_of_match[] = {
	{ .compatible = "nvidia,tegra210-i2c", .data = &tegra210_i2c_hw, },
};	
	
static struct platform_driver tegra_i2c_driver = {
	.probe   = tegra_i2c_probe,
	.driver  = {
		.name  = "tegra-i2c",
		.of_match_table = tegra_i2c_of_match,
	},
};
	
static int __init tegra_i2c_init_driver(void)
{
	return platform_driver_register(&tegra_i2c_driver);
}
subsys_initcall(tegra_i2c_init_driver);
```

#### 3、例：陀螺仪MPU6050

```c
MPU6050 //六轴传感器模块: 能同时检测三轴加速度、三轴陀螺仪(三轴角速度)的运动数据以及温度数据   
        //应用:手机、智能手环、四轴飞行器、计步器等的姿态检测   
	     	
//管脚连线
vcc --- 3.3v(17)
gnd --- GND(25)
scl --- I2C0_SCL(28)   -> pJ1
sda --- I2C0_SDA(27)   
        //AD0:从机地址设置引脚 :1.接地或悬空时, 地址为0x68；2.接VCC时，地址为0x69
        //INT: 中断输出引脚 (暂未用)
```

##### ①设备树

```c
// ./linux-4.9.253/vender/dts/platform/t210/porg/kernel-dts/tegra210-p3448-0000-p3449-0000-b00.dts
// arch/arm64/boot/dts/nvidia_bsp/platform/t210/porg/kernel-dts/tegra210-p3448-0000-p3449-0000-b00.dts

//tegra210-p3448-0000-p3449-0000-b00.dts
i2c@7000c000 { //i2c设备mp6050，要挂载到的i2c-0控制器，对应 I2C0_SCL(28)，同名节点内容会叠加
  mpu6050-3-axi@68 {
    compatible = "invensense,mpu6050";
     reg = <0x68>; 
  };
};

从机地址0x68由来： /*i2c slave address  
由来 见见mpu6050 的芯片手册 PS-MPU-6000A-00v3.4.pdf 的  
9.2 I2C Interface
The slave address of the MPU-60X0 is b110100X which is 7 bits long.
The LSB bit of the 7 bit address is determined by the logic level on pin AD0.
This allows two MPU-60X0s to be connected to the same I2C bus.
When used in this configuration, the address of the one of the devices should be b1101000 (pin AD0 is logic low)and the address of the other should be b1101001 (pin AD0 is logic high).
AD0 悬空和 结地 一样
i2c设备的地址是 b1101000 -->0x68*/

//tegra210-porg-pinmux-p3448-0000-b00.dtsi
gen1_i2c_scl_pj1 {
  nvidia,pins = "gen1_i2c_scl_pj1";
  nvidia,function = "i2c1";
  nvidia,pull = <TEGRA_PIN_PULL_NONE>;
  nvidia,tristate = <TEGRA_PIN_DISABLE>;
  nvidia,enable-input = <TEGRA_PIN_ENABLE>;
  nvidia,io-high-voltage = <TEGRA_PIN_ENABLE>;
};

gen1_i2c_sda_pj0 {
  nvidia,pins = "gen1_i2c_sda_pj0";
  nvidia,function = "i2c1";
  nvidia,pull = <TEGRA_PIN_PULL_NONE>;
  nvidia,tristate = <TEGRA_PIN_DISABLE>;
  nvidia,enable-input = <TEGRA_PIN_ENABLE>;
  nvidia,io-high-voltage = <TEGRA_PIN_ENABLE>;
};
```

##### ②验证测试

```c
$ cd ~/kernel-4.9
$ make dtbs
$ cp arch/arm64/boot/dts/tegra210-p3448-0000-p3449-0000-b00.dtb   /tftpboot/
$ cd i2c_mpu6050	
$ make
$ cp mpu6050.ko /nfs/rootfs
$ aarch64-linux-gnu-gcc test.c
$ cp a.out /nfs/rootfs

#  insmod mpu6050.ko /*插入报错
[  273.760284] mpu6050: loading out-of-tree module taints kernel.
[  273.766165] //yh warn:kernel/module.c check_modinfo 2996
[  273.766848] match OK!
[  284.021880] tegra-i2c 7000c000.i2c: pio timed out addr: 0x68 tlen:16 rlen:0  
  注：pio timed out addr 错误信息，见drivers/i2c/busses/i2c-tegra.c的 tegra_i2c_xfer_msg
[  284.028859] tegra-i2c 7000c000.i2c: --- register dump for debugging ----
[  284.035559] tegra-i2c 7000c000.i2c: I2C_CNFG - 0x22c00
[  284.040697] tegra-i2c 7000c000.i2c: I2C_PACKET_TRANSFER_STATUS - 0x10011
[  284.047393] tegra-i2c 7000c000.i2c: I2C_FIFO_CONTROL - 0xe0
[  284.052961] tegra-i2c 7000c000.i2c: I2C_FIFO_STATUS - 0x800080
[  284.058787] tegra-i2c 7000c000.i2c: I2C_INT_MASK - 0x7c
[  284.064007] tegra-i2c 7000c000.i2c: I2C_INT_STATUS - 0x82
[  284.069403] tegra-i2c 7000c000.i2c: i2c transfer timed out addr: 0x68
[  294.261869] tegra-i2c 7000c000.i2c: pio timed out addr: 0x68 tlen:16 rlen:0
  */
# mknod  /dev/mpu6050 c 500 5
# ./a.out /*能成功读到下面值，摇晃mpu6050 值会相应变化
acceleration data: x = 0821, y = 01bc, z = 0095
gyroscope data: x = 02ec, y = fcf0, z = 0433
acceleration data: x = 081b, y = 01bb, z = 008d
gyroscope data: x = 02ec, y = fcf2, z = 042d
acceleration data: x = 081d, y = 01c0, z = 0099  
  */

```

##### ③问题排查

```c
# ls /sys/bus/i2c/devices /*查看I2C设备情况
 0-0068  3-0050  4-003c  6-0040  8-0010  i2c-1   i2c-3   i2c-5   i2c-7
 3-003a  3-0054  4-0068  7-0010  i2c-0   i2c-2   i2c-4   i2c-6   i2c-8
注： i2c-0 ~ i2c-8 对应SOC里 9个 I2C控制器
     0-0068  表示挂载到i2c-0 adapter上的从机地址为0x68的i2c设备(对应mpu6050 设备树里的 reg = <0x68>;)
 */

# ls  /sys/firmware/devicetree/base/i2c@7000c000  /*能看到6050节点信息，说明设备节点有生效
   mpu6050-3-axi@68
   */	
	
# cat /sys/kernel/debug/pinctrl/pinctrl-handles |grep pj1 /*查看管脚 scl的管脚复用状态
  type: MUX_GROUP controller 700008d4.pinmux group: gen1_i2c_scl_pj1 (58) function: i2c1 (17)
    type: CONFIGS_GROUP controller 700008d4.pinmux group gen1_i2c_scl_pj1 (58)config pull=0

  */  	
	
//后面发现是mpu6050_write_byte函数有问题，应改为
static int mpu6050_write_byte(struct i2c_client *client, uint8_t reg_addr, uint8_t data)
{
    int ret = 0;
    uint8_t w_buf[2];

    struct i2c_msg msg;

    w_buf[0] = reg_addr;
    w_buf[1] = data;

    msg.addr = client->addr;
    msg.buf = w_buf;
    msg.flags = 0; // I2C direction write 
    msg.len = sizeof(w_buf);

    ret = i2c_transfer(client->adapter, &msg, 1);
    if (ret < 0){
        printk("i2c transfer err\n");
        return ret;
    }
    else if (ret != 1){
        printk("i2c transfer err -EIO\n");
        return -EIO;
    }
    //printk("i2c transfer ok\n");

    return 0;
}
```



##### ④应用程序

```c
//test.c

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>

#include "mpu6050.h"

int main(int argc, const char *argv[])
{
	int fd;
	union mpu6050_data data; 
	
	fd = open("/dev/mpu6050", O_RDWR);
	if (fd < 0) {
		perror("open");
		exit(1);
	}

	while(1) {
		//三轴加速度
		ioctl(fd, GET_ACCEL, &data);
		printf("1 acceleration data: x = %04x, y = %04x, z = %04x\n", 
				data.accel.x, data.accel.y, data.accel.z);
                //三轴陀螺仪(三轴角速度)
		ioctl(fd, GET_GYRO, &data);
		printf("2 gyroscope data: x = %04x, y = %04x, z = %04x\n", 
				data.accel.x, data.accel.y, data.accel.z);
		//温度值	
		ioctl(fd, GET_TEMP, &data);
		printf("3 temp data: = %x \n", data.temp);
		sleep(1);
	}

	close(fd);

	return 0;
}
```



##### ⑤驱动程序

##### ⑥头文件

##### ⑦编译文件

```c
/mpu6050.h
#ifndef MPU6050_HHHH
#define MPU6050_HHHH

#define MPU6050_MAGIC 'K'

union mpu6050_data
{
	struct {
		unsigned short x;
		unsigned short y;
		unsigned short z;
	}accel; //三轴加速度
	struct {
		unsigned short x;
		unsigned short y;
		unsigned short z;
	}gyro; //三轴陀螺仪(三轴角速度)
	unsigned short temp; //温度值
};

#define GET_ACCEL _IOR(MPU6050_MAGIC, 0, union mpu6050_data)
#define GET_GYRO  _IOR(MPU6050_MAGIC, 1, union mpu6050_data) 
#define GET_TEMP  _IOR(MPU6050_MAGIC, 2, union mpu6050_data)

#endif
```

##### ⑧挑战

```
1. 换另一个 i2c中线试试，看要如何改才能工作
2. 用i2c 读取不同传感器的值 //见前面单片机套件	
```

#### 4、例：OLED屏控制

```
ssd1306 //是驱动oled屏显示的 单片机芯片，是集成在oled模块里面
        //它是作为i2c从机，和jetson 主机通讯
        //支持uart i2c 和spi控制
slave addr //见 SSD1306.pdf 的 8.1.5 MCU I2C Interface   
            //   0111100 -> 0x3c
```

##### ①最简（完全由应用层控制I2C设备）

```
//测试
$ aarch64-linux-gnu-gcc main.c
$ cp a.out /nfs/rootfs


# ./a.out //能成功看到屏幕全亮，且会闪烁
//main.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/i2c-dev.h>

int SSD1306_send_cmd (int hi2c, unsigned char cmd)
{
  unsigned char sending_buffer[2];

  sending_buffer[0] = 0x00;
  sending_buffer[1] = cmd;

  return write (hi2c, sending_buffer, 2);
}

void SSD1306_Init(int fd)
{
  SSD1306_send_cmd(fd,0xAE);//关闭显示

  SSD1306_send_cmd(fd,0xD5);//设置时钟分频因子,震荡频率
  SSD1306_send_cmd(fd,80);  //[3:0],分频因子;[7:4],震荡频率

  SSD1306_send_cmd(fd,0xA8);//设置驱动路数
  SSD1306_send_cmd(fd,0X3F);//默认0X3F(hi2c,1/64)
  SSD1306_send_cmd(fd,0xD3);//设置显示偏移
  SSD1306_send_cmd(fd,0X00);//默认为0

  SSD1306_send_cmd(fd,0x40);//设置显示开始行 [5:0],行数.

  SSD1306_send_cmd(fd,0x8D);//电荷泵设置
  SSD1306_send_cmd(fd,0x14);//bit2，开启/关闭

  SSD1306_send_cmd(fd,0x20);//设置内存地址模式
  SSD1306_send_cmd(fd,0x00);

  SSD1306_send_cmd(fd,0xA1);//段重定义设置,bit0:0,0->0;1,0->127;
  SSD1306_send_cmd(fd,0xC0);

  SSD1306_send_cmd(fd,0xDA);//设置COM硬件引脚配置
  SSD1306_send_cmd(fd,0x12);//[5:4]配置

  SSD1306_send_cmd(fd,0x81);//对比度设置
  SSD1306_send_cmd(fd,0xEF);//1~255;默认0X7F (hi2c,亮度设置,越大越亮)

  SSD1306_send_cmd(fd,0xD9);//设置预充电周期
  SSD1306_send_cmd(fd,0xf1);//[3:0],PHASE 1;[7:4],PHASE 2;

  SSD1306_send_cmd(fd,0xDB);//设置VCOMH 电压倍率
  SSD1306_send_cmd(fd,0x30);//[6:4] 000,0.65*vcc;001,0.77*vcc;011,0.83*vcc;

  SSD1306_send_cmd(fd,0xA4);//全局显示开启;bit0:1,开启;0,关闭;(白屏/黑屏)

  SSD1306_send_cmd(fd,0xA6);//设置显示方式;bit0:1,反相显示;0,正常显示

  SSD1306_send_cmd(fd,0xAF);//开启显示	
}
int main(int argc, const char *argv[])
{
	int ret;
	int fd;

	
	fd = open("/dev/i2c-1", O_WRONLY);  //打开i2c控制器(下面可以挂多个i2c设备)
	if (fd < 0) {
		perror("open");
		exit(1);
	}

  ret = ioctl (fd, I2C_SLAVE_FORCE, 0x3c);  //指定i2c从机设备的id  (id为0x3c 的是oled屏)
  if (ret < 0) {
  	perror("ioctl");
  	exit(1);
  }		

  SSD1306_Init(fd);  //初始化oled屏
  sleep(1);
  SSD1306_send_cmd(fd,0xAE);//关闭显示
  sleep(1);
  SSD1306_send_cmd(fd,0xAF);//开启显示
  printf("test i2c oled \n");
  close(fd);
  return 0;
}	
```

##### ②挑战

```
把OLED屏更改到另一个 i2c总线上，

实现OLED屏上显示 数字 ，或字母，甚至汉字。
```



#### 5、例：小车马达控制

```c
PCA9685 //是NXP推出，一款基于IIC总线通信的12位精度16通道PWM波输出的芯片 -> I/O扩展
        //可多个pwm输出控制电机，led调光舵机等设备  -> 节省主机资源
        //JetBot 小车用它扩展 I/O ，一边与主控通过 I2C 总线通信，另一边连接 TB6612 马达驱动芯片

TB6612 //用pwm控制的电机驱动芯片，可控制2个电机(停止 正传 反转)
       //STBY: 使能端口，高电平有效
       //PWM 电机提供pwm脉冲。
       //IN1 IN2  00:停止 01:正转 10:反转      
       //O1 O2 输出接电机
	  
TT电机 //直流减速电机TT马达
       //改变 O1 O2 极性可正传 反转， pwm调节输出电压值，可控制转速
       //注: 这里才用个马达速度差来实现转弯， 故没有方向盘的舵机
```

##### ①最简测试

```c
//用python版的做验证参考
网页登录 http://192.168.10.237:8888/ 输入密码yhai
打开 notebooks/basic_motion/basic_motion.ipynb //逐步运行，发现能控制小车，表示基本成功
                           //注意小车电源开关要打开哦
//最简：python控制电机
//car1.py	
from jetbot import Robot
import time
robot = Robot()
robot.left(speed=0.3)
time.sleep(1)
robot.stop()	

//运行
$ python3 car1.py	 

//跟踪python如何调用驱动
vscode 远程打开板子上	car1.py	-> 光标移到Robot上 -> 右键选跳转到定义 
如没有提示 //见  天眼 -> 开发板SDK包 -> 环境搭建:  从零自己制作 -> Window 下远程操作 -> 远程代码提示
详见 // 天眼 -> 开发板SDK包 -> 源码分析 -> jetbot源码分析	  
```

##### ②设备树

```c
//Documentation/devicetree/bindings/pwm/nxp,pca9685-pwm.txt
//tegra210-p3448-0000-p3449-0000-b00.dts
i2c@7000c400  { //i2c设备pca9685，要挂载到的i2c-1控制器，对应 I2C1_SCL(5)，同名节点内容会叠加
   motor_pwm:pca9685@40 {
    compatible = "nxp,pca9685-pwm";
    #pwm-cells = <2>;
    reg = <0x41>;  //slave地址 1a5~a0  通过电路图确定a0到a5接的电平，                            
    invert;
    open-drain; 
  };
};	
```

##### ③驱动

```
drivers/pwm/pwm-pca9685.c 
```

##### ④验证

```c
$ make menuconfig
  Device Drivers  ---> 
     [*] Pulse-Width Modulation (PWM) Support  --->
           <M>   NXP PCA9685 PWM driver
$ make modules -j4         
$ cp drivers/pwm/pwm-pca9685.ko  /nfs/rootfs	  
$ make dtbs
$ cp arch/arm64/boot/dts/tegra210-p3448-0000-p3449-0000-b00.dtb   /tftpboot/ 

# insmod pwm-pca9685.ko /* 插入模块
[   21.531347] tegra-i2c 7000c400.i2c: no acknowledge from address 0x40 
[   21.537960] tegra-i2c 7000c400.i2c: no acknowledge from address 0x40
[   21.544523] tegra-i2c 7000c400.i2c: no acknowledge from address 0x40
[   21.551071] tegra-i2c 7000c400.i2c: no acknowledge from address 0x40
[   21.559053] tegra-i2c 7000c400.i2c: no acknowledge from address 0x40
[root@yhai ]# [   21.565654] leds_pwm pwmleds: unable to request PWM for led for motor 0: -121
[   21.573866] leds_pwm: probe of pwmleds failed with error -121
注：  报错 i2c从设备没有回应，
最后通过python的库（或电路图略）
   class Adafruit_MotorHAT:
      def __init__(self, addr = 0x60, freq = 1600, i2c=None, i2c_bus=None): 
      
   发现i2c从设备的地址是0x60 不是0x41    
 */
```

##### ⑤挑战

```
1.用C驱动方式，控制马达 //以OK的python库控制马达的例子做参考（确定 pca9685的i2c的通讯控制命令）
```

### 五、中断机制

### 六、并发控制

### 七、阻塞非阻塞 同步异步

### 八、内存资源管控

## 伍、驱动高级

### 一、摄像头

#### 1、溯源

![摄像头溯源](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\摄像头溯源.png)

```
摄像头：镜头采集光线，通过CCD/CMOS将光信息转化为电信号，ISP(图像信号处理芯片)将电信号转换为图像。
CSI-->VI-->ISP
不同厂商根据硬件的不同进行优化，定制不同的库(如nvidia的libargus)
难点在于：摄像头知识的地图构建
c语言面向过程，代码中有许多冗余的结构体，方便调用，类似与软连接。 底层驱动代码-->命名规范，知名见意
c++面向对象，有继承机制，子类可以继承父类的一些属性和方法
硬件信息和驱动程序(控制设备的一些方法)分离思想，硬件变化只需要改设备树即可
上锁时机:插入链表、remap映射内部机制、
驱动初始化步骤：分配空间、初始化、注册、硬件初始化
i2C控制图像的尺寸、帧率、曝光、相关参数
CSI传输：数据处理
一个设备有多个通道，一个通道可能有多个端口，一个端口下有多个通路
```

#### 2、V4L2应用开发

##### ①能识别摄像头

```c
/---虚拟机上 能识别摄像头 
usb摄像头 插入电脑 
vmware -> 虚拟机 -> 可移动设备 -> USB camera -> 连接   
$ ls -l /dev/video0*  /*查看摄像头有生成没
   /dev/video0  电脑 自带摄像头	
   /dev/video1  其它摄像头
  让摄像头 在ubuntu里能识别到，成功会自动生成 /dev/video   */
$ lsusb -t /* 查看usb树信息 
	/:  Bus 04.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/4p, 5000M
	/:  Bus 03.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/4p, 480M
	    |__ Port 1: Dev 2, If 0, Class=Hub, Driver=hub/7p, 12M
	        |__ Port 1: Dev 4, If 0, Class=Human Interface Device, Driver=usbhid, 12M
	    |__ Port 2: Dev 3, If 0, Class=Hub, Driver=hub/7p, 480M
	        |__ Port 1: Dev 11, If 3, Class=Audio, Driver=snd-usb-audio, 480M   
	        |__ Port 1: Dev 11, If 1, Class=Video, Driver=uvcvideo, 480M    usb摄像头信息
	        |__ Port 1: Dev 11, If 2, Class=Audio, Driver=snd-usb-audio, 480M
	        |__ Port 1: Dev 11, If 0, Class=Video, Driver=uvcvideo, 480M
	    |__ Port 3: Dev 5, If 0, Class=Hub, Driver=hub/7p, 12M
	    |__ Port 4: Dev 6, If 0, Class=Hub, Driver=hub/7p, 480M
	/:  Bus 02.Port 1: Dev 1, Class=root_hub, Driver=uhci_hcd/2p, 12M
	    |__ Port 1: Dev 7, If 0, Class=Wireless, Driver=btusb, 12M
	    |__ Port 1: Dev 7, If 1, Class=Wireless, Driver=btusb, 12M
	    |__ Port 2: Dev 3, If 0, Class=Hub, Driver=hub/7p, 12M
	/:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=ehci-pci/6p, 480M
*/
$ lsusb  /* 查看usb摄像头 的设备ID (可尝试移除再添加新增了哪个 哪个就是usb摄像头)
Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 003 Device 006: ID 0e0f:0002 VMware, Inc. Virtual USB Hub
Bus 003 Device 005: ID 0e0f:0002 VMware, Inc. Virtual USB Hub   
Bus 003 Device 008: ID 1bcd:4002 VMware, Inc. VMware Virtual USB Hub 这是usb摄像头的ID  1bcd:4002
Bus 003 Device 003: ID 0e0f:0002 VMware, Inc. Virtual USB Hub
Bus 003 Device 004: ID 0e0f:0003 VMware, Inc. Virtual Mouse
Bus 003 Device 002: ID 0e0f:0002 VMware, Inc. Virtual USB Hub
Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 003: ID 0e0f:0002 VMware, Inc. Virtual USB Hub
Bus 002 Device 002: ID 0e0f:0008 VMware, Inc. Virtual Bluetooth Adapter
Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
 */

$ sudo cat /sys/kernel/debug/usb/devices |grep 4002 -A 5 /* 通过id 查找设备厂商信息
P:  Vendor=1bcd ProdID=4002 Rev=11.23
S:  Manufacturer=XHT-211123-HD  生产商
S:  Product=Photry PC230A QHD Webcam  产品名
S:  SerialNumber=01.00.00
C:* #Ifs= 4 Cfg#= 1 Atr=80 MxPwr=500mA
A:  FirstIf#= 0 IfCount= 2 Cls=0e(video) Sub=03 Prot=00
 */
 
$ sudo apt install v4l-utils 
$ v4l2-ctl -d  /dev/video0 --all /*通过v4l2工具，查看摄像头 参数
Driver Info:
	Driver name      : uvcvideo
	Card type        : Photry PC230A QHD WebcamPhotry PC230A QHD Webcam: Photr
	Bus info         : usb-0000:03:00.0-2.1
	Driver version   : 5.13.19
	Capabilities     : 0x84a00001
		Video Capture
		Metadata Capture
		Streaming
		Extended Pix Format
		Device Capabilities
	Device Caps      : 0x04200001
		Video Capture
		Streaming
		Extended Pix Format
Priority: 2
Video input : 0 (Camera 1: ok)
Format Video Capture:
	Width/Height      : 2560/1440
	Pixel Format      : 'MJPG' (Motion-JPEG)
	Field             : None
	Bytes per Line    : 0
	Size Image        : 7372800
	Colorspace        : sRGB
	Transfer Function : Rec. 709
	YCbCr/HSV Encoding: ITU-R 601
	Quantization      : Default (maps to Full Range)
	Flags             : 
Crop Capability Video Capture:
	Bounds      : Left 0, Top 0, Width 2560, Height 1440
	Default     : Left 0, Top 0, Width 2560, Height 1440
	Pixel Aspect: 1/1
Selection Video Capture: crop_default, Left 0, Top 0, Width 2560, Height 1440, Flags: 
Selection Video Capture: crop_bounds, Left 0, Top 0, Width 2560, Height 1440, Flags: 
Streaming Parameters Video Capture:
	Capabilities     : timeperframe
	Frames per second: 30.000 (30/1)
	Read buffers     : 0
                     brightness 0x00980900 (int)    : min=-64 max=64 step=1 default=0 value=-17
                       contrast 0x00980901 (int)    : min=0 max=95 step=1 default=0 value=0
                     saturation 0x00980902 (int)    : min=0 max=100 step=1 default=34 value=64
                            hue 0x00980903 (int)    : min=-2000 max=2000 step=1 default=0 value=-10
 white_balance_temperature_auto 0x0098090c (bool)   : default=1 value=1
                          gamma 0x00980910 (int)    : min=100 max=300 step=1 default=100 value=100
           power_line_frequency 0x00980918 (menu)   : min=0 max=2 default=1 value=1
				0: Disabled
				1: 50 Hz
				2: 60 Hz
      white_balance_temperature 0x0098091a (int)    : min=2800 max=6500 step=1 default=4600 value=4600 flags=inactive
                      sharpness 0x0098091b (int)    : min=1 max=7 step=1 default=1 value=1
         backlight_compensation 0x0098091c (int)    : min=0 max=1 step=1 default=0 value=0
                  exposure_auto 0x009a0901 (menu)   : min=0 max=3 default=3 value=3
				1: Manual Mode
				3: Aperture Priority Mode
              exposure_absolute 0x009a0902 (int)    : min=3 max=2047 step=1 default=166 value=166 flags=inactive
                 focus_absolute 0x009a090a (int)    : min=0 max=1023 step=1 default=0 value=195 flags=inactive
                     focus_auto 0x009a090c (bool)   : default=0 value=1

 */

$ sudo apt-get install guvcview
$ guvcview -d /dev/video0  //视频显示( 注：是video0 还是video1更具你电脑决定，如果自带了摄像头那，外插usb摄像头就是video1)

$ sudo apt-get install cheese
$ cheese -d /dev/video0  //视频显示

//---板子上 能识别摄像头
官方bsp包已支持 usb摄像头
# run  distro_bootcmd  //按官方 bsp OK镜像启动
板子上插入usb摄像头  //有识别到设备的信息打印
$ ls -l /dev/video0  //能成功看到该设备，表示驱动有识别
# sudo apt install v4l-utils  
# v4l2-ctl -d  /dev/video0 --all //能成功看到摄像头的参数信息，表示摄像头驱动支持是基本成功的
     //板子上跑的就是ubuntu系统，几乎和虚拟机里摄像头操作没差别
```

##### ②最简：查看设备能力信息

```c
//app.c	
#include <stdio.h>      //for open printf
#include <fcntl.h>      //for Open O_RDWR
#include <string.h>     //for memset
#include <sys/ioctl.h>  //for ioctl
#include <linux/videodev2.h> //for v4l2
	
//查看 摄像头设备的能力	
int get_capability(int fd){
	int ret;
	struct v4l2_capability cap;	
	
	memset(&cap, 0, sizeof(struct v4l2_capability)); /*SourceInsight跳转,可看到能力描述
			struct v4l2_capability {
			__u8	driver[16];   驱动名
			__u8	card[32];   设备名
			__u8	bus_info[32]; 总线信息
			__u32   version;  版本
			__u32	capabilities;  设备支持的操作
			__u32	device_caps;
			__u32	reserved[3];
		};
	  */
	ret = ioctl(fd, VIDIOC_QUERYCAP, &cap);  //查看设备能力信息
	if (ret < 0) {
	    printf("VIDIOC_QUERYCAP failed (%d)\n", ret);
	    return ret;
	}
	printf("Driver Info: \n  Driver Name:%s \n  Card Name:%s \n  Bus info:%s \n",cap.driver,cap.card,cap.bus_info);
	printf("Device capabilities: \n"); 	
	if (cap.capabilities & V4L2_CAP_VIDEO_CAPTURE) { //支持视频捕获(截取一帧图像保存)
	  printf("  support video capture \n");
	}

	if (cap.capabilities & V4L2_CAP_STREAMING) { //支持视频流操作(mmap映射到同一缓冲区队列，后的入队出队 即流入流出，
	  printf("  support streaming i/o\n");
	}

	if(cap.capabilities & V4L2_CAP_READWRITE) { //支持读写（需内核到应用空间拷贝 慢)
	  printf("  support read i/o\n");
	}
	//V4L2_CAP_VIDEO_OVERLAY 支持视频预览（覆盖），指无需帧拷贝，直接存放到显卡的内存，需硬件的DMA支持 -> 实时预览
	//V4L2_CAP_VIDEO_OUTPUT 支持视频输出
	//V4L2_CAP_VBI_CAPTURE  针对老式 模拟显示设备（CRT),很少用
	//V4L2_CAP_RDS_CAPTURE 电台识别	
}
	
int main(int argc, char**argv)
{ 
	int fd = open("/dev/video0", O_RDWR, 0);
	if (fd < 0) {
	    printf("Open /dev/video0 failed\n");
	    return -1;
	} 
	get_capability(fd);
	return 0;
}	

$ gcc app.c	
$ ./a.out /*成功可看到信息
Driver Info: 
  Driver Name:uvcvideo 
  Card Name:Photry PC230A QHD Webcam: Photr 
  Bus info:usb-0000:03:00.0-2.1 
Device capabilities: 
  support video capture 
  support streaming i/o */
```

##### ③查看支持视频格式

```c
int get_suppurt_video_format(int fd){
	int ret;
  printf("List device support video format:  \n");
  struct v4l2_fmtdesc fmtdesc;
  memset(&fmtdesc, 0, sizeof(fmtdesc));
  fmtdesc.index = 0;
  fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
  while ((ret = ioctl(fd, VIDIOC_ENUM_FMT, &fmtdesc)) == 0) //枚举出支持的视频格式
  {
     fmtdesc.index++;
     printf("  { pixelformat = ''%c%c%c%c'', description = ''%s'' }\n",
	fmtdesc.pixelformat & 0xFF, (fmtdesc.pixelformat >> 8) & 0xFF, (fmtdesc.pixelformat >> 16) & 0xFF, 
	(fmtdesc.pixelformat >> 24) & 0xFF, fmtdesc.description);
  }		
  return ret;
}	
	
$ ./a.out /*成功可看到信息
List device support video format:  
  { pixelformat = ''MJPG'', description = ''Motion-JPEG'' }  支持jpeg图片，可直接存储（不用软件调jpeg库转换)
  { pixelformat = ''YUYV'', description = ''YUYV 4:2:2'' }  支持YUYV 4:2:2格式

BMP 位图编码格式中的无损格式。由信息头数据信息等组成
JPG 位图编码格式中的有损压缩格式

RGB: 色彩模式， 红(R)、绿(G)、蓝(B)，占三个字节。  用R G B三原色混合成不同的颜色
	   RGB24   1个点需要 8x3=24 bits即24bpp
	   
YUV： 电视模拟信号的颜色编码方法（属于PAL），Y代表亮度，UV代表色度，U(Cr 相对于红色偏差），V（Cb 相对于蓝色偏差）（相比RGB，占用频宽小）。
注： 在视频采集编码时，RGB数据量太大，且发现人眼对亮度更敏感，故采用了亮度和色差来表示图像。
     4：2：2 表示每4个像素点采样一4 Y分量， 2 U分量  2 V 分量
CIF: 视频YUV帧 的文件存储格式,
D1:  4*CIF
 */	
```



##### ④设置视频格式

```c
#define VIDEO_WIDTH  320  //采集图像的宽度
#define VIDEO_HEIGHT 240  //采集图像的高度	
	
//设置视频格式	
int set_video_format(int fd){	
	int ret=0;
	struct v4l2_format fmt;
	
	memset(&fmt, 0, sizeof(fmt));
	fmt.type                = V4L2_BUF_TYPE_VIDEO_CAPTURE;
	fmt.fmt.pix.width       = VIDEO_WIDTH; 
	fmt.fmt.pix.height      = VIDEO_HEIGHT;
	fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG; //注：如果是支持mipg的摄像头最好(白色小摄像头)
                                               //    普通摄像头 用 V4L2_PIX_FMT_YUYV 它比较麻烦，要用到jpeg库
	fmt.fmt.pix.field       = V4L2_FIELD_INTERLACED;
	ret = ioctl(fd, VIDIOC_S_FMT, &fmt);
	if (ret < 0) {
	    printf("VIDIOC_S_FMT failed (%d)\n", ret);
	    return ret;
	}

	// 获取视频格式
	ret = ioctl(fd, VIDIOC_G_FMT, &fmt);
	if (ret < 0) {
	    printf("VIDIOC_G_FMT failed (%d)\n", ret);
	    return ret;
	}
	// Print Stream Format
	printf("Stream Format Informations:\n");
	printf(" type: %d\n", fmt.type);
	printf(" width: %d\n", fmt.fmt.pix.width);
	printf(" height: %d\n", fmt.fmt.pix.height);
	char fmtstr[8];
	memset(fmtstr, 0, 8);
	memcpy(fmtstr, &fmt.fmt.pix.pixelformat, 4);
	printf(" pixelformat: %s\n", fmtstr);
	printf(" field: %d\n", fmt.fmt.pix.field);
	printf(" bytesperline: %d\n", fmt.fmt.pix.bytesperline);
	printf(" sizeimage: %d\n", fmt.fmt.pix.sizeimage);
	printf(" colorspace: %d\n", fmt.fmt.pix.colorspace);
	printf(" priv: %d\n", fmt.fmt.pix.priv);
	printf(" raw_date: %s\n", fmt.fmt.raw_data);	
	return ret;
}

$ ./a.out /*成功可看到信息
Stream Format Informations:
 type: 1
 width: 640   
 height: 480
 pixelformat: MJPG
 field: 1
 bytesperline: 0
 sizeimage: 614400
 colorspace: 8
 priv: -17970434
 raw_date: ?

 */	
```



##### ⑤申请帧缓冲

```c
#define	REQBUFS_COUNT	4	 //缓存区个数
struct v4l2_requestbuffers reqbufs; 	///定义缓冲区
struct cam_buf {
	void *start;
	size_t length;
};
struct cam_buf bufs[REQBUFS_COUNT]; //映射后指向的同一片帧缓冲区

//申请帧缓冲区
int request_buf(int fd){
	int ret=0;
	int i;
	struct v4l2_buffer vbuf;
	
	memset(&reqbufs, 0, sizeof(struct v4l2_requestbuffers));
	reqbufs.count	= REQBUFS_COUNT;//缓存区个数
	reqbufs.type	= V4L2_BUF_TYPE_VIDEO_CAPTURE;
	reqbufs.memory	= V4L2_MEMORY_MMAP;//设置操作申请缓存的方式:映射 MMAP
	ret = ioctl(fd, VIDIOC_REQBUFS, &reqbufs); //向驱动申请缓存	
	if (ret == -1) {	
		printf("VIDIOC_REQBUFS fail  %s %d\n",__FUNCTION__,__LINE__);
		return ret;
	}
	//循环映射并入队 -> 让内核 和 应用的虚拟地址空间 指向同一片物理内存
	for (i = 0; i < reqbufs.count; i++){
		//真正获取缓存的地址大小
		memset(&vbuf, 0, sizeof(struct v4l2_buffer));
		vbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
		vbuf.memory = V4L2_MEMORY_MMAP;
		vbuf.index = i;
		ret = ioctl(fd, VIDIOC_QUERYBUF, &vbuf);
		if (ret == -1) {
		  printf("VIDIOC_QUERYBUF fail  %s %d\n",__FUNCTION__,__LINE__);
			return ret;
		}
		//映射缓存到用户空间,通过mmap讲内核的缓存地址映射到用户空间,并切和文件描述符fd相关联
		bufs[i].length = vbuf.length;
		bufs[i].start = mmap(NULL, vbuf.length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, vbuf.m.offset);
		if (bufs[i].start == MAP_FAILED) {
			printf("mmap fail  %s %d\n",__FUNCTION__,__LINE__);
			return ret;
		}
		//每次映射都会入队,放入缓冲队列
		vbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
		vbuf.memory = V4L2_MEMORY_MMAP;
		ret = ioctl(fd, VIDIOC_QBUF, &vbuf);
		if (ret == -1) {
			printf("VIDIOC_QBUF err %s %d\n",__FUNCTION__,__LINE__);
			return ret;
		}
	}
	return ret;
}	
```



##### ⑥启动采集

```c
int start_camera(int fd)
{
	int ret;
	
	enum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
	ret = ioctl(fd, VIDIOC_STREAMON, &type); //ioctl控制摄像头开始采集
	if (ret == -1) {
		perror("start_camera");
		return -1;
	}
	fprintf(stdout, "camera->start: start capture\n");
	return 0;
}
```



##### ⑦出队取一帧图像

```c
int camera_dqbuf(int fd, void **buf, unsigned int *size, unsigned int *index){
	int ret=0;
	struct v4l2_buffer vbuf;
	vbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
	vbuf.memory = V4L2_MEMORY_MMAP;
	ret = ioctl(fd, VIDIOC_DQBUF, &vbuf);	//出队,也就是从用户空间取出图片
	if (ret == -1) {
		perror("camera dqbuf ");
		return -1;
	}	
	*buf = bufs[vbuf.index].start;
	*size = vbuf.bytesused;
	*index = vbuf.index;	
	return ret;
}	

int main(int argc, char**argv)
{ 
	char *jpeg_ptr = NULL;
	unsigned int size;
	unsigned int index;
        camera_dqbuf(fd, (void **)&jpeg_ptr, &size, &index); //出队取一帧图像	
  
	int pixfd = open("1.jpg", O_WRONLY|O_CREAT, 0666);//打开文件（无则 创建一个空白文件）
	write(pixfd, jpeg_ptr, size); //将一帧图像写入文件  
}	
```



##### ⑧入队归还帧缓冲

```c
int camera_eqbuf(int fd, unsigned int index)
{
	int ret;
	struct v4l2_buffer vbuf;

	vbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
	vbuf.memory = V4L2_MEMORY_MMAP;
	vbuf.index = index;
	ret = ioctl(fd, VIDIOC_QBUF, &vbuf);		//入队
	if (ret == -1) {
		perror("camera->eqbuf");
		return -1;
	}

	return 0;
}	
```



##### ⑨停止视频采集

```c
int camera_stop(int fd)
{
	int ret;
	enum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

	ret = ioctl(fd, VIDIOC_STREAMOFF, &type);
	if (ret == -1) {
		perror("camera->stop");
		return -1;
	}
	fprintf(stdout, "camera->stop: stop capture\n");

	return 0;
}
```



##### ⑩退出释放资源

```c
int camera_exit(int fd)
{
	int i;
	int ret=0;
	struct v4l2_buffer vbuf;
	vbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
	vbuf.memory = V4L2_MEMORY_MMAP;
	
	//出队所有帧缓冲
	for (i = 0; i < reqbufs.count; i++) {
		ret = ioctl(fd, VIDIOC_DQBUF, &vbuf);
		if (ret == -1)
			break;
	}
	
	//取消所有帧缓冲映射
	for (i = 0; i < reqbufs.count; i++)
		munmap(bufs[i].start, bufs[i].length);
	fprintf(stdout, "camera->exit: camera exit\n");
	return ret;
}	
```

##### ⑩采集一张图片（完整版）

```c
$ gcc app.c	
$ ./a.out /dev/video0 // 采集摄像头图片，成功生成1.jpg图片(注意/dev/video0 根据实际情况改写)

//app.c	
#include <stdio.h>      //for open printf
#include <fcntl.h>      //for Open O_RDWR 文件控制定义
#include <string.h>     //for memset
#include <sys/ioctl.h>  //for ioctl
#include <linux/videodev2.h> //for v4l2
	
#include <sys/mman.h>
#include<unistd.h>     /*Unix 标准函数定义*/
#include<errno.h>      /*错误号定义*/
	

#define VIDEO_WIDTH  320  //采集图像的宽度
#define VIDEO_HEIGHT 240  //采集图像的高度	
	
#define	REQBUFS_COUNT	4	 //缓存区个数
struct v4l2_requestbuffers reqbufs; 	///定义缓冲区
struct cam_buf {
	void *start;
	size_t length;
};
struct cam_buf bufs[REQBUFS_COUNT]; //映射后指向的同一片帧缓冲区
	
	
//查看 摄像头设备的能力	
int get_capability(int fd){
	int ret=0;
	struct v4l2_capability cap;	
	
	memset(&cap, 0, sizeof(struct v4l2_capability)); /*SourceInsight跳转,可看到能力描述
			struct v4l2_capability {
			__u8	driver[16];   驱动名
			__u8	card[32];   设备名
			__u8	bus_info[32]; 总线信息
			__u32   version;  版本
			__u32	capabilities;  设备支持的操作
			__u32	device_caps;
			__u32	reserved[3];
		};
	  */
	ret = ioctl(fd, VIDIOC_QUERYCAP, &cap);  //查看设备能力信息
	if (ret < 0) {
	    printf("VIDIOC_QUERYCAP failed (%d)\n", ret);
	    return ret;
	}
	printf("Driver Info: \n  Driver Name:%s \n  Card Name:%s \n  Bus info:%s \n",cap.driver,cap.card,cap.bus_info);
	printf("Device capabilities: \n"); 	
	if (cap.capabilities & V4L2_CAP_VIDEO_CAPTURE) { //支持视频捕获(截取一帧图像保存)
	  printf("  support video capture \n");
	}

	if (cap.capabilities & V4L2_CAP_STREAMING) { //支持视频流操作(mmap映射到同一缓冲区队列，后的入队出队 即流入流出，
	  printf("  support streaming i/o\n");
	}

	if(cap.capabilities & V4L2_CAP_READWRITE) { //支持读写（需内核到应用空间拷贝 慢)
	  printf("  support read i/o\n");
	}
	//V4L2_CAP_VIDEO_OVERLAY 支持视频预览（覆盖），指无需帧拷贝，直接存放到显卡的内存，需硬件的DMA支持 -> 实时预览
	//V4L2_CAP_VIDEO_OUTPUT 支持视频输出
	//V4L2_CAP_VBI_CAPTURE  针对老式 模拟显示设备（CRT),很少用
	//V4L2_CAP_RDS_CAPTURE 电台识别	
	return ret;
}
	
//查看 摄像头支持的视频格式
int get_suppurt_video_format(int fd){
	int ret=0;
  printf("List device support video format:  \n");
  struct v4l2_fmtdesc fmtdesc;
  memset(&fmtdesc, 0, sizeof(fmtdesc));
  fmtdesc.index = 0;
  fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
  while ((ret = ioctl(fd, VIDIOC_ENUM_FMT, &fmtdesc)) == 0) //枚举出支持的视频格式
  {
		fmtdesc.index++;
		printf("  { pixelformat = ''%c%c%c%c'', description = ''%s'' }\n",
		          fmtdesc.pixelformat & 0xFF, (fmtdesc.pixelformat >> 8) & 0xFF, (fmtdesc.pixelformat >> 16) & 0xFF, 
		          (fmtdesc.pixelformat >> 24) & 0xFF, fmtdesc.description);
  }		
  return ret;
}	
	
//设置视频格式	
int set_video_format(int fd){	
	int ret=0;
	struct v4l2_format fmt;
	
	memset(&fmt, 0, sizeof(fmt));
	fmt.type                = V4L2_BUF_TYPE_VIDEO_CAPTURE;
	fmt.fmt.pix.width       = VIDEO_WIDTH; 
	fmt.fmt.pix.height      = VIDEO_HEIGHT;
	fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG; //注：如果是支持mipg的摄像头最好(白色小摄像头)
                                               //    普通摄像头 用 V4L2_PIX_FMT_YUYV 它比较麻烦，要用到jpeg库
	fmt.fmt.pix.field       = V4L2_FIELD_INTERLACED;
	ret = ioctl(fd, VIDIOC_S_FMT, &fmt);
	if (ret < 0) {
	    printf("VIDIOC_S_FMT failed (%d)\n", ret);
	    return ret;
	}

	// 获取视频格式
	ret = ioctl(fd, VIDIOC_G_FMT, &fmt);
	if (ret < 0) {
	    printf("VIDIOC_G_FMT failed (%d)\n", ret);
	    return ret;
	}
	// Print Stream Format
	printf("Stream Format Informations:\n");
	printf(" type: %d\n", fmt.type);
	printf(" width: %d\n", fmt.fmt.pix.width);
	printf(" height: %d\n", fmt.fmt.pix.height);
	char fmtstr[8];
	memset(fmtstr, 0, 8);
	memcpy(fmtstr, &fmt.fmt.pix.pixelformat, 4);
	printf(" pixelformat: %s\n", fmtstr);
	printf(" field: %d\n", fmt.fmt.pix.field);
	printf(" bytesperline: %d\n", fmt.fmt.pix.bytesperline);
	printf(" sizeimage: %d\n", fmt.fmt.pix.sizeimage);
	printf(" colorspace: %d\n", fmt.fmt.pix.colorspace);
	printf(" priv: %d\n", fmt.fmt.pix.priv);
	printf(" raw_date: %s\n", fmt.fmt.raw_data);	
	return ret;
}

//申请帧缓冲区
int request_buf(int fd){
	int ret=0;
	int i;
	struct v4l2_buffer vbuf;
	
	memset(&reqbufs, 0, sizeof(struct v4l2_requestbuffers));
	reqbufs.count	= REQBUFS_COUNT;					//缓存区个数
	reqbufs.type	= V4L2_BUF_TYPE_VIDEO_CAPTURE;
	reqbufs.memory	= V4L2_MEMORY_MMAP;					//设置操作申请缓存的方式:映射 MMAP
	ret = ioctl(fd, VIDIOC_REQBUFS, &reqbufs); //向驱动申请缓存	
	if (ret == -1) {	
		printf("VIDIOC_REQBUFS fail  %s %d\n",__FUNCTION__,__LINE__);
		return ret;
	}
	//循环映射并入队 -> 让内核 和 应用的虚拟地址空间 指向同一片物理内存
	for (i = 0; i < reqbufs.count; i++){
		//真正获取缓存的地址大小
		memset(&vbuf, 0, sizeof(struct v4l2_buffer));
		vbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
		vbuf.memory = V4L2_MEMORY_MMAP;
		vbuf.index = i;
		ret = ioctl(fd, VIDIOC_QUERYBUF, &vbuf);
		if (ret == -1) {
		  printf("VIDIOC_QUERYBUF fail  %s %d\n",__FUNCTION__,__LINE__);
			return ret;
		}
		//映射缓存到用户空间,通过mmap讲内核的缓存地址映射到用户空间,并切和文件描述符fd相关联
		bufs[i].length = vbuf.length;
		bufs[i].start = mmap(NULL, vbuf.length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, vbuf.m.offset);
		if (bufs[i].start == MAP_FAILED) {
			printf("mmap fail  %s %d\n",__FUNCTION__,__LINE__);
			return ret;
		}
		//每次映射都会入队,放入缓冲队列
		vbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
		vbuf.memory = V4L2_MEMORY_MMAP;
		ret = ioctl(fd, VIDIOC_QBUF, &vbuf);
		if (ret == -1) {
			printf("VIDIOC_QBUF err %s %d\n",__FUNCTION__,__LINE__);
			return ret;
		}
	}
	return ret;
}	

//启动采集
int start_camera(int fd)
{
	int ret;
	
	enum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
	ret = ioctl(fd, VIDIOC_STREAMON, &type); //ioctl控制摄像头开始采集
	if (ret == -1) {
		perror("start_camera");
		return -1;
	}
	fprintf(stdout, "camera->start: start capture\n");
	return 0;
}

//出队取一帧图像
int camera_dqbuf(int fd, void **buf, unsigned int *size, unsigned int *index){
	int ret=0;
	struct v4l2_buffer vbuf;
	vbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
	vbuf.memory = V4L2_MEMORY_MMAP;
	ret = ioctl(fd, VIDIOC_DQBUF, &vbuf);	//出队,也就是从用户空间取出图片
	if (ret == -1) {
		perror("camera dqbuf ");
		return -1;
	}	
	*buf = bufs[vbuf.index].start;
	*size = vbuf.bytesused;
	*index = vbuf.index;	
	return ret;
}
	
//入队归还帧缓冲	
int camera_eqbuf(int fd, unsigned int index)
{
	int ret;
	struct v4l2_buffer vbuf;

	vbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
	vbuf.memory = V4L2_MEMORY_MMAP;
	vbuf.index = index;
	ret = ioctl(fd, VIDIOC_QBUF, &vbuf);		//入队
	if (ret == -1) {
		perror("camera->eqbuf");
		return -1;
	}

	return 0;
}
	
//停止视频采集	
int camera_stop(int fd)
{
	int ret;
	enum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

	ret = ioctl(fd, VIDIOC_STREAMOFF, &type);
	if (ret == -1) {
		perror("camera->stop");
		return -1;
	}
	fprintf(stdout, "camera->stop: stop capture\n");

	return 0;
}

//退出释放资源
int camera_exit(int fd)
{
	int i;
	int ret=0;
	struct v4l2_buffer vbuf;
	vbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
	vbuf.memory = V4L2_MEMORY_MMAP;
	
	//出队所有帧缓冲
	for (i = 0; i < reqbufs.count; i++) {
		ret = ioctl(fd, VIDIOC_DQBUF, &vbuf);
		if (ret == -1)
			break;
	}
	
	//取消所有帧缓冲映射
	for (i = 0; i < reqbufs.count; i++)
		munmap(bufs[i].start, bufs[i].length);
	fprintf(stdout, "camera->exit: camera exit\n");
	return ret;
}	
	
int main(int argc, char**argv)
{ 
	int ret;
	char *jpeg_ptr = NULL;
	unsigned int size;
	unsigned int index;

	int fd = open("/dev/video0", O_RDWR, 0);
	if (fd < 0) {
		printf("Open /dev/video0 failed\n");
		return -1;
	} 
	get_capability(fd); //查看 摄像头设备的能力	
	get_suppurt_video_format(fd); //查看 摄像头支持的视频格式
	set_video_format(fd); //设置视频格式	
	request_buf(fd); //申请帧缓冲区
	start_camera(fd); //启动采集
	camera_dqbuf(fd, (void **)&jpeg_ptr, &size, &index); //出队取一帧图像

	int pixfd = open("1.jpg", O_WRONLY|O_CREAT, 0666);//打开文件（无则 创建一个空白文件）
	write(pixfd, jpeg_ptr, size); //将一帧图像写入文件

	camera_eqbuf(fd, index); //入队归还帧缓冲 
	camera_stop(fd); //关掉摄像头

	camera_exit(fd);  //退出释放资源
	close(fd);
	return 0;
}	
```



#### 3、V4L2源码分析√

##### ①英伟达 相机软件架构√

![摄像头框架](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\摄像头框架.png)

```c
JetPack SDK  //用于构建AI应用程序的最全面的解决方案	
      //见https://developer.nvidia.com/embedded/jetpack 多媒体相关应用库等 都集成到jetpack包中 
      // https://developer.nvidia.com/zh-cn/embedded/jetpack   可下载整机的sd卡镜像（如jetbot-043_nano-4gb-jp45.zip）
    
//包括uboot、内核、根文件系统
BSP SDK  //https://developer.nvidia.com/embedded/linux-tegra-r3261  BSP包下载
         //多媒体 BSP文档 见https://docs.nvidia.com/jetson/archives/l4t-archived/l4t-3261/index.html 的多媒体章节
	                   
库源码见 // ~/bsp/Linux_for_Tegra/source/public/gst-nvv4l2camera_src.tbz2 等，再编译安装bsp包生成烧录镜像时
         //已安装到板子 /usr/lib/aarch64-linux-gnu/tegra/libnvcamv4l2.so  等
         //libargus 板子上已集成 见 /usr/src/jetson_multimedia_api/argus
         //官方示例文档 https://docs.nvidia.com/jetson/archives/l4t-multimedia-archived/l4t-multimedia-3261/l4t_mm_00_video_decode.html
    
         //$ cd /usr/src/jetson_multimedia_api/samples  //官方已把示例，集成到BSP整机镜像里
```

##### ②对上: 管理V4L2设备，向应用暴露控制接口√

```c
//include/media/v4l2-dev.h  对上: 管理v4l2设备，向应用暴露控制接口
// 定义视频设备对象: 创建 /dev/video0, 把操作暴露给应用层，管理v4l2设备
struct video_device   
{
    const struct v4l2_file_operations *fops; //v4l2设备的文件操作
    struct cdev *cdev; //继承于 字符设备
    struct v4l2_device *v4l2_dev;
    struct vb2_queue *queue; //videobuf2 的队列 -> 构建环形缓冲区(无锁化)
    const struct v4l2_ioctl_ops *ioctl_ops;  //v4l2的ioctl操作集
};

//v4l2设备的文件操作（暴露给应用层）
struct v4l2_file_operations {
    struct module *owner;
    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
    unsigned int (*poll) (struct file *, struct poll_table_struct *);
    long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
    unsigned long (*get_unmapped_area) (struct file *, unsigned long,
                unsigned long, unsigned long, unsigned long);
    int (*mmap) (struct file *, struct vm_area_struct *);
    int (*open) (struct file *);
    int (*release) (struct file *);
};

//include/media/v4l2-ioctl.h
struct v4l2_ioctl_ops {
    /* ioctl callbacks */
    //查询驱动能力的回调函数， 对应V4L2 应用的API  ioctl(fd, VIDIOC_QUERYCAP, &capability);
    /* VIDIOC_QUERYCAP handler */
    int (*vidioc_querycap)(struct file *file, void *fh,
                   struct v4l2_capability *cap);
    ....               
}
```

##### ③管理所有V4L2子设备(以链表方式)√

```
//include/media/v4l2-device.h
struct v4l2_device { //定义对象 v4l2设备: 是v4l2子设备的组合
    struct device *dev;
    struct list_head subdevs;
    spinlock_t lock;
    char name[V4L2_DEVICE_NAME_SIZE];
    void (*notify)(struct v4l2_subdev *sd,
            unsigned int notification, void *arg);
    struct v4l2_ctrl_handler *ctrl_handler;
};
```

##### ④对下: 被驱动继承 实现具体内容√

```c
//include/media/v4l2-subdev.h 对下: 被驱动继承 实现具体内容
//定义对象 v4l2子设备 
struct v4l2_subdev { 
    struct list_head list;
    struct v4l2_device *v4l2_dev; //关联 v4l2设备
    const struct v4l2_subdev_ops *ops; //子设备操作集
    const struct v4l2_subdev_internal_ops *internal_ops;//子设备的内部操作集
    struct v4l2_ctrl_handler *ctrl_handler;
    char name[V4L2_SUBDEV_NAME_SIZE];
    struct video_device *devnode; //关联 video设备
    struct device *dev; 
};

//V4L2 子设备操作集
struct v4l2_subdev_ops {
    const struct v4l2_subdev_core_ops   *core;  //核心操作
    const struct v4l2_subdev_tuner_ops  *tuner; //无线电模式下操作
    const struct v4l2_subdev_audio_ops  *audio; //音频操作
    const struct v4l2_subdev_video_ops  *video; //视频操作
    const struct v4l2_subdev_vbi_ops    *vbi;
    const struct v4l2_subdev_ir_ops     *ir;
    const struct v4l2_subdev_sensor_ops *sensor;
    const struct v4l2_subdev_pad_ops    *pad;
}; 
```

##### ⑤USB摄像头 通用 V4L2 接口√

```c
//drivers/media/usb/uvc/uvc_v4l2.c	 USB Video Class driver USB摄像头 通用 v4l2 API
static int uvc_ioctl_dqbuf(struct file *file, void *fh, struct v4l2_buffer *buf)
{
	struct uvc_fh *handle = fh;
	struct uvc_streaming *stream = handle->stream;

	if (!uvc_has_privileges(handle))
		return -EBUSY;

	return uvc_dequeue_buffer(&stream->queue, buf,
				  file->f_flags & O_NONBLOCK);
}

const struct v4l2_ioctl_ops uvc_ioctl_ops = { //应用层  ioctl(fd, VIDIOC_QUERYCAP, &cap) 时会回调它
	.vidioc_querycap = uvc_ioctl_querycap,
	.vidioc_reqbufs = uvc_ioctl_reqbufs,
	.vidioc_querybuf = uvc_ioctl_querybuf,
	.vidioc_qbuf = uvc_ioctl_qbuf,
	.vidioc_dqbuf = uvc_ioctl_dqbuf,
	.vidioc_streamon = uvc_ioctl_streamon,
};	
	
const struct v4l2_file_operations uvc_fops = {  //被驱动uvc_driver.c关联
	.open		= uvc_v4l2_open,  //应用层  open("/dev/video0", O_RDWR, 0); 时会回调它
	.release	= uvc_v4l2_release,
	.unlocked_ioctl	= video_ioctl2,
	.read		= uvc_v4l2_read,
	.mmap		= uvc_v4l2_mmap,
	.poll		= uvc_v4l2_poll,
};	

```

##### ⑥USB摄像头驱动（免驱）√

```c
//drivers/media/usb/uvc/uvc_driver.c  USB摄像头驱动（免驱）  -> 切入点（插入usb摄像头，内核会打印该驱动里的信息)
板子插入usb摄像 /*看到下面打印信息 表示内核有识别到摄像头
   uvcvideo 1-2.3:1.0: Entity type for entity Extension 4 was not initialized!
[  187.424230] uvcvideo 1-2.3:1.0: Entity type for entity Extension 3 was not initialized!
[  187.432456] uvcvideo 1-2.3:1.0: Entity type for entity Processing 2 was not initialized!
[  187.440613] uvcvideo 1-2.3:1.0: Entity type for entity Camera 1 was not initialized!
[  187.756521] tegra-i2c 7000c400.i2c: no acknowledge from address 0x3c
[  187.843185] usb 1-2.3: 3:1: cannot get freq at ep 0x86
[  188.232784] usb 1-2.3: 3:2: cannot get freq at ep 0x86
[  188.622932] usb 1-2.3: 3:3: cannot get freq at ep 0x86
[  190.578653] usb 1-2.3: Warning! Unlikely big volume range (=4096), cval->res is probably wrong.
[  190.588574] usb 1-2.3: [7] FU [Mic Capture Volume] ch = 1, val = 0/4096/1

$ dmesg|grep uvc   应用层打印信息有限，通过查看内核信息，可知道更多内核驱动信息 
[   90.640845] uvcvideo: Found UVC 1.00 device Photry PC230A QHD Webcam (1bcd:4002)  -> 对应uvc_driver.c 里2144     uvc_printk(KERN_INFO, "Found UVC %u.%02x device %s (%04x:%04x)\n"
[   90.660384] uvcvideo 1-2.1:1.0: Entity type for entity Extension 4 was not initialized!
[   90.668526] uvcvideo 1-2.1:1.0: Entity type for entity Extension 3 was not initialized!
[   90.676904] uvcvideo 1-2.1:1.0: Entity type for entity Processing 2 was not initialized!
[   90.685205] uvcvideo 1-2.1:1.0: Entity type for entity Camera 1 was not initialized!
[   90.693669] usbcore: registered new interface driver uvcvideo
 */
  
static int uvc_register_video(struct uvc_device *dev,
		struct uvc_streaming *stream)
{
	
	vdev->fops = &uvc_fops;
	vdev->ioctl_ops = &uvc_ioctl_ops;	
	
}  
  
static int uvc_probe(struct usb_interface *intf,
		     const struct usb_device_id *id)
{
	struct usb_device *udev = interface_to_usbdev(intf);
	struct uvc_device *dev;  /*定义uvc设备
	//drivers/media/usb/uvc/uvcvideo.h
		struct uvc_device {
			struct usb_device *udev;
			struct usb_interface *intf;
			struct v4l2_device vdev;  //继承于 v4l2_device
			struct usb_host_endpoint *int_ep;

			struct input_dev *input;
			char input_phys[64];
		};	
	 */
	dev->udev = usb_get_dev(udev);	
	uvc_printk(KERN_INFO, "Found UVC %u.%02x device %s (%04x:%04x)\n",
		dev->uvc_version >> 8, dev->uvc_version & 0xff,
		udev->product ? udev->product : "<unnamed>",
		le16_to_cpu(udev->descriptor.idVendor),
		le16_to_cpu(udev->descriptor.idProduct));	
}
  	
struct uvc_driver uvc_driver = {
	.driver = {
		.name		= "uvcvideo",
		.probe		= uvc_probe,
		.id_table	= uvc_ids,
	},
};	

static int __init uvc_init(void)
{
	ret = usb_register(&uvc_driver.driver);
	printk(KERN_INFO DRIVER_DESC " (" DRIVER_VERSION ")\n");
	return 0;
}
module_init(uvc_init);	
```

#### 4、平台摄像头框架

##### ①结构体图谱√

![摄像头结构体图谱](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\摄像头结构体图谱.png)

###### (1)初衷

![摄像头初衷](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\摄像头初衷.png)

###### (2)V4L2核心框架

![v4l2核心框架](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\v4l2核心框架.png)

###### (3)平台摄像头框架之视频设备

![摄像头结构体图谱](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\摄像头结构体图谱.png)

###### (4)平台摄像头框架之VI设备

###### (5)源码目录

```c
drivers/media/v4l2-core/ // v4l2 核心框架： 构建内核中标准视频设备驱动的框架
                         //为应用的视频操作提供统一的接口函数	
drivers/media/platform/  //不同平台的soc驱动(如英伟达，三星)
                         //不同平台,它们对视频 vi进入SOC内部处理各家都不一样的
//不同类型的v4l2子设备
drivers/media/usb/     //usb接口的摄像头驱动   
drivers/media/i2c/     //i2c接口的摄像头驱动  
drivers/media/spi/     //spi接口的摄像头驱动
drivers/media/pci/     //pci接口的摄像头驱动
drivers/media/adio/    //无线电设备 
drivers/media/tuners/  //调谐收音设备                 
drivers/media/mmc      //mmc接口的设备
       
//英伟达平台(tegra)独立出来驱动代码 
//注：它由原厂驱动工程师提供，二次开发时，要参考它，
//开发针对不同平台的摄像头驱动，这也是摄像头驱动开发难点所
nvidia/drivers/media/i2c/  //i2c接口的摄像头驱动
         //如imx219.c的摄像头驱动，它是根据英伟达平台定制的驱动。
         //如果你的摄像头该目录没有，需要按英伟达平台框架，重新改写。
nvidia/drivers/media/platform/tegra/camera //独立出来tegra平台摄像头通用代码
nvidia/drivers/media/platform/tegra-vivid/ //虚拟的摄像头的测试驱动
nvidia/drivers/media/platform/tegra/vi  //视频输入模块模块
```

##### ②CSI摄像头驱动源码切入√

###### (1)定义设备类

```c
//: D:\BaiduNetdiskDownload\嵌入式AI班资料\10.内核驱动\kernel_src\kernel\nvidia\drivers\media\i2c\imx219.c
struct imx219 { 
	struct i2c_client	*i2c_client; //继承，作为i2c设备的客户端
	struct v4l2_subdev	*subdev;   //继承, 作为v4l2的子设备
	u16	fine_integ_time;
	u32	frame_length;
	struct camera_common_data *s_data; //常用的摄像头数据
	struct tegracam_device	  *tc_dev; //继承于英伟达的tegra摄像头设备
};
```

###### (2)设备树匹配检测

```c
static const struct i2c_device_id imx219_id[] = {
  { "imx219", 0 }, //匹配设备树里的子节点（第二个参数为辅助信息driver_data，默认为0）
  { } 
};
MODULE_DEVICE_TABLE(i2c, imx219_id);

static const struct of_device_id imx219_of_match[] = { //定义匹配的平台设备id列表
   { .compatible = "nvidia,imx219", }, //设置与驱动匹配的设备树节点名 
       //见tegra210-camera-rbpcv2-dual-imx219.dtsi
   { },//注：空括号用于判断数组结束不能省略
};
MODULE_DEVICE_TABLE(of, imx219_of_match);

static struct i2c_driver imx219_i2c_driver = { //定义 i2c驱动
   .driver = {
   .name = "imx219", //驱动名
   .of_match_table = of_match_ptr(imx219_of_match),//设置 与驱动匹配的平台设备表(一个驱动可匹配多个设备)，使用设备树编码的设备信息,进行驱动和设备匹配
   },
   .probe = imx219_probe, //驱动与设备树匹配成功，才会调用probe函数，进行初始化
   .remove = imx219_remove,
   .id_table = imx219_id, //使用C语言编码的设备信息进行驱动和设备匹配（它的命名相比of_match_table 里厂商名+设备名，只需设备名如imx219即可)
  //注：驱动和设备匹配方式有多种，优先用of_match_table,再用id_table匹配，一般平台设备只需填充of_match_table即可
  // 但 i2c的匹配不一样，of_match_table和id_table都需填充才行
};
module_i2c_driver(imx219_i2c_driver); //声明驱动入口 为i2c驱动

MODULE_DESCRIPTION("Media Controller driver for Sony IMX219"); //驱动的描述：是用于imx219多媒体控制的驱动
MODULE_AUTHOR("NVIDIA Corporation"); //驱动作者：英伟达公司
MODULE_LICENSE("GPL v2"); //驱动的免费开源声明
```

###### (3)探测初始化

```c
//----摄像头的板子安装
static int imx219_board_setup(struct imx219 *priv)
{
	if (pdata->mclk_name) {
		err = camera_common_mclk_enable(s_data); //使能提供给相机的时钟源
	}
	err = imx219_power_on(s_data); //设备上电

        //读设备的id，检测是否正确 -> 正确这设备硬件基本没问题。
	/* Probe sensor model id registers */
	err = imx219_read_reg(s_data, IMX219_MODEL_ID_ADDR_MSB, &reg_val[0]);
	err = imx219_read_reg(s_data, IMX219_MODEL_ID_ADDR_LSB, &reg_val[1]);
	if (!((reg_val[0] == 0x02) && reg_val[1] == 0x19))
		dev_err(dev, "%s: invalid sensor model id: %x%x\n",
			__func__, reg_val[0], reg_val[1]);

         //获取传感器精细积分时间 -> 曝光控制
	/* Sensor fine integration time */
	err = imx219_get_fine_integ_time(priv, &priv->fine_integ_time);

err_reg_probe:
	imx219_power_off(s_data);
err_power_on:
	if (pdata->mclk_name)
		camera_common_mclk_disable(s_data);
done:
	return err;
}	

/*regmap机制: 寄存器的缓存映射  -> 解决I2C/SPI 等中冗余函数问题 
//I2C充斥 基于i2c_transfer 的冗余代码 如 	
static int mpu6050_read_byte(struct i2c_client *client, unsigned char reg)
{
	struct i2c_msg msg[2] = {   //设定 I2C消息格式
	{client->addr, 0, 1, txbuf},       //0         指定i2c设备里的寄存器地址   txbuf 存放其地址
	{client->addr, I2C_M_RD, 1, rxbuf} //I2C_M_RD  表示读i2c设备里该寄存器的数据
	};
	ret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg)); //传输I2C消息
	if (ret < 0) {
	return rxbuf[0];
}	

//有了regmap 后，通过regmap_config的映射配置后，只需调统一的接口regmap_read regmap_write即可，
regmap内缓存类型 //数组(flat): 寄存器很少时，用该类型来缓存寄存器值
              //LZO 压缩：在数组之上加了压缩来节约内存
              //红黑树(rbtree): 红黑树特性就是索引快，所以当设备寄存器数量比较大,要求延时低时,用它
   
}
*/
static const struct regmap_config sensor_regmap_config = { //对I2C设备加regmap 映射
	.reg_bits = 16, //寄存器的地址位宽 为16位
	.val_bits = 8,  //地址位宽位 8位
	.cache_type = REGCACHE_RBTREE,//缓存类型设为红黑树
	.use_single_rw = true,
};

//---文件操作 勾连 具体实现
//摄像头的常用传感器操作(CSI I2C + GPIO控制)
static struct camera_common_sensor_ops imx219_common_ops = {
	.numfrmfmts = ARRAY_SIZE(imx219_frmfmt),
	.frmfmt_table = imx219_frmfmt,
	.power_on = imx219_power_on,   //开机
	.power_off = imx219_power_off, //关机
	.write_reg = imx219_write_reg, 
	.read_reg = imx219_read_reg, //读寄存器
	.parse_dt = imx219_parse_dt, //设备树解析
	.power_get = imx219_power_get,
	.power_put = imx219_power_put,
	.set_mode = imx219_set_mode,
	.start_streaming = imx219_start_streaming, //开启视频流采集
	.stop_streaming = imx219_stop_streaming, //停止视频流采集
};


static int imx219_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	dev_dbg(&client->dev, "%s:\n", __func__);
	return 0;
}

static const struct v4l2_subdev_internal_ops imx219_subdev_internal_ops = {
	.open = imx219_open,
};

static int imx219_probe(struct i2c_client *client,const struct i2c_device_id *id)
{
	struct device *dev = &client->dev;
	struct tegracam_device *tc_dev;  //定义 tegra摄像头设备对象（英伟达自定义的）
	struct imx219 *priv;  //定义设备对象 
	int err;

	dev_dbg(dev, "probing v4l2 sensor at addr 0x%0x\n", client->addr);

	if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node) //异常检测：不是平台设备则退出
		return -EINVAL;

	priv = devm_kzalloc(dev,sizeof(struct imx219), GFP_KERNEL);//为设备对象分配空间
        //为tegra摄像头设备对象 分配空间
	tc_dev = devm_kzalloc(dev,sizeof(struct tegracam_device), GFP_KERNEL); 


	priv->i2c_client = tc_dev->client = client; //初始化 设备对象的属性 i2c_client 
	//初始化 tegra摄像头设备的属性 
	tc_dev->dev = dev;
	strncpy(tc_dev->name, "imx219", sizeof(tc_dev->name)); //设置设备的名字
	tc_dev->dev_regmap_config = &sensor_regmap_config;  //对设备的i2c操作 进行 regmap 映射
	tc_dev->sensor_ops = &imx219_common_ops;  //设置设备的传感器操作
	tc_dev->v4l2sd_internal_ops = &imx219_subdev_internal_ops; //设置设置的v4l2子设备的内部操作
	tc_dev->tcctrl_ops = &imx219_ctrl_ops; //设置设备的控制操作

	err = tegracam_device_register(tc_dev); //注册为 tegra摄像头设备 
             //具体实现见 nvidia/drivers/media/platform/tegra/camera/tegracam_core.c
	    //通过注册方式，回调某函数，完成对象的指针的初始化关联
	priv->tc_dev = tc_dev; //初始化 设备对象的属性 tc_dev -> 继承于tegra摄像头设备(英伟达自定义的) 
	priv->s_data = tc_dev->s_data;
	priv->subdev = &tc_dev->s_data->subdev;
	tegracam_set_privdata(tc_dev, (void *)priv);
	err = imx219_board_setup(priv); //摄像头的板子安装

        //注册为 v4l2子设备（注册就是和上层的回调指针勾连，方便应用层回调）
        //如 应用打开/dev/video0后 -> video_device  ->  v4l2-device -> v4l2_subdev_video_ops
	err = tegracam_v4l2subdev_register(tc_dev, true);  
	dev_dbg(dev, "detected imx219 sensor\n");

	return 0;
}
```

###### (4)实现需要的文件操作

```c
//写相机寄存器（用regmap实现）
static inline int imx219_write_reg(struct camera_common_data *s_data,
    u16 addr, u8 val)
{
    err = regmap_write(s_data->regmap, addr, val);
    return err;
}

static int imx219_set_gain(struct tegracam_device *tc_dev, s64 val)
{
	struct camera_common_data *s_data = tc_dev->s_data;
	struct device *dev = s_data->dev;
	const struct sensor_mode_properties *mode =
		&s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];

	int err = 0;
	imx219_reg gain_reg;
	s16 gain;

	if (val < mode->control_properties.min_gain_val)
		val = mode->control_properties.min_gain_val;
	else if (val > mode->control_properties.max_gain_val)
		val = mode->control_properties.max_gain_val;

	/* translate value (from normalized analog gain) */
	gain = (s16)((256 * mode->control_properties.gain_factor) / val);
	gain = 256 - gain;

	if (gain < IMX219_MIN_GAIN)
		gain = IMX219_MAX_GAIN;
	else if (gain > IMX219_MAX_GAIN)
		gain = IMX219_MAX_GAIN;

	dev_dbg(dev, "%s: val: %lld (/%d) [times], gain: %u\n",
		__func__, val, mode->control_properties.gain_factor, gain);

	imx219_get_gain_reg(&gain_reg, (u8)gain);
	err = imx219_write_reg(s_data, gain_reg.addr, gain_reg.val);

	return 0;
}

//相机的控制操作(如 亮度 曝光 帧率)
static struct tegracam_ctrl_ops imx219_ctrl_ops = {
	.numctrls = ARRAY_SIZE(ctrl_cid_list),
	.ctrl_cid_list = ctrl_cid_list,
	.set_gain = imx219_set_gain, //增益设置 -> 调节相机亮度
	.set_exposure = imx219_set_exposure, //曝光设置
	.set_frame_rate = imx219_set_frame_rate, //帧率设置
	.set_group_hold = imx219_set_group_hold, //组保持设置 ->   曝光设定需要操作许多寄存器（曝光时间，每帧行数，增益），这些必须在同一帧完成更新
};


//相机上电流程：avdd ->  iovdd -> dvdd
static int imx219_power_on(struct camera_common_data *s_data)
{
	int err = 0;
	struct camera_common_power_rail *pw = s_data->power;
	struct camera_common_pdata *pdata = s_data->pdata;
	struct device *dev = s_data->dev;

	dev_dbg(dev, "%s: power on\n", __func__);
	if (pdata && pdata->power_on) {
		err = pdata->power_on(pw);
		if (err)
			dev_err(dev, "%s failed.\n", __func__);
		else
			pw->state = SWITCH_ON;
		return err;
	}

	if (pw->reset_gpio) {
		if (gpio_cansleep(pw->reset_gpio))
			gpio_set_value_cansleep(pw->reset_gpio, 0);
		else
			gpio_set_value(pw->reset_gpio, 0);
	}

	if (unlikely(!(pw->avdd || pw->iovdd || pw->dvdd)))
		goto skip_power_seqn;

	usleep_range(10, 20);

	if (pw->avdd) {
	err = regulator_enable(pw->avdd); //电源使能输出  avdd: 模拟电源，主要给感光区和ADC供电，要求比较干净；
	}

	if (pw->iovdd) {  
	err = regulator_enable(pw->iovdd); //电源使能输出 iovdd:数字IO电源，给I2C和DVP供电。
	}

	if (pw->dvdd) {
	  err = regulator_enable(pw->dvdd);  //电源使能输出 dvdd: 数字电源，主要是给ISP供电；
	}

	usleep_range(10, 20);

skip_power_seqn:
	if (pw->reset_gpio) {
		if (gpio_cansleep(pw->reset_gpio))
			gpio_set_value_cansleep(pw->reset_gpio, 1);
		else
			gpio_set_value(pw->reset_gpio, 1);
	}

	/* Need to wait for t4 + t5 + t9 time as per the data sheet */
	/* t4 - 200us, t5 - 21.2ms, t9 - 1.2ms */
	usleep_range(23000, 23100);
	pw->state = SWITCH_ON;
	return 0;

}

//按表写寄存器（用regmap来实现）
static int imx219_write_table(struct imx219 *priv, const imx219_reg table[])
{
	  //用regmap 映射方式 按表写寄存器
    return regmap_util_write_table_8(priv->s_data->regmap, table, NULL, 0,
        IMX219_TABLE_WAIT_MS, IMX219_TABLE_END);
}


//3.解析设备树（比较特殊，不是在probe时传参时去解析设备树，而是通过of_match_device)
static struct camera_common_pdata *imx219_parse_dt(
	struct tegracam_device *tc_dev)
{
	struct device *dev = tc_dev->dev;
	struct device_node *np = dev->of_node;
	struct camera_common_pdata *board_priv_pdata;
	const struct of_device_id *match;
	struct camera_common_pdata *ret = NULL;
	int err = 0;
	int gpio;

	match = of_match_device(imx219_of_match, dev);  //通过 imx219_of_match 去找匹配的设备树节点

	board_priv_pdata = devm_kzalloc(dev,
		sizeof(*board_priv_pdata), GFP_KERNEL);

	gpio = of_get_named_gpio(np, "reset-gpios", 0); //获取设备的 reset-gpios属性的gpio值 （见 reset-gpios = <&gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;）
	board_priv_pdata->reset_gpio = (unsigned int)gpio;


        //查找mclk  avdd-reg dvdd-reg 等设备树的属性，如果没有，它才有独立电源方式启动
	err = of_property_read_string(np, "mclk", &board_priv_pdata->mclk_name);
	err = of_property_read_string(np, "avdd-reg",
		&board_priv_pdata->regulators.avdd);
	err |= of_property_read_string(np, "iovdd-reg",
		&board_priv_pdata->regulators.iovdd);
	err |= of_property_read_string(np, "dvdd-reg",
		&board_priv_pdata->regulators.dvdd);
	return board_priv_pdata;

}

static int imx219_set_mode(struct tegracam_device *tc_dev)
{
	struct imx219 *priv = (struct imx219 *)tegracam_get_privdata(tc_dev);
	struct camera_common_data *s_data = tc_dev->s_data;
	err = imx219_write_table(priv, mode_table[IMX219_MODE_COMMON]);
	err = imx219_write_table(priv, mode_table[s_data->mode]);
	return 0;
}

static int imx219_start_streaming(struct tegracam_device *tc_dev)
{
	struct imx219 *priv = (struct imx219 *)tegracam_get_privdata(tc_dev);
	return imx219_write_table(priv, mode_table[IMX219_START_STREAM]);
}

static int imx219_stop_streaming(struct tegracam_device *tc_dev)
{
	int err;
	struct imx219 *priv = (struct imx219 *)tegracam_get_privdata(tc_dev);

	err = imx219_write_table(priv, mode_table[IMX219_STOP_STREAM]);/* 按表 写 相机的寄存器
	 //nvidia/drivers/media/i2c/imx219_mode_tbls.h
	 struct reg_8 {
          u16 addr;
          u8 val;
	};
   #define IMX219_TABLE_WAIT_MS    0
	 #define IMX219_TABLE_END    1

	 #define imx219_reg struct reg_8

		static imx219_reg imx219_start_stream[] = {
		    {0x0100, 0x01},
		    {IMX219_TABLE_WAIT_MS, 3},
		    {IMX219_TABLE_END, 0x00}
		};

		static imx219_reg *mode_table[] = { 
		    [IMX219_MODE_3264x2464_21FPS] = imx219_mode_3264x2464_21fps,
		    [IMX219_MODE_3264x1848_28FPS] = imx219_mode_3264x1848_28fps,
		    [IMX219_MODE_1920x1080_30FPS] = imx219_mode_1920x1080_30fps,
		    [IMX219_MODE_1640x1232_30FPS] = imx219_mode_1640x1232_30fps,
		    [IMX219_MODE_1280x720_60FPS] = imx219_mode_1280x720_60fps,

		    [IMX219_MODE_COMMON]  = imx219_mode_common,
		    [IMX219_START_STREAM]  = imx219_start_stream,
		    [IMX219_STOP_STREAM]  = imx219_stop_stream,
		};
	   */
	usleep_range(50000, 51000);
	return err;
}
```

###### (5)文件操作2



##### ③电路图芯片手册√

```c
IPI //移动行业处理器接口(Mobile Industry Processor Interface) 主要包括，CSI+DSI
DSI //显示接口	
CSI //摄像头接口(Camera Serial Interface)

//1. 摄像头排线旁的丝印 "CAM0" "J13" ->  CSI0_D0_P  CAM_I2C_SCL 
      注 //电路图要看新的 2.3板子B01板的电路图P3449_B01_OrCAD_schematics.pdf
                    J13      J49   //板子上丝印 有两个CSI插槽，可接2个摄像头(cam0,cam1)
                    cam0     cam1
                    ----     ----
                    |  |     |  |  -- D0_N  //第一条数据通道(采用差分信号，抗干扰强)
                    |  |     |  |  -- D0_P 
               CSI0 |  | CSI2|  |  -- D1_N  //第二条数据通道(采用差分信号，抗干扰强)
                    |  |     |  |  -- D1_P
                    |  |     |  |  -- CLK_N //数据传输的时钟线(采用差分信号，抗干扰强)
                    ----     ----  -- CLK_P 
                     | |     | |
   CAM_I2C_SCL ------| |-----| |   //i2c是共用
   CAM_I2C_DAT -----------------
   CAM_MUX_SEL -------|-------|    //共用的i2c，切换开关 -> GPIO-6
   
   CAM0_PWDN  //摄像头0的电源控制
   CAM0_MCLK  //给摄像头提供 时钟源
   
//2.  CAM_I2C_SCL -> 4.3 管脚复用的映射表 Jetson_Nano_Module_Pinmux_Config_Template.xlsm
	  CAM          GPIO         SFIO1
      CAM_I2C_SCL   GPIO3_PS.02   I2CVI_CLK  //-> 设备树 i2c7: i2c@546c0000 里的  scl-gpio = <&gpio TEGRA_GPIO(S, 2) 0>;
      CAM_I2C_SDA   GPIO3_PS.03   I2CVI_DAT
 			    
  CAM_MUX_SEL -> GPIO06 GPIO3_PI.00    -> //-> 设备树  #define CAM_I2C_MUX TEGRA_GPIO(I, 0)
  CAM0_PWDN   ->        GPIO3_PS.07  //-> 设备树  cam1_pwdn_ps7
  CAM1_PWDN   ->        GPIO3_PT.00  //-> 设备树  cam2_pwdn_pt0
  
  CAM0_MCLK   ->        GPIO3_PS.00  //-> 设备树 cam1_mclk_ps0
  CAM1_MCLK   ->        GPIO3_PS.01 
```

##### ④设备树分析√

###### (1)入口

```c
帮助文档 //见https://docs.nvidia.com/jetson/archives/l4t-archived/l4t-3261/index.html 的相机开发

{//tegra210-p3448-0002-p3449-0000-b00.dts
#include "porg-platforms/tegra210-porg-camera-rbpcv2-dual-imx219.dtsi"
}	
```

###### (2)摄像头I2C复用

```c
//tegra210-porg-camera-rbpcv2-dual-imx219.dtsi
//platform/t210/porg/kernel-dts/porg-platforms/tegra210-porg-camera-rbpcv2-dual-imx219.dtsi	
#include "tegra210-camera-rbpcv2-dual-imx219.dtsi"

#define CAM1_PWDN		TEGRA_GPIO(S, 7)
#define CAM2_PWDN		TEGRA_GPIO(T, 0)
#define CAM_I2C_MUX TEGRA_GPIO(I, 0) // NFC_EN GPIO 对应电路图的CAM_MUX_SEL 是2个摄像头共用i2c时，的选择脚。

cam_i2cmux { //两个摄像头复用一个i2c
	compatible = "i2c-mux-gpio";
	#address-cells = <1>;  //设置子节点"reg"属性的 首地址 占1个单位(即32位)
	#size-cells = <0>; //设置子节点"reg"属性的 地址长度 为零 ，  即子节点里reg只有一个参数，做id用
	mux-gpios = <&gpio CAM_I2C_MUX GPIO_ACTIVE_HIGH>; //两摄像头切换脚
	i2c-parent = <&i2c7>; //指定的复用的I2C总线为I2C7(由  CAM_I2C_SCL追踪而得)
	i2c@0 { 
		reg = <0>; //reg id为零时，代表切换到摄像头1 工作时使用
		#address-cells = <1>;
		#size-cells = <0>;
		rbpcv2_imx219_a@10 {
			reset-gpios = <&gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;  //摄像头1的电源复位脚
		};
	};
	i2c@1 {   //reg id为1时，代表切换到摄像头2 工作时使用
		reg = <1>;
		#address-cells = <1>;
		#size-cells = <0>;
		rbpcv2_imx219_e@10 {
			reset-gpios = <&gpio CAM2_PWDN GPIO_ACTIVE_HIGH>; //摄像头2的电源复位脚
		};
	};
};
```

###### (3)摄像头的I2C  CSI  VI配置

```c
//tegra210-camera-rbpcv2-dual-imx219.dtsi
//platform/t210/porg/kernel-dts/porg-platforms/tegra210-camera-rbpcv2-dual-imx219.dtsi  
#include <dt-bindings/media/camera.h>
#include <dt-bindings/platform/t210/t210.h>

/ {
  host1x {
    vi_base: vi {
      num-channels = <2>;
      ports {
        #address-cells = <1>;
        #size-cells = <0>;
        vi_port0: port@0 {
          reg = <0>;
          rbpcv2_imx219_vi_in0: endpoint {
            port-index = <0>;
            bus-width = <2>;
            remote-endpoint = <&rbpcv2_imx219_csi_out0>;
          };
        };
        vi_port1: port@1 {
          reg = <1>;
          rbpcv2_imx219_vi_in1: endpoint {
            port-index = <4>;
            bus-width = <2>;
            remote-endpoint = <&rbpcv2_imx219_csi_out1>;
          };
        };
      };
    };

    csi_base: nvcsi { //摄像头的CSI接口描述
      num-channels = <2>;  //通道数2（可接2个csi摄像头）
      #address-cells = <1>;
      #size-cells = <0>;
      csi_chan0: channel@0 { //对应CSI0 接口 (通道0: 接摄像头1)
        reg = <0>;
        ports {
          #address-cells = <1>;
          #size-cells = <0>;
          csi_chan0_port0: port@0 { //对应CSI0_D0_N/P  的数据端口一
            reg = <0>;
            rbpcv2_imx219_csi_in0: endpoint@0 {
              port-index = <0>;
              bus-width = <2>;
              remote-endpoint = <&rbpcv2_imx219_dual_out0>;
            };
          };
          csi_chan0_port1: port@1 {  //对应CSI0_D1_N/P  的数据端口二
            reg = <1>;
            rbpcv2_imx219_csi_out0: endpoint@1 {
              remote-endpoint = <&rbpcv2_imx219_vi_in0>;
            };
          };
        };
      };
      csi_chan1: channel@1 { //对应CSI2 接口(通道1：接摄像头2)
        reg = <1>;
        ...
      };
    };
  };

  cam_i2cmux {  //摄像头的I2C接口描述(两个摄像头复用一个i2c)
    i2c_0: i2c@0 { //0号i2c总线
      imx219_cam0: rbpcv2_imx219_a@10 {
        compatible = "nvidia,imx219";
        /* I2C device address */
        reg = <0x10>;    //imx219的 I2C 从机地址  -> 该0号i2c总线上挂的i2c设备(从机的id)

        /* V4L2 device node location */
        devnode = "video0";  //创建的设备文件名  /dev/video0

        /* Physical dimensions of sensor */
        physical_w = "3.680";
        physical_h = "2.760";

        sensor_model = "imx219";

        use_sensor_mode_id = "true";

        //英伟达特有的，为支持其摄像头软件栈而定义的多个模式

        mode0 { /* IMX219_MODE_3264x2464_21FPS  模式0的配置：分辨率3264*2464  帧速：21帧每秒*/ 
          mclk_khz = "24000";
          num_lanes = "2";
          tegra_sinterface = "serial_a";
          phy_mode = "DPHY";
          discontinuous_clk = "yes";
          dpcm_enable = "false";
          cil_settletime = "0";

          active_w = "3264";
          active_h = "2464";
          pixel_t = "bayer_rggb"; //像素格式  bayer_rggb
          readout_orientation = "90";
          line_length = "3448";
          inherent_gain = "1";
          mclk_multiplier = "9.33";
          pix_clk_hz = "182400000";

          gain_factor = "16";
          framerate_factor = "1000000";
          exposure_factor = "1000000";
          min_gain_val = "16"; /* 1.00x */
          max_gain_val = "170"; /* 10.66x */
          step_gain_val = "1";
          default_gain = "16"; /* 1.00x */
          min_hdr_ratio = "1";
          max_hdr_ratio = "1";
          min_framerate = "2000000"; /* 2.0 fps */
          max_framerate = "21000000"; /* 21.0 fps */
          step_framerate = "1";
          default_framerate = "21000000"; /* 21.0 fps */
          min_exp_time = "13"; /* us */
          max_exp_time = "683709"; /* us */
          step_exp_time = "1";
          default_exp_time = "2495"; /* us */

          embedded_metadata_height = "2";
        };

        ports {
          #address-cells = <1>;
          #size-cells = <0>;

          port@0 {
            reg = <0>;
            rbpcv2_imx219_dual_out0: endpoint {
              port-index = <0>;
              bus-width = <2>;
              remote-endpoint = <&rbpcv2_imx219_csi_in0>;
            };
          };
        };
      };
    };
    i2c_1: i2c@1 { //1号i2c总线
      imx219_cam1: rbpcv2_imx219_e@10 {
        compatible = "nvidia,imx219";
        /* I2C device address */
        reg = <0x10>;  //imx219的 I2C 从机地址

        /* V4L2 device node location */
        devnode = "video1";  //创建的设备文件名  /dev/video1
         ...
      };
    };
  };

  lens_imx219@RBPCV2 {
    min_focus_distance = "0.0";
    hyper_focal = "0.0";
    focal_length = "3.04";
    f_number = "2.0";
    aperture = "0.0";
  };
};
```

###### (4)SOC多媒体的总线接口

```c
//tegra210-soc-base.dtsi SOC描述

compatible = "nvidia,tegra210";
interrupt-parent = <&lic>; //设置父中断节点是 lic
#address-cells = <2>;  //设置子节点"reg"属性的 首地址 占2个单元格数 (1个cell单元 有32位)
                       //解析见内核源码 early_init_dt_scan_root
#size-cells = <2>;     //设置子节点"reg"属性的 长度大小 占2个单元格数
                       //子节点会继承属性设置， 如果有同名的，则会覆盖
host1x@50000000 { //主机控制器: 图形 视频和显示的控制器(见手册 的CHAPTER 14: HOST SUBSYSTEM)
    compatible = "nvidia,tegra210-host1x", "simple-bus";
    reg = <0x0 0x50000000 0x0 0x00034000>;
    interrupts = <GIC_SPI 65 IRQ_TYPE_LEVEL_HIGH>, /*中断源属性: 域名(0:spi 1:ppi) + 中断索引+ 触发方式 */
             <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>; /* general */
    clocks = <&tegra_car TEGRA210_CLK_HOST1X>; //时钟源设置
    clock-names = "host1x";
    resets = <&tegra_car 28>;  //复位源设置
    reset-names = "host1x";

    #address-cells = <2>;
    #size-cells = <2>;
    //ranges属性：父子地址空间的映射转换  <子总线地址， 父总线地址,长度>
    ranges = <0x0 0x54000000 0x0 0x54000000 0x0 0x01000000>; 
    vi@54080000 {//视频输入节点(详见 31.4 VGP (GPIO) Interface)
        compatible = "nvidia,tegra210-vi";
        reg = <0x0 0x54080000 0x0 0x00040000>;  //首地址+ 长度 (详见2.1 System Address Map  的 VI)
        interrupts = <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>;
        status = "disabled"; //禁用状态
    };
    
    vic@54340000 {//视频图像合成器（见CHAPTER 15: VIDEO IMAGE COMPOSITOR (VIC))
        compatible = "nvidia,tegra210-vic";
        reg = <0x0 0x54340000 0x0 0x00040000>;
        status = "disabled";          
    };
    
    nvdec@54480000 {//视频解码
        compatible = "nvidia,tegra210-nvdec";
        reg = <0x0 0x54480000 0x0 0x00040000>;
        status = "disabled";
    };

    nvenc@544c0000 {//视频编码
        compatible = "nvidia,tegra210-nvenc";
        reg = <0x0 0x544c0000 0x0 0x00040000>;
        status = "disabled";
    };       
    dsi@54400000 {//显示串行接口（见   CHAPTER 26: DISPLAY INTERFACES: MIPI-DSI）-> 接LCD屏
        compatible = "nvidia,tegra210-dsi";
        reg = <0x0 0x54400000 0x0 0x00040000>;
        clocks = <&tegra_car TEGRA210_CLK_DSIB>,
             <&tegra_car TEGRA210_CLK_DSIBLP>,
             <&tegra_car TEGRA210_CLK_PLL_D_OUT0>;
        clock-names = "dsi", "lp", "parent";
        resets = <&tegra_car 82>;
        reset-names = "dsi";
        power-domains = <&pd_sor>;
        nvidia,mipi-calibrate = <&mipi 0x300>; /* DSIC & DSID pads */

        status = "disabled";

        #address-cells = <1>;
        #size-cells = <0>;
    };         
    dpaux: dpaux@545c0000 { //图像显示接口的辅助通道: DP接口(DisplayPort)是一种图像显示接口,AUX 是辅助通道      
    };
    i2c7: i2c@546c0000 { //I2C的描述（接CSI摄像头的i2c7)
        #address-cells = <1>;
        #size-cells = <0>;
        compatible = "nvidia,tegra210-vii2c";
        reg = <0x0 0x546C0000 0x0 0x00034000>;
        iommus = <&smmu TEGRA_SWGROUP_VII2C>;
        interrupts = <0 17 0x04>;
        scl-gpio = <&gpio TEGRA_GPIO(S, 2) 0>; //scl的管脚描述为 GPIO S 2 对应 CAM_I2C_SCL
        sda-gpio = <&gpio TEGRA_GPIO(S, 3) 0>;
        status = "disabled";
        clocks = <&tegra_car TEGRA210_CLK_VI_I2C>,
            <&tegra_car TEGRA210_CLK_I2CSLOW>,
            <&tegra_car TEGRA210_CLK_HOST1X>;
        clock-names = "vii2c", "i2cslow", "host1x";
        resets = <&tegra_car 208>;
        reset-names = "vii2c";
        clock-frequency = <400000>;
    };
          
}
```

###### (5)摄像头的管脚复用

```c
  cam_i2c_scl_ps2 { 
      nvidia,pins = "cam_i2c_scl_ps2";
      nvidia,function = "i2cvi";
      nvidia,pull = <TEGRA_PIN_PULL_NONE>;
      nvidia,tristate = <TEGRA_PIN_DISABLE>;
      nvidia,enable-input = <TEGRA_PIN_ENABLE>;
      nvidia,io-high-voltage = <TEGRA_PIN_ENABLE>;
  };

  cam_i2c_sda_ps3 { 
      nvidia,pins = "cam_i2c_sda_ps3";
      nvidia,function = "i2cvi";
      nvidia,pull = <TEGRA_PIN_PULL_NONE>;
      nvidia,tristate = <TEGRA_PIN_DISABLE>;
      nvidia,enable-input = <TEGRA_PIN_ENABLE>;
      nvidia,io-high-voltage = <TEGRA_PIN_ENABLE>;
  };

  cam1_mclk_ps0 {
      nvidia,pins = "cam1_mclk_ps0";
      nvidia,function = "extperiph3";
      nvidia,pull = <TEGRA_PIN_PULL_NONE>;
      nvidia,tristate = <TEGRA_PIN_DISABLE>;
      nvidia,enable-input = <TEGRA_PIN_DISABLE>;
  };

  cam2_mclk_ps1 {
      nvidia,pins = "cam2_mclk_ps1";
      nvidia,function = "extperiph3";
      nvidia,pull = <TEGRA_PIN_PULL_NONE>;
      nvidia,tristate = <TEGRA_PIN_DISABLE>;
      nvidia,enable-input = <TEGRA_PIN_DISABLE>;
  };


  cam1_pwdn_ps7 { //第一个摄像头的电源控制脚
      nvidia,pins = "cam1_pwdn_ps7";
      nvidia,function = "rsvd1";
      nvidia,pull = <TEGRA_PIN_PULL_NONE>;
      nvidia,tristate = <TEGRA_PIN_DISABLE>;
      nvidia,enable-input = <TEGRA_PIN_DISABLE>;
  };

  cam2_pwdn_pt0 { //第二个摄像头的电源控制脚
      nvidia,pins = "cam2_pwdn_pt0";
      nvidia,function = "rsvd1";
      nvidia,pull = <TEGRA_PIN_PULL_NONE>;
      nvidia,tristate = <TEGRA_PIN_DISABLE>;
      nvidia,enable-input = <TEGRA_PIN_DISABLE>;
  };
```

##### ⑤VI模块源码切入

![vi视频输入](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\vi视频输入.png)

###### (1)定义设备类

```c
//nvidia/drivers/media/platform/tegra/vi/vi.c  VI视频输入模块
static struct vi *tegra_vi;
```

```c
//nvidia/include/media/vi.h   VI对象定义(vi数据+ csi设备+ 多媒体控制器）
//vi设备对象的定义： 数据 + csi设备 + 控制器  
struct vi {
    struct tegra_vi_data *data;   //vi数据
    struct tegra_mc_vi mc_vi;     //vi的多媒体控制器
    struct tegra_csi_device csi;  //csi设备
} 
```

```c
{//nvidia/include/media/csi.h  csi对象定义(device> channel >  ports > lanes )
//csi设备定义: 属性（数据+通道+端口）+ 操作
struct tegra_csi_device {
    struct camera_common_data s_data[6]; //摄像头数据
    struct tegra_csi_channel *tpg_start;  //csi通道（每个通道对应一个csi排线接摄像头)    
    struct tegra_csi_port *ports; //csi端口(通道下有多个端口)
    struct media_pad *pads;  //media 上对硬件设备端口抽象
    const struct tpg_frmfmt *tpg_frmfmt_table;  //帧率格式表
    const struct tegra_csi_fops *fops;  //csi设备的文件操作
}

//csi通道定义（每个通道对应一个csi排线接摄像头)
struct tegra_csi_channel { 
    struct media_pad *pads; /*硬件设备端口抽象
        entity：硬件设备模块抽象（类比芯片）
        pad：硬件设备端口抽象（类比芯片上的管脚）
        link：硬件设备的连接抽象，link 的两端是 pad（管脚之间的连线）
        */
    struct media_pipeline pipe; //多媒体管线（动态调整 meida 数据和设备拓扑)
    struct v4l2_subdev *sensor_sd; //关联
    struct tegra_csi_device *csi; //属于 csi设备
    struct tegra_csi_port *ports; //csi的端口（tegra上个1通道下有2个端口，见设备树和芯片手册)
    struct camera_common_data *s_data; //摄像头数据
};

//csi端口定义
struct tegra_csi_port {
    void __iomem *pixel_parser;
    void __iomem *cil;
    void __iomem *tpg;

    u32 csi_port;  //csi端口号
    u32 stream_id; //视频流id号 
    u32 virtual_channel_id;  //虚拟通道id(对应pipeline)

    /* One pair of sink/source pad has one format */
    struct v4l2_mbus_framefmt format;
    const struct tegra_video_format *core_format; //视频格式
    unsigned int lanes; //通路数（一个通道有多个端口，端口下有多个通路）
    unsigned int framerate; //帧率
    unsigned int h_blank;
    unsigned int v_blank;
};


//csi设备的文件操作定义 
struct tegra_csi_fops {
    int (*csi_power_on)(struct tegra_csi_device *csi); //开启csi
    int (*csi_power_off)(struct tegra_csi_device *csi);
    int (*csi_start_streaming)(struct tegra_csi_channel *chan, //启动csi的视频采集
        int port_idx);
    void (*csi_stop_streaming)(struct tegra_csi_channel *chan,
        int port_idx);
    void (*csi_override_format)(struct tegra_csi_channel *chan,
        int port_idx);
    int (*csi_error_recover)(struct tegra_csi_channel *chan, int port_idx);
    int (*mipical)(struct tegra_csi_channel *chan);
    int (*hw_init)(struct tegra_csi_device *csi); //csi设备的硬件初始化
};

}

{//nvidia/include/media/mc_common.h
//vi的多媒体控制器定义
struct tegra_mc_vi {
    struct vi *vi;  //视频输入对象
    struct v4l2_device v4l2_dev;    //v4l2设备
    struct media_device media_dev; //多媒体设备
    struct nvhost_device_data *ndata; //英伟达主机侧的数据
    unsigned int num_channels; //通道数
    unsigned int num_subdevs; //video子设备树

    struct tegra_csi_device *csi; //csi设备
    struct tegra_channel *tpg_start;  //开始的数据通道

    struct v4l2_ctrl_handler ctrl_handler;  //v4l2控制处理的跟踪
    struct v4l2_ctrl *pattern; //v4l2控制方式

    const struct tegra_vi_fops *fops;  //vi对象的文件操作
}

//通道对象的定义
struct tegra_channel {
    struct video_device *video;  //关联 视频设备
    struct media_pad pad;  //media 上对硬件设备端口抽象
    struct media_pipeline pipe; //media管线
    struct tegra_mc_vi *vi; //属于  vi的多媒体控制器
    struct v4l2_subdev *subdev[MAX_SUBDEVICES];  //拥有的v4l2_subdev数组
    struct v4l2_ctrl_handler ctrl_handler;
    struct v4l2_pix_format format;  //v4l2的像素格式
    const struct tegra_video_format *fmtinfo; //视频格式信息
}


//vi对象的文件操作定义
struct tegra_vi_fops {
    int (*vi_power_on)(struct tegra_channel *chan); //vi开机
    void (*vi_power_off)(struct tegra_channel *chan);
    int (*vi_start_streaming)(struct vb2_queue *vq, u32 count); //vi启动视频采集
    int (*vi_stop_streaming)(struct vb2_queue *vq);
    int (*vi_setup_queue)(struct tegra_channel *chan,
            unsigned int *nbuffers);
    int (*vi_error_recover)(struct tegra_channel *chan, bool queue_error);
    int (*vi_add_ctrls)(struct tegra_channel *chan);
    void (*vi_init_video_formats)(struct tegra_channel *chan);
    long (*vi_default_ioctl)(struct file *file, void *fh,
            bool use_prio, unsigned int cmd, void *arg);
    int (*vi_mfi_work)(struct tegra_mc_vi *vi, int port);
    void (*vi_stride_align)(unsigned int *bpl);
};
}
```

###### (2)设备树匹配检测

```c
static struct of_device_id tegra_vi_of_match[] = { 
    { .compatible = "nvidia,tegra210-vi", /* 匹配设备树
        vscode搜索
          vi {
    			compatible = "nvidia,tegra210-vi", "simple-bus";
    			power-domains = <&ve_pd>;
    			reg = <0x0 0x54080000 0x0 0x40000>;
    			interrupts = <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>;
    			iommus = <&smmu TEGRA_SWGROUP_VI>;
    			status = "disabled";
    			clocks = <&tegra_car TEGRA210_CLK_VI_V4L2_CBUS>,
    				 <&tegra_car TEGRA210_CLK_CSI>,
    				 <&tegra_car TEGRA210_CLK_CILAB>,
    				 <&tegra_car TEGRA210_CLK_CILCD>,
    				 <&tegra_car TEGRA210_CLK_CILE>,
    				 <&tegra_car TEGRA210_CLK_VI_I2C>,
    				 <&tegra_car TEGRA210_CLK_I2CSLOW>,
    				 <&tegra_car TEGRA210_CLK_PLL_D>,
    				 <&tegra_car TEGRA210_CLK_PLL_D_DSI_OUT>;
    			clock-names = "vi", "csi", "cilab", "cilcd",
    					"cile", "vii2c", "i2cslow",
    					"pll_d", "pll_d_dsi_out";
    			resets = <&tegra_car 20>;
    			reset-names = "vi";
    			#address-cells = <1>;
    			#size-cells = <0>;
    		};
      */
        .data = (struct tegra_t210_vi_data *)&t21_vi_data },
    { },
};
  
static struct platform_driver vi_driver = {
    .probe = vi_probe,
    .driver = {
        .name = "vi",
		    .pm = &nvhost_module_pm_ops,        
        .of_match_table = tegra_vi_of_match,
    }
};

static struct of_device_id tegra_vi_domain_match[] = {
	{.compatible = "nvidia,tegra210-ve-pd", /*匹配设备树
	  用vscode 搜索匹配的 设备树节点(因偏门的字符串用sourceinsith或vim 都不好用)  -> 右键 -> 在文件夹中查找 
	  soc/t210/kernel-dts/tegra210-soc/tegra210-soc-power-domain.dtsi
	  ve_pd: ve-pd {
			compatible = "nvidia,tegra210-ve-pd";
			is_off;
			#power-domain-cells = <0>;
			power-domains = <&host1x_pd>;
			partition-id = <TEGRA210_POWER_DOMAIN_VENC>;  打开VENC(视频编码)模块的电源开关的ID号
		};


  	power-domain {
  		compatible = "tegra-power-domains";

  		host1x_pd: host1x-pd {
  			compatible = "nvidia,tegra210-host1x-pd";
  			is_off;
  			host1x;
  			#power-domain-cells = <0>;
  		};
  	}	
	  */
	 .data = (struct nvhost_device_data *)&t21_vi_info},
	{},
	
};

static int __init vi_init(void)
{
    //英伟达图像显示主机领域的初始化
    nvhost_domain_init(tegra_vi_domain_match);  
    return platform_driver_register(&vi_driver);
}
late_initcall(vi_init); //内核初始化默认自动加载该模块
```



###### (3)探测初始化1

```
//三: 探测初始化: 分配空间 + 初始化 + 注册勾连 

//探测初始化: 分配空间 + 赋初值 + 注册勾连
static int vi_probe(struct platform_device *dev) 
{
    match = of_match_device(tegra_vi_of_match, &dev->dev);  //从设备树获取 vi数据信息
    
    tegra_csi_media_controller_init(&tegra_vi->csi, dev);  //csi 多媒体控制器的初始化
    
    tegra_vi_media_controller_init(&tegra_vi->mc_vi, dev); //vi 多媒体控制器的初始化

    tegra_camera_device_register(&vi_info, tegra_vi);  //摄像头 设备的注册
} 

勾连模块化  //每个对象就像情报站点， 它由个注册函数，负责和上家联系。
 
{//勾连构建过程: 逆向反推 通过注册，实现回调指针勾连
late_initcall(vi_init)  -> vi_probe -> tegra_vi_media_controller_init ->tegra_vi_graph_init -> tegra_vi_graph_notify_complete //关键函数:完成全部子设备的注册

//初始化vi里video设备: 勾连 v4l2应用层 ioctl(fd, VIDIOC_STREAMON, &type) 和底层的驱动 
tegra_channel_init_video -> tegra_channel_fops -> tegra_channel_ioctl_ops -> vb2_ioctl_streamon -> v4l2_subdev_call -> v4l2sd_stream -> imx219_start_streaming

//注册video设备（即生成 dev/video0，勾连v4l2_fops等操作）-> 支持v4l2应用层 open(/dev/video0)等操作
video_register_device ->__video_register_device 

//注册video子设备(勾连video_device v4l2_device 和 v4l2_subdev_fops) ->  使得v4l2的应用层操作，能最终调用到v4l2_subdev_fops
v4l2_device_register_subdev_nodes 


}  

```



###### (4)探测初始之注册勾连

```c
//探测初始化: 分配空间 + 赋初值 + 注册勾连
static int vi_probe(struct platform_device *dev) 
{
    match = of_match_device(tegra_vi_of_match, &dev->dev);  //从设备树获取 vi数据信息
    
    tegra_csi_media_controller_init(&tegra_vi->csi, dev);  //csi 多媒体控制器的初始化
    
    tegra_vi_media_controller_init(&tegra_vi->mc_vi, dev); //vi 多媒体控制器的初始化

    tegra_camera_device_register(&vi_info, tegra_vi);  //摄像头 设备的注册
} 

{//nvidia/drivers/media/platform/tegra/camera/csi/csi.c   csi设备的控制

//csi 多媒体控制器的初始化 
int tegra_csi_media_controller_init(struct tegra_csi_device *csi,
				    struct platform_device *pdev)
{
   //解析csi的设备树 " nvcsi"
  csi_parse_dt(csi, pdev);

  //遍历初始化所有 csi通道
	if (csi->num_channels > 0) {
		ret = tegra_csi_channels_init(csi);
	}  
	
	//初始化csi设备
	tegra_csi_init(csi, pdev);
  
}  
  
}


{//nvidia/drivers/media/platform/tegra/camera/vi/mc_common.c 多媒体 控制


int tegra_vi_v4l2_init(struct tegra_mc_vi *vi)
{
  media_device_init(&vi->media_dev); //初始化VI 内的media_device
  media_device_register(&vi->media_dev); //注册media_dev -> 完成与上层 media_device控制子系统  勾连
  v4l2_device_register(vi->dev, &vi->v4l2_dev); //注册v4l2_dev -> 完成与上层 v4l2_device控制子系统 的勾连
}


//vi 多媒体控制器的初始化
int tegra_vi_media_controller_init(struct tegra_mc_vi *mc_vi,
                   struct platform_device *pdev)
{
    
   err = vi_parse_dt(mc_vi, pdev);  //解析vi的设备树 
   err = tegra_vi_v4l2_init(mc_vi); //vi里v4l2的初始化 -> 完成与v4l2框架的勾连
   err = tegra_vi_channels_init(mc_vi); //vi里的通道初始化
   /* Setup media links between VI and external sensor subdev. */
   err = tegra_vi_graph_init(mc_vi); //vi内的子设备图的初始化
   
} 
EXPORT_SYMBOL(tegra_vi_media_controller_init);  
} 
  
{//nvidia/drivers/media/platform/tegra/camera/vi/graph.c   视频输入设备图 的构建 -> 完成全部子设备的注册
  
//VI设备图谱的构建（通知完成全部子设备的注册)
static int tegra_vi_graph_notify_complete(struct v4l2_async_notifier *notifier)
{
    struct tegra_channel *chan =
        container_of(notifier, struct tegra_channel, notifier);
    struct tegra_vi_graph_entity *entity;
    int ret;

    dev_dbg(chan->vi->dev, "notify complete, all subdevs registered\n");

    /* Allocate video_device */
     //初始化vi里video设备 （勾连v4l2_ioctl_ops）   ->  支持v4l2应用层 ioctl(fd, VIDIOC_S_FMT, &fmt) 等的调用(逆向反推)  
    ret = tegra_channel_init_video(chan);


    //注册video设备（即生成 dev/video0，勾连v4l2_fops等操作）-> 支持v4l2应用层 open(/dev/video0)等操作
    ret = video_register_device(chan->video, VFL_TYPE_GRABBER, -1); 
    
   /* Create links for every entity. */
    list_for_each_entry(entity, &chan->entities, list) {
        if (entity->entity != NULL) {
            ret = tegra_vi_graph_build_one(chan, entity);
            if (ret < 0)
                goto graph_error;
        }
    }

    /* Create links for channels */
    ret = tegra_vi_graph_build_links(chan);


   //注册video子设备(勾连video_device v4l2_device 和 v4l2_subdev_fops) ->  使得v4l2的应用层操作，能最终调用到v4l2_subdev_fops
    ret = v4l2_device_register_subdev_nodes(&chan->vi->v4l2_dev);

    chan->link_status++;

    return 0;

}

int tegra_vi_graph_init(struct tegra_mc_vi *vi)
{
  struct tegra_channel *chan;
  chan->notifier.complete = tegra_vi_graph_notify_complete;
}

//nvidia/drivers/media/platform/tegra/camera/vi/channel.c 勾连 v4l2_file_operations  v4l2_ioctl_ops 和 v4l2_subdev_ops  ->  v4l2应用的ioctl操作，和v4l2子设备硬件的操作关联起来

//通道的ioctl 命令操作(querycap qbuf 等) -> 对接v4l2应用层ioctrl命令操作
static const struct v4l2_ioctl_ops tegra_channel_ioctl_ops = { 
    .vidioc_querycap        = tegra_channel_querycap,    //查询设备的能力  
    .vidioc_g_fmt_vid_cap   = tegra_channel_get_format,
    .vidioc_s_fmt_vid_cap   = tegra_channel_set_format,  //设置通道的格式
    .vidioc_reqbufs         = vb2_ioctl_reqbufs,
    .vidioc_querybuf        = vb2_ioctl_querybuf,
    .vidioc_qbuf            = vb2_ioctl_qbuf,
    .vidioc_dqbuf           = vb2_ioctl_dqbuf,
    .vidioc_streamon        = vb2_ioctl_streamon, /*开启视频采集（跟踪到 驱动的硬件访问）
      -> vb2_streamon -> vb2_core_streamon -> vb2_start_streaming -> 	ret = call_qop(q, start_streaming  ) -> 
      .start_streaming = tegra_channel_start_streaming -> vi_start_streaming -> .vi_start_streaming = vi2_channel_start_streaming
      -> tegra_channel_set_stream ->  v4l2_subdev_call(sd, video, s_stream, on)  ->   驱动 tegracam_v4l2.c  里的  .s_stream   = v4l2sd_stream  
      ->   sensor_ops->start_streaming(tc_dev);    -> 对接 imx219.c驱动里的  .start_streaming = imx219_start_streaming, //开启视频流采集
    
    #define v4l2_subdev_call(sd, o, f, args...)             \
    (!(sd) ? -ENODEV : (((sd)->ops->o && (sd)->ops->o->f) ? \
        (sd)->ops->o->f((sd), ##args) : -ENOIOCTLCMD))
        
        转换后为，   sd->ops ->video-> s_stream
        
        
    struct v4l2_subdev {
    	const struct v4l2_subdev_ops *ops;
    };
    struct v4l2_subdev_ops {
    	const struct v4l2_subdev_video_ops	*video;
    	const struct v4l2_subdev_sensor_ops	*sensor;
    };            
    struct v4l2_subdev_video_ops {
    	int (*s_stream)(struct v4l2_subdev *sd, int enable);
    }
               
     */
}


//通道队列的操作
static const struct vb2_ops tegra_channel_queue_qops = {
    .queue_setup = tegra_channel_queue_setup,
    .start_streaming = tegra_channel_start_streaming, 
};



//通道的文件操作 -> 对接v4l2应用层文件操作(open read ioctl)
static const struct v4l2_file_operations tegra_channel_fops = {
    .owner      = THIS_MODULE,
    .unlocked_ioctl = video_ioctl2,  //勾连 ioctl 和 v4l2_ioctl_ops
    {//例：ioctl(fd, VIDIOC_STREAMON, &type) 调用过程
      //tegra_channel_fops -> video_ioctl2 -> __video_do_ioctl -> v4l2_ioctls ->  v4l_streamon -> vidioc_querybuf     
      static struct v4l2_ioctl_info v4l2_ioctls[] = { //查询ioctl的命令表
        IOCTL_INFO_FNC(VIDIOC_QUERYCAP, v4l_querycap, v4l_print_querycap, 0),  
        IOCTL_INFO_FNC(VIDIOC_G_FMT, v4l_g_fmt, v4l_print_format, 0),
        IOCTL_INFO_FNC(VIDIOC_QBUF, v4l_qbuf, v4l_print_buffer, INFO_FL_QUEUE), 
        IOCTL_INFO_FNC(VIDIOC_DQBUF, v4l_dqbuf, v4l_print_buffer, INFO_FL_QUEUE),
        IOCTL_INFO_FNC(VIDIOC_STREAMON, v4l_streamon, v4l_print_buftype, INFO_FL_PRIO | INFO_FL_QUEUE),
        ...
      }  
      
      static int v4l_streamon(const struct v4l2_ioctl_ops *ops,
				struct file *file, void *fh, void *arg)
      {
      	return ops->vidioc_streamon(file, fh, *(unsigned int *)arg); //回调驱动里的实现  tegra_channel_ioctl_ops的 vb2_ioctl_streamon
      }

      struct v4l2_ioctl_ops {
      	int (*vidioc_streamon)(struct file *file, void *fh,
			       enum v4l2_buf_type i);
      }
      
    }

    .open       = tegra_channel_open,
    .release    = tegra_channel_close,
    .read       = vb2_fop_read,
    .poll       = vb2_fop_poll,
    .mmap       = vb2_fop_mmap,
};


int tegra_channel_set_stream(struct tegra_channel *chan, bool on)
{
  v4l2_subdev_call(sd, video, s_stream, on);//调用子对象的操作
     //s_stream  对接  驱动 tegracam_v4l2.c  里的  .s_stream   = v4l2sd_stream
}


//初始化vi里video设备
int tegra_channel_init_video(struct tegra_channel *chan)
{
    struct tegra_mc_vi *vi = chan->vi;
    int ret = 0;

    chan->video = video_device_alloc(); //分配video设备的空间

    //初始化 多媒体实体 
    /* Initialize the media entity... */
    chan->pad.flags = MEDIA_PAD_FL_SINK;
    ret = tegra_media_entity_init(&chan->video->entity, 1,
                    &chan->pad, false, false);

    /* init control handler */
    ret = v4l2_ctrl_handler_init(&chan->ctrl_handler, MAX_CID_CONTROLS);

    /* init video node... */
    chan->video->fops = &tegra_channel_fops;   //勾连 通道的文件操作(open read ioctl) -> 对接v4l2应用层文件操作(open read ioctl)
    chan->video->v4l2_dev = &vi->v4l2_dev;
    chan->video->queue = &chan->queue;
    snprintf(chan->video->name, sizeof(chan->video->name), "%s-%s-%u",
        dev_name(vi->dev), chan->pg_mode ? "tpg" : "output",
        chan->pg_mode ? (chan->id - vi->num_channels) : chan->port[0]);
    chan->video->ioctl_ops = &tegra_channel_ioctl_ops;  //勾连 通道的ioctl 命令操作(querycap qbuf 等) -> 对接v4l2应用层ioctrl命令操作
    video_set_drvdata(chan->video, chan);

    return ret;
}

```

###### (5)实现需要的文件操作

```
static struct tegra_t210_vi_data t21_vi_data = { 
    .info = (struct nvhost_device_data *)&t21_vi_info,
    .vi_fops = &vi2_fops,  //vi模块的操作控制
    .csi_fops = &csi2_fops, //支持2路 csi接口的摄像头控制
};

```

```
//nvidia/drivers/media/platform/tegra/camera/vi/vi2_fops.c  vi控制操作
struct tegra_vi_fops vi2_fops = {
    .vi_power_on = vi2_power_on,
    .vi_power_off = vi2_power_off,
    .vi_start_streaming = vi2_channel_start_streaming,
    .vi_stop_streaming = vi2_channel_stop_streaming,
    .vi_setup_queue = vi2_channel_setup_queue,

    .vi_init_video_formats = vi2_init_video_formats,
};
  
```

```
{//nvidia/drivers/media/platform/tegra/camera/csi/csi2_fops.c  csi控制操作 -> 正式从摄像头获取数据（被vi模块调用）
static int csi2_start_streaming(struct tegra_csi_channel *chan, int port_idx)
{
    /* CSI pixel parser registers setup */
    pp_write(port, TEGRA_CSI_PIXEL_STREAM_PP_COMMAND,
            (0xF << CSI_PP_START_MARKER_FRAME_MAX_OFFSET) |
            CSI_PP_SINGLE_SHOT_ENABLE | CSI_PP_RST);
    pp_write(port, TEGRA_CSI_PIXEL_PARSER_INTERRUPT_MASK, 0x0);
} 
  
//MIPI 的CSI2 协议的设置
static int csi2_mipi_cal(struct tegra_csi_channel *chan)
{
  unsigned int lanes, num_ports, val, csi_port;
  struct tegra_csi_port *port;
  struct tegra_csi_device *csi = chan->csi;
  int err;

  lanes = 0;
  num_ports = 0;

  err = v4l2_subdev_call(chan->sensor_sd, core, s_power, true);


  err = v4l2_subdev_call(chan->sensor_sd, video, s_stream, true);

  while (num_ports < chan->numports) {
    port = &chan->ports[num_ports];
    csi_port = port->csi_port;
    dev_dbg(csi->dev, "Calibrate csi port %d\n", csi_port);
      val = ((csi_port & 0x1) == NVCSI_PORT_A) ?
        CSI_A_PHY_CIL_ENABLE | CSI_B_PHY_CIL_NOP
        : CSI_B_PHY_CIL_ENABLE | CSI_A_PHY_CIL_NOP;
      csi_write(chan, TEGRA_CSI_PHY_CIL_COMMAND, val,

    num_ports++;
  }


  err = tegra_mipi_calibration(lanes);

  err = v4l2_subdev_call(chan->sensor_sd, video, s_stream, false);


  return 0;
}
  
  
const struct tegra_csi_fops csi2_fops = { 
    .csi_power_on = csi2_power_on,
    .csi_power_off = csi2_power_off,
    .csi_start_streaming = csi2_start_streaming,
    .csi_stop_streaming = csi2_stop_streaming,
    .mipical = csi2_mipi_cal, //设置MIPI 的CSI2 协议
    .hw_init = csi2_hw_init, //csi2的硬件初始化
};
EXPORT_SYMBOL(csi2_fops); 
} 
```



##### ⑥函数调用结构体关系图 自动绘制

```

```



###### (1)安装软件

```
$ sudo -H pip3 install filetype pygraphviz  /*
  error: command 'x86_64-linux-gnu-gcc' failed with exit status 1
  要先安装库
  $ sudo apt-get install build-essential python3-dev libssl-dev libffi-dev libxml2 libxml2-dev libxslt1-dev zlib1g-dev
  $ sudo apt-get install python3-pygraphviz
 */   
$ sudo apt-get install doxygen-latex doxygen-doc doxygen-gui graphviz
$ doxywizard //doxygen启动
配置
```



###### (2)内核源码 中实际编译的文件列表

```
原理 /*内核每个源文件编译会生成 .xx.o.cmd 的隐藏文件，里面包含了依赖源文件和头文件列表
      如imx219.c对应的 .imx219.o.cmd  里
     3  source_drivers/media/i2c/imx219.o := /home/yhai/bsp/git_tegra/linux/vender/nvidia/drivers/media/i2c/imx219.c
     4
     5 deps_drivers/media/i2c/imx219.o := \
      6     $(wildcard include/config/of.h) \
      7   include/linux/slab.h \
      8     $(wildcard include/config/debug/slab.h) \
      9     $(wildcard include/config/debug/objects.h) \

      */   


```

```
//kernel_src_dump.py
#!/usr/bin/env python
import sys
import os
import os.path
import time
import re
import argparse
 
KERNEL_BASE  = os.getcwd()
KERNEL_SRC = os.getcwd()
KERNEL_OUT = os.getcwd()

def kernel_depfile_2_flist(depfile, filelist) :
    fobj = open(depfile, "r")
    for line in fobj :
        txt = line.strip()
        if 0 == len(txt) :
            continue
        if txt.startswith("cmd_") :
            continue
        if txt.startswith("deps_") :
            continue
        if txt.startswith("$(deps_") :
            continue
        if txt.endswith(".o)") :
            continue
 
        if txt.endswith(" \\") :
            txt = txt[:-2]
 
        if txt.startswith("$(wildcard ") and txt.endswith(")"):
            idx_start = len("$(wildcard ")
            tmp_txt = txt[idx_start : -1]
            pre_path = KERNEL_OUT
            relative_path = os.path.join(pre_path, tmp_txt)
            abs_path = relative_path
            if KERNEL_BASE in KERNEL_OUT:
                pre_path = KERNEL_OUT[len(KERNEL_BASE) + 1::]
                relative_path = os.path.join(pre_path, tmp_txt)
                abs_path = os.path.join(KERNEL_BASE, relative_path)
            if os.path.exists(abs_path) : 
                print(relative_path)
                pass
        else :
            tmp_txt = re.sub(r".*:= *","", txt)
            if len(tmp_txt) == 0 :
                continue
            if tmp_txt.find(KERNEL_BASE) >= 0 :
                idx_start = len(KERNEL_BASE) + 1
                full_txt = tmp_txt[idx_start:]
            else :
                if tmp_txt.endswith(".mod.c") :
                    continue
                pre_path = KERNEL_OUT
                relative_path = os.path.join(pre_path, tmp_txt)
                if KERNEL_BASE in KERNEL_OUT:
                    pre_path = KERNEL_OUT[len(KERNEL_BASE) + 1::]
                    relative_path = os.path.join(pre_path, tmp_txt)
                full_txt = relative_path
            print(full_txt)
    fobj.close()
 
def depfile_find(path, callback, args):
    for root, dirs, files in os.walk(path):  # path 为根目录
        for fname in files :
            rootname = str(root)
            if rootname.startswith(os.path.join(KERNEL_OUT,"scripts")) :
                continue
            full_name = os.path.join(rootname, fname)
            matchObj = re.search( r'.*\.o\.cmd', full_name, re.M|re.I)
            if matchObj :
                # print(full_name)
                # print("callback type: %s" % str(type(callback)))
                # if "<class 'function'>" == str(type(callback)) :
                # py_ver = sys.version[:3]
                if "function" in str(type(callback)) :
                    callback(full_name, args)
 
if __name__ == '__main__' :
    path = KERNEL_OUT
    depfile_find(path, kernel_depfile_2_flist, "undefined")
    # dump all files in path: include/generated
    path = os.path.join(KERNEL_OUT,"include", "generated")
    for root, dirs, files in os.walk(path):  # path 为根目录
        rootname = str(root)
        for fname in files :
            full_txt = os.path.join(rootname, fname)
            strip_path = full_txt
            if KERNEL_BASE in full_txt:
                strip_path = full_txt[len(KERNEL_BASE) + 1::]
            print(strip_path)
```

```
$ cd ~/kernel-4.9
$ python3 kernel_dump.py -s $PWD | uniq -u |sort |uniq> kernel.txt  //递归查找子目录中 .o.cmd文件提取出依赖的源文件和头文件列表
          //加sort 和uniq 是去除隔行重复的行
          //运行时间要几分钟，可以进到drivers/media下测试 内容少比较快

```



###### (3)source Insight里只导入参与编译的源文件 

```
注 //通过文件列表文件导入，或让源码只包含实际编译过的，
   // 精确导入后，你跳转或搜索，就不用再选择了
{//kernel.txt
arch/arm64/crypto/aes-ce-ccm-core.S
arch/arm64/crypto/aes-ce-ccm-glue.c
arch/arm64/crypto/aes-ce-cipher-core.c
arch/arm64/crypto/aes-ce-cipher-glue.c
arch/arm64/crypto/aes-ce.S
arch/arm64/crypto/aes-ce-setkey.h
...
/home/yhai/bsp/Linux_for_Tegra/source/public/kernel/nvgpu/drivers/gpu/nvgpu/boardobj/boardobj.c
/home/yhai/bsp/Linux_for_Tegra/source/public/kernel/nvgpu/drivers/gpu/nvgpu/boardobj/boardobjgrp.c
/home/yhai/bsp/Linux_for_Tegra/source/public/kernel/nvgpu/drivers/gpu/nvgpu/boardobj/boardobjgrp_e255.c
/home/yhai/bsp/Linux_for_Tegra/source/public/kernel/nvgpu/drivers/gpu/nvgpu/boardobj/boardobjgrp_e255.h
...
include/acpi/acbuffer.h
include/acpi/acconfig.h
include/acpi/acexcep.h

}

{//kernel_win10.txt
C:\share\public_sources\kernel\kernel-4.9\arch\arm64\crypto\aes-ce-ccm-core.S
C:\share\public_sources\kernel\kernel-4.9\arch\arm64\crypto\aes-ce-ccm-glue.c
C:\share\public_sources\kernel\kernel-4.9\arch\arm64\crypto\aes-ce-cipher-core.c
C:\share\public_sources\kernel\kernel-4.9\arch\arm64\crypto\aes-ce-cipher-glue.c
C:\share\public_sources\kernel\kernel-4.9\arch\arm64\crypto\aes-ce.S
C:\share\public_sources\kernel\kernel-4.9\arch\arm64\crypto\aes-ce-setkey.h
...
C:\share\public_sources\kernel\nvgpu\drivers\gpu\nvgpu\boardobj\boardobj.c
C:\share\public_sources\kernel\nvgpu\drivers\gpu\nvgpu\boardobj\boardobjgrp.c
C:\share\public_sources\kernel\nvgpu\drivers\gpu\nvgpu\boardobj\boardobjgrp_e255.c
C:\share\public_sources\kernel\nvgpu\drivers\gpu\nvgpu\boardobj\boardobjgrp_e255.h
... 
C:\share\public_sources\kernel\kernel-4.9\include\acpi\acbuffer.h
C:\share\public_sources\kernel\kernel-4.9\include\acpi\acconfig.h
C:\share\public_sources\kernel\kernel-4.9\include\acpi\acexcep.h
}

//路径替换 把kernel.txt 里linux的文件路径变成 win10下的文件路径 kernel_win10.txt
用utrledit打开 kernel.txt -> ctrl +r -> 查找什么填 /  替换为 \ -> 全部替换   //把linux文件路径的\ 变为win10路径/    
ctrl +r ->  查找什么填 \home\yhai\bsp\Linux_for_Tegra\source\public\kernel\ 替换为  C:\share\public_sources\kernel\ -> 全部替换

把  arch\arm64\ 等没有内核目录的前面添加 C:\share\public_sources\kernel\kernel-4.9\ 
鼠标放在顶格 -> alt+c ->shift+ 向下键 选择你要改变的行  -> 输入 %\ ->  
ctrl +r -> 查找什么填  %\ 替换为 C:\share\public_sources\kernel\kernel-4.9\    -> 全部替换  //指定内核目录


//把转换后的 kernel_win10.txt 的文件 导入到source insight 的新工程中
 P项目 -> 新项目 ->新项目名 填为 linux_map -> 确定 ->确定 -> 从列表加入 -> 选择  kernel_win10.txt  文件 -> 右键 选同步文件 -> 确定
```



###### (4)按文件列表拷贝文件

```
$ python3 copy_file.py kernel.txt  //运行，可成功看到生成out目录，里面文件有拷贝过来，

//copy_file.py
# coding:utf-8 
import os 
import sys 
import shutil
 
src_kernel = '/home/yhai/kernel-4.9/'  
out_dir = 'out/' 
abs_src_dir = '/home/yhai/bsp/Linux_for_Tegra/source/public/kernel'  #//绝对路径源文件的目录
self_out_dir = 'out/self_nvidia/'  #//英伟达独立出来的目录 

def copyFile(src):
  #//检测是绝对路径吗
  if os.path.isabs(src): 
    #//是则，只需指定的输出目录(如从/home/yhai/bsp/main.c  变为out/self_nvidia/main.c) 
    dst = src.replace(abs_src_dir, self_out_dir) 
  else:
    #//不是则，需修改源目录，和目的目录
    dst = os.path.join(out_dir, src)    #//目的文件 是在前面添加目录(如 arch/main.c 变为 out/arch/main.c)
    src = os.path.join(src_kernel, src) #//源文件 变为绝对路径（如从 arch/main.c 变为 /home/yhai/kernel-4.9/arch/main.c)
  
  #//查看转换后路径 正确否  
  #print("src abs path:"+src)
  #print("dst abs path:"+dst)
  
  dirs = os.path.dirname(dst) #//获取目的文件的目录路径
  #print("dst dir:"+dirs) 
  if not(os.path.exists(dirs) and os.path.isdir(dirs)):   #//如果目录路径不存在，则创建目录（包括子集目录) 
    try:  #//一定要加try，避免异常时，就退出了，
      os.makedirs(dirs)  
    except OSError:  #//异常时，只打印信息提示，不退出
      print("dirs already exists"+dirs)    
    
  try:  
    shutil.copyfile(src,dst) #//拷贝文件
    print("copy ok:"+src)
  except: #//异常时，只打印信息提示，不退出
    print("copy err:"+src)   
    
    
if __name__ == '__main__': 
  if len(sys.argv) != 2: #//检测参数个数,不满足报错
    print('params must be 1,the params is the file of contain the list of cutAndPastFile List')
    exit(0) 

  file_pa1 = sys.argv[1]  #//第二个参数，为包含文件列表的文件
  f = open(file_pa1, 'r') #//打开文件
  lst_file = f.readlines() #//读取文件里的一行（一行就是一个待拷贝的文件路径）   
  f.close()  

  for filename in lst_file:   #//循环读取文件的每一行，进行拷贝
    filename = filename.replace('\n', '') #//去除换行符的影响
    if filename != '': 
      copyFile(filename)  #//拷贝指定文件
  
//测试文件kernel.txt
arch/arm64/crypto/aes-ce-ccm-glue.c
/home/yhai/bsp/Linux_for_Tegra/source/public/kernel/nvgpu/drivers/gpu/nvgpu/gk20a/gk20a.c
arch/arm64/include/../../../arch/arm/mach-tegra/iomap.h

```



###### (5)选择需要的构建图谱 

```
在 out目录基础上根据需要，尽量减少文件 //整个内核太大了，根据编译的文件列表，选择你需要的内容去生成

out目录是实际编译中用到文件，结合目录下的内容，和soure insight里跳转，
结合你实际开发，如摄像头驱动imx219跟踪，尽量减少无关文件 ，再用doxygen去生成图谱  //注意：内核太大，直接用doxygen生成是搞不定的。直接卡死

out_camera 
 |--init
 |--include/media
 |--include/video
 |--self_nvidia/nvidia/include/media
 |--self_nvidia/nvidia/include/video
 |--self_nvidia/nvidia/drivers/media
 |--self_nvidia/nvidia/drivers/video 

将 out_camera做源码目录 用doxygen构建图谱
```



#### 5、公司实际项目开发背景

![ADAS感知相机](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\ADAS感知相机.png)

##### ①公司实际开发背景

![公司实际开发背景](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\公司实际开发背景.png)

##### ②监控项目

![监控项目](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\监控项目.png)

##### ③CSI传输协议

![CSI传输协议](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\CSI传输协议.png)

##### ④VR相机感知相机

![UR感知相机](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\UR感知相机.png)

##### ⑤全志瑞芯微板子了解

![全志瑞芯微板子了解](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\全志瑞芯微板子了解.png)

##### ⑥实际开发背景之启动优化

![实际开发背景之启动优化](D:\Adminstrator_Copy\Desktop\Linux\易化AI_截图\实际开发背景之启动优化.png)

#### 6、CSI摄像头移植

```
OV5647 摄像头移植 //选择OV5647 摄像头（树莓派500万像素）,因使用广泛，价格便宜 13元

常见mipi sensor //sony：imx317、imx477、imx274、imx258、imx286、imx307、imx385等
                //ov：ov2718、ov12895、ov2710等
                //ar： ar0238  
                //国产：gc1024、gc1034..

如何移植 //1. 内核源码里有该驱动否， 
        //2. 无则找第三方源码，移植过啦 (如树莓派 https://github.com/raspberrypi/linux)
        //3. 结对对比

相近芯片结对 //jetson 不支持ov5647  但已支持 ov5693 -> 可在ov5693驱动和设备树基础上移植支持ov5647
平台结对 //jetson 不支持ov5647 但树莓派已支持 jeston树莓派都支持imx219 -> 可对比看驱动和设备树的差异            
设备树结对 //jetson ok的 ov5693和imx219的设备树  -> 对比后知道那些是针对不同摄像头，需改的部分

资料 链接：https://pan.baidu.com/s/1XtnuyDwmEPdDRj4r5N6ltw 
提取码：yhai
```



##### ①下载源码

```c
//下载树莓派内核源码 ,里面有ov5647.c      
$ git clone  --depth=1 https://github.com/raspberrypi/linux.git  //加--depth=1 只下载最新版本，避免下载历史版本太大了
$ mv linux linux_raspberry
$ cd  linux_raspberry
$ make bcm2709_defconfig // bcm2711_defconfig bcmrpi_defconfig 等都是树莓派开发板的配置
$ vim arch/arm/boot/dts/cm2709-rpi-2-b.dts  //对应的设备树 
$ vim arch/arm/boot/dts/overlays/ov5647-overlay.dts   //查找摄像头的设备树 ov5647.c -> 设备树 "ov5647" -> vscode 在 arm/boot/dts 文件夹里查找
```

##### ②编译文件修改

```c
// nvidia驱动力支持 OV5693 ，可参照它，修改文件
注 //因更改地方太大，且需反复调试，故要加git 版本管理。 
$ cd kernel-4.9
$ cp ~/bsp/linux_raspberry/drivers/media/i2c/ov5647.c   nvidia/drivers/media/i2c/
$ vim nvidia/drivers/media/i2c/Makefile /* 
 在 obj-$(CONFIG_VIDEO_OV5693) += ov5693.o 后面仿照添加
    obj-$(CONFIG_VIDEO_OV5647) += ov5647.o
*/  
$ vim nvidia/drivers/media/i2c/Kconfig /*
  仿照  config VIDEO_OV5693 在后面添加

  config VIDEO_OV5647
      tristate "OV5647 camera sensor support"
      depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
      ---help---
        This is a Video4Linux2 sensor-level driver for the OmniVision
        OV5647 camera.

        To compile this driver as a module, choose M here: the module
        will be called ov5647.
  */

```

##### ③源码内容修改

```c
根据平台（nvidia）来修改
//难点1：对比ov5647.c   ov5693.c 和imx219.c 发现差异巨大，要根据英伟达的摄像头平台框架 去改。
//---对比jetson 和树莓派下imx219的不同 （用beyond compare对比，发现对比意义不大，整个对象框架，英伟达全部改了，必须理解框架，才知道它怎么改的)
//---在ov5693基础上修改
$ cd  nvidia/drivers/media/i2c 
$ mv ov5647.c ov5647_org.c  //备份原始的（源于树莓派内核）
$ cp ov5693.c ov5647.c   //基于 ov5693.c 来修改
$ cp ov5693_mode_tbls.h ov5647_mode_tbls.h
$ vim ov5647.c /*
:%s/5693/5647/g   把5693字符串都替换为5647
 */

$vim  ov5647_mode_tbls.h  /*
:%s/5693/5647/g
*/

$vim  nvidia/include/media/ov5647.h /*
:%s/5693/5647/g
 */
$vim  nvidia/include/uapi/media/ov5647.h /*
:%s/5693/5647/g
 */  
$vim nvidia/include/trace/events/ov5647.h /*
:%s/5693/5647/g
*/
```

##### ④设备树的修改

```c
//难点2：设备树更改，可借鉴imx219和ov5693设备树（ 两个设备树对比，就知道那些变化是对摄像头的的，那些是平台的不需要改）
//        ov5693 见hardware里 tegra210-jetson-e-base-p2595-0000-a00.dts  tegra210-camera-e3326-a00.dtsi 

{//tegra210-p3448-0002-p3449-0000-b00.dts
在 #include "porg-platforms/tegra210-porg-camera-rbpcv2-dual-imx219.dtsi" 下添加
#include "porg-platforms/tegra210-porg-camera-rbpcv2-dual-ov5647.dtsi"  //仿照dual-imx219.dtsi

}
```

```c
{//tegra210-porg-camera-rbpcv2-dual-ov5647.dtsi  摄像头I2C复用
/*仿照 tegra210-porg-camera-rbpcv2-dual-imx219.dtsi 
$ cd hardware/nvidia/platform/t210/porg/kernel-dts/porg-platforms/
$ cp tegra210-porg-camera-rbpcv2-dual-imx219.dtsi tegra210-porg-camera-rbpcv2-dual-ov5647.dtsi
:%s/imx219/ov5647/g  把imx219都改为 ov5647
*/
#include "tegra210-camera-rbpcv2-dual-ov5647.dtsi" 
#define CAM1_PWDN       TEGRA_GPIO(S, 7)
#define CAM2_PWDN       TEGRA_GPIO(T, 0)
#define CAM_I2C_MUX TEGRA_GPIO(I, 0) // NFC_EN GPIO

/ {
    cam_i2cmux {
        compatible = "i2c-mux-gpio";
        #address-cells = <1>;
        #size-cells = <0>;
        mux-gpios = <&gpio CAM_I2C_MUX GPIO_ACTIVE_HIGH>;
        i2c-parent = <&i2c7>;
        i2c@0 {
            reg = <0>;
            #address-cells = <1>;
            #size-cells = <0>;
            rbpcv2_ov5647_a@10 {
                reset-gpios = <&gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;
            };
        };
        i2c@1 {
            reg = <1>;
            #address-cells = <1>;
            #size-cells = <0>;
            rbpcv2_ov5647_e@10 {
                reset-gpios = <&gpio CAM2_PWDN GPIO_ACTIVE_HIGH>;
            };
        };
    };

    gpio@6000d000 {
        camera-control-output-low {
            gpio-hog;
            output-low;
            gpios = < CAM1_PWDN 0  CAM2_PWDN 0>;
            label = "cam1-pwdn", "cam2-pwdn";
        };
    };
};
 
  
}
```

```c
{//tegra210-camera-rbpcv2-dual-ov5647.dtsi  摄像头的I2C,CSI,VI配置
/*仿照 tegra210-camera-rbpcv2-dual-imx219.dtsi 
$ cd hardware/nvidia/platform/t210/porg/kernel-dts/porg-platforms/
$ cp tegra210-camera-rbpcv2-dual-imx219.dtsi tegra210-camera-rbpcv2-dual-ov5647.dtsi
:%s/imx219/ov5647/g  把imx219都改为 ov5647
*/  

/*更改芯片的i2c从机地址
  compatible = "nvidia,ov5647";
  //I2C device address 
  reg = <0x36>;   //更改为ov5647 芯片的i2c从机地址（从0x10改为0x36)
                  //由原树莓派 arm/boot/dts/overlays/ov5647-overlay.dts里  compatible = "ovti,ov5647"; 里得到 reg = <0x36>;
*/

/*摄像头模式设置(  参考 ok的ov5693的摄像头模式配置)
  hardware/nvidia/platform/t210/jetson/kernel-dts/jetson-platforms/tegra210-camera-e3326-a00.dtsi
把 ov5693_c@36 里mode0 mode1 等拷贝过来后，先测一下，后面还要调整（因ov5693和ov5647 虽相近但毕竟不太一样）
*/



}
```

```c
{//...arm/boot/dts/overlays/ov5647-overlay.dts  树莓派的借鉴，确认ov5647 的i2c id(如果没有参考，就要看ov5647的芯片手册了）
	compatible = "brcm,bcm2835";
			ov5647: ov5647@36 {
				compatible = "ovti,ov5647";
				reg = <0x36>;
				status = "okay";

  
}
```



##### ⑤调试目标1：读到OV5647的ID值 

```c
//调试目标1： 实现i2c能读到ov5647的ID值  -> 硬件基本没问题
$ make menuconfig
  <*> Multimedia support  --->  
      NVIDIA overlay Encoder ->
$ make -j4   
$ make dtbs
$ cp drivers/media/i2c/ov5647.ko  /nfs/rootfs
$ cp arch/arm64/boot/dts/tegra210-p3448-0002-p3449-0000-b00.dtb  /tftpboot/

//板子重启上电
# run distro_bootcmd //启动 官方ubuntu系统
$ scp arch/arm64/boot/Image yhbd@192.168.10.237:/home/yhbd/Image //传文件到板子
$ sudo service network-manager restart  //虚拟机里双网卡只能识别到一个时，重启网络就好了
//板子重启上电，快速按enter停下来  
//# setenv bootargs  root=/dev/nfs rw nfsroot=192.168.9.119:/nfs/rootfs,v3 console=ttyS0,115200 init=/linuxrc ip=192.168.9.9
//# setenv nfs_bootcmd pci enum \; pci \; ext4load mmc 1:1 0x84000000 /home/yhbd/Image \; tftp 0x83100000 tegra210-p3448-0002-p3449-0000-b00.dtb \; booti 0x84000000 - 83100000
//# saveenv
# run nfs_bootcmd  //能nfs挂载成功
    //可setenv bootcmd run nfs_bootcmd  设为自启动，方便调试
$ insmod  ov5647.ko  /*报错
[  222.306451] ov5647 7-0036: probing v4l2 sensor.
[  222.311160] ov5647 7-0036: Failed to find clocks
[  222.315822] ov5647 7-0036: unable to get platform data
[  222.320958] ov5647 7-0036: tegra camera driver registration failed
[  222.327210] ov5647: probe of 7-0036 failed with error -14


[  222.332694] ov5647 8-0036: probing v4l2 sensor.
[  222.337294] ov5647 8-0036: Failed to find clocks
[  222.341911] ov5647 8-0036: unable to get platform data
[  222.347049] ov5647 8-0036: tegra camera driver registration failed
[  222.353252] ov5647: probe of 8-0036 failed with error -14

注： 出现两次的原因是  由两个摄像头接口

先确定硬件有接好，树莓派的ov5647的摄像头有插好
 */
```

```c
{//用OK的imx219驱动读i2c设备的ID 
 imx219的是0x10 而5647的是0x36  
 先把imx219编译成模块,再改设备树为0x35

$ make menuconfig ->  / 搜如imx219搜索 ->  选M 编译成模块
$ make -j4
$ cp drivers/media/i2c/imx219.ko  /nfs/rootfs   

//板子重启上电
# run distro_bootcmd //启动 官方ubuntu系统
$ scp arch/arm64/boot/Image yhbd@192.168.10.237:/home/yhbd/Image //传文件到板子
//板子重启上电，快速按enter停下来 
# run nfs_bootcmd  //能nfs挂载成功
$ insmod  imx219.ko /*报错读识别，原因时0x10 id是imx219的，借用imx219的设备树，改为0x36看看，能否读到ov5647的id
 ====yhai: /home/yhai/bsp/Linux_for_Tegra/source/public/kernel/nvidia/drivers/media/i2c/imx219.c, imx219_probe,696 ---
[   89.889067] imx219 7-0010: tegracam sensor driver:imx219_v2.0.6
[   89.918931] tegra-vii2c 546c0000.i2c: no acknowledge from address 0x10
[   89.925797] imx219 7-0010: imx219_board_setup: error during i2c read probe (-121)
[   89.933425] imx219 7-0010: board setup failed
[   89.937870] imx219: probe of 7-0010 failed with error -121
[   89.943463] ====yhai: /home/yhai/bsp/Linux_for_Tegra/source/public/kernel/nvidia/drivers/media/i2c/imx219.c, imx219_probe,696 ---
[   89.955568] imx219 8-0010: tegracam sensor driver:imx219_v2.0.6
[   89.985300] tegra-vii2c 546c0000.i2c: no acknowledge from address 0x10
[   89.992120] imx219 8-0010: imx219_board_setup: error during i2c read probe (-121)
[   89.999660] imx219 8-0010: board setup failed
[   90.004062] imx219: probe of 8-0010 failed with error -121
   */

$ vim  tegra210-camera-rbpcv2-dual-imx219.dtsi //更改设备树里imx219的id 从0x10改为0x36
$ make dtbs
$ cp arch/arm64/boot/dts/tegra210-p3448-0002-p3449-0000-b00.dtb  /tftpboot/
重启板子
$ insmod  imx219.ko /*发现id能读到，证明用imx219的框架对 ov5647摄像头的i2c供电i2c读取是成功的
               ====yhai: /home/yhai/bsp/Linux_for_Tegra/source/public/kernel/nvidia/drivers/media/i2c/imx219.c, imx219_probe,696 ---
[   86.122765] imx219 7-0036: tegracam sensor driver:imx219_v2.0.6
[   86.153780] imx219 7-0036: imx219_board_setup: invalid sensor model id: 00
[   86.162440] ====yhai: /home/yhai/bsp/Linux_for_Tegra/source/public/kernel/nvidia/drivers/media/i2c/imx219.c, imx219_probe,696 ---
[   86.174566] imx219 8-0036: tegracam sensor driver:imx219_v2.0.6
[   86.204074] tegra-vii2c 546c0000.i2c: no acknowledge from address 0x36
[   86.210889] imx219 8-0036: imx219_board_setup: error during i2c read probe (-121)
[   86.218451] imx219 8-0036: board setup failed
[   86.222873] imx219: probe of 8-0036 failed with error -121
 插槽一的摄像头，没有报i2c 没有应答的错误了，但invalid sensor model id: 00 ，原因是芯片ID 的读取地址 不对
 插槽二的摄像头 没有接， 会报id没应答的错误
*/

摄像芯片ID的寄存器地址 //差linux_raspberry/drivers/media/i2c/ov5647.c 
       // 的#define OV5647_REG_CHIPID_H		0x300a   和#define OV5647_REG_CHIPID_L		0x300b
       //更改imx219.c 里     IMX219_MODEL_ID_ADDR_MSB 为0x300a   IMX219_MODEL_ID_ADDR_LSB为 0x300b
$ make dtbs
$ cp arch/arm64/boot/dts/tegra210-p3448-0002-p3449-0000-b00.dtb  /tftpboot/
重启板子
$ insmod  imx219.ko  /*成功读到芯片ID  5647   -> 确认ov5647硬件基本正常（电源，时钟等）
 insmod imx219.ko
[ 1765.703788] ====yhai: /home/yhai/bsp/Linux_for_Tegra/source/public/kernel/nvidia/drivers/media/i2c/imx219.c, imx219_probe,698 ---
[ 1765.716303] imx219 7-0036: tegracam sensor driver:imx219_v2.0.6
[ 1765.747431] imx219 7-0036: imx219_board_setup: invalid sensor model id: 5647  成功读到芯片ID
[ 1765.756498] ====yhai: /home/yhai/bsp/Linux_for_Tegra/source/public/kernel/nvidia/drivers/media/i2c/imx219.c, imx219_probe,698 ---
[ 1765.768632] imx219 8-0036: tegracam sensor driver:imx219_v2.0.6
[ 1765.798266] tegra-vii2c 546c0000.i2c: no acknowledge from address 0x36
[ 1765.805089] imx219 8-0036: imx219_board_setup: error during i2c read probe (-121)
[ 1765.812651] imx219 8-0036: board setup failed
[ 1765.817086] imx219: probe of 8-0036 failed with error -121

*/
 
}

摇摆 //是基于ov5693.c 还是imx219.c来改
```

##### ⑥调试目标2：能查询设备信息

```c
//调试目标2: 生成/dev/video0，能查询到摄像头的格式信息
 
借鉴 imx219，更改ov5647.c 让它能正常识别ID

 里用imx219_parse_dt 替代   ov5647_parse_dt
  
$ cp drivers/media/i2c/ov5647.ko  /nfs/rootfs 
$ insmod ov5647.ko /*发现什么信息都没有
  原因是设备树生成时它动态匹配了imx219的配置
  故需 tegra210-p3448-0002-p3449-0000-b00.dts里屏蔽调，重新更新dtb才行
  //#include "porg-platforms/tegra210-porg-camera-rbpcv2-dual-imx219.dtsi 

  更新dtb后再插入显示信息
[   29.936951] ov5647 7-0036: probing v4l2 sensor.
[   29.941955] ov5647 7-0036: unable to get clock cam_mclk1
[   29.947277] ov5647 7-0036: unable to power get  电源不能获得， 原因是需用 imx219_power_get 替代  imx5647_power_get
[   29.951724] ov5647 7-0036: tegra camera driver registration failed
[   29.957979] ov5647: probe of 7-0036 failed with error -14
 
 */

用 imx219_power_get 替代  imx5647_power_get后
 
$ insmod ov5647.ko /*报错
 811.851918] ov5647 7-0036: probing v4l2 sensor.
[  811.856918] ov5647 7-0036: camera_common_regulator_get vana ERR: ffffffffffffffed  原因是设备树里要把avdd等屏蔽调，它采用的是外部独立供电
[  811.864415] ov5647 7-0036: camera_common_regulator_get vif ERR: ffffffffffffffed
[  811.871807] ov5647 7-0036: ov5647_power_get: unable to get regulator(s)
[  811.878458] ov5647 7-0036: unable to power get
[  811.882903] ov5647 7-0036: tegra camera driver registration failed
[  811.889155] ov5647: probe of 7-0036 failed with error -14
 */
把 tegra210-camera-rbpcv2-dual-ov5647.dts 里avdd-reg = "vana";和 iovdd-reg = "vif"; 屏蔽掉
$ insmod ov5647.ko /*发现注册成功了
 113.566000] ov5647 7-0036: probing v4l2 sensor.
[  113.571206] ov5647 7-0036: tegracam sensor driver:ov5647_v2.0.6
[  114.440239] vi 54080000.vi: subdev ov5647 7-0036 bound
 */
$ ls -l /dev/video0  //发现设备有生成，表示基本ov5467框架构建成功（但里面各种功能和参数都未测试过，还有很多问题）
$ ./a.out /* 运行前面的 v4l2的应用程序 采集图片，发现报错
Driver Info:
  Driver Name:tegra-video
  Card Name:vi-output, ov5647 7-0036
  Bus info:platform:54080000.vi:0
Device capabilities:
  support video capture
  support streaming i/o
List device support video format:
  { pixelformat = ''BG10'', description = ''10-bit Bayer BGBG/GRGR'' }
Stream Format Informations:
 type: 1
 width: 2592
 height: 1944
 pixelformat: BG10
 field: 1
 bytesperline: 5184
 sizeimage: 10077696
 colorspace: 8
 priv: -17970434
 raw_date:

camera->start: start capture  发现不能采集图片超时（正常的，你还有很多参数等未更改，你基于的是5693来改的，不是5647）
[  181.814507] video4linux video0: frame start syncpt timeout!0
[  182.022594] video4linux video0: frame start syncpt timeout!0
[  182.230591] video4linux video0: frame start syncpt timeout!0
[  182.438590] video4linux video0: frame start syncpt timeout!0

 */
```



##### ⑦调试目标3：能采集图片（难点）

```c
关键点 // 能采集图片意味你各个参数都必须正确，且要符合英伟达摄像头的平台框架，
       //可借鉴 树莓派ov5647.c 和设备树,英伟达的imx219.c ov5693.c 设备树。 
       //和相关的芯片手册，电路图。 需静下心来把 源码框架 差异搞清楚，慢慢一步步来，急不得
```

###### (1)调试跟踪：从报错信息切入

```
camera->start: start capture  //发现不能采集图片超时（正常的，你还有很多参数等未更改，你基于的是5693来改的，不是5647）
[  181.814507] video4linux video0: frame start syncpt timeout!0

//SourceInsight -> ctrl+shift+f -> 搜  frame start syncpt  
Vi2_fops.c (self_nvidia\nvidia\drivers\media\platform\tegra\camera\vi):				"frame start syncpt timeout!%d\n", index);

```

###### (2)找OK版本参考 -》确保 硬件 代码 参数正确

```
如何确定 硬件连接是对的

写的代码没问题

参数设置是正确的

```

##### ⑧找OK版本做对比

###### (1)以OK的树莓派4B做参考(支持OV5647)

###### (2)排除硬件问题：电源，时钟

###### (3)对比平台差异( 树莓派 VS 英伟达)

###### (4)对比设备差异（OV5647 对比 OV5693)

##### ⑨调试跟踪

###### (1)从报错信息切入

###### (2)打开驱动调试开关

###### (3)函数调用追踪

###### (4)读写寄存器列表

##### ⑩移植

```
参考树莓派的，移植过来
参考 https://docs.nvidia.com/jetson/archives/l4t-archived/l4t-3261/index.html 里相机开发 -> 感器软件驱动程序编程 -> 调试技巧  
找OK的版本做对比  
```

###### 默认模式

```
  ov5647_2592x1944_10bpp 的内容替换 mode_2592x1944里内容，
注 //但原来的首尾 附加信息先保留，后面再调整，因可能是英伟达框架特有的。
  
static const ov5647_reg mode_2592x1944[] = { 
   {OV5647_TABLE_WAIT_MS, OV5647_WAIT_MS}, //首
	{0x0100, 0x00},
	{0x0103, 0x01},
	{0x3034, 0x1a},
	{0x3035, 0x21},
	{0x3036, 0x69},
	{0x303c, 0x11},
	{0x3106, 0xf5},
	{0x3821, 0x00},
	{0x3820, 0x00},
	{0x3827, 0xec},
	{0x370c, 0x03},
	{0x3612, 0x5b},
	{0x3618, 0x04},
	{0x5000, 0x06},
	{0x5002, 0x41},
	{0x5003, 0x08},
	{0x5a00, 0x08},
	{0x3000, 0x00},
	{0x3001, 0x00},
	{0x3002, 0x00},
	{0x3016, 0x08},
	{0x3017, 0xe0},
	{0x3018, 0x44},
	{0x301c, 0xf8},
	{0x301d, 0xf0},
	{0x3a18, 0x00},
	{0x3a19, 0xf8},
	{0x3c01, 0x80},
	{0x3b07, 0x0c},
	{0x380c, 0x0b},
	{0x380d, 0x1c},
	{0x3814, 0x11},
	{0x3815, 0x11},
	{0x3708, 0x64},
	{0x3709, 0x12},
	{0x3808, 0x0a},
	{0x3809, 0x20},
	{0x380a, 0x07},
	{0x380b, 0x98},
	{0x3800, 0x00},
	{0x3801, 0x00},
	{0x3802, 0x00},
	{0x3803, 0x00},
	{0x3804, 0x0a},
	{0x3805, 0x3f},
	{0x3806, 0x07},
	{0x3807, 0xa3},
	{0x3811, 0x10},
	{0x3813, 0x06},
	{0x3630, 0x2e},
	{0x3632, 0xe2},
	{0x3633, 0x23},
	{0x3634, 0x44},
	{0x3636, 0x06},
	{0x3620, 0x64},
	{0x3621, 0xe0},
	{0x3600, 0x37},
	{0x3704, 0xa0},
	{0x3703, 0x5a},
	{0x3715, 0x78},
	{0x3717, 0x01},
	{0x3731, 0x02},
	{0x370b, 0x60},
	{0x3705, 0x1a},
	{0x3f05, 0x02},
	{0x3f06, 0x10},
	{0x3f01, 0x0a},
	{0x3a08, 0x01},
	{0x3a09, 0x28},
	{0x3a0a, 0x00},
	{0x3a0b, 0xf6},
	{0x3a0d, 0x08},
	{0x3a0e, 0x06},
	{0x3a0f, 0x58},
	{0x3a10, 0x50},
	{0x3a1b, 0x58},
	{0x3a1e, 0x50},
	{0x3a11, 0x60},
	{0x3a1f, 0x28},
	{0x4001, 0x02},
	{0x4004, 0x04},
	{0x4000, 0x09},
	{0x4837, 0x19},
	{0x4800, 0x24},
	{0x3503, 0x03},
	{0x0100, 0x01},
  {OV5647_TABLE_END, 0x0000}  //尾
};  
  
$ make modules
$ cp drivers/media/i2c/ov5647.ko /nfs/rootfs
# insmoe ov5647.ko
# ./a.out/* 发现能启动视频采集图片（注：只是能采集，但图片格式是否正确，后面还需调整）
Driver Info:
  Driver Name:tegra-video
  Card Name:vi-output, ov5647 7-0036
  Bus info:platform:54080000.vi:0
Device capabilities:
  support video capture
  support streaming i/o
List device support video format:
  { pixelformat = ''BG10'', description = ''10-bit Bayer BGBG/GRGR'' }
Stream Format Informations:
 type: 1
 width: 2592
 height: 1944
 pixelformat: BG10
 field: 1
 bytesperline: 5184
 sizeimage: 10077696
 colorspace: 8
 priv: -17970434
 raw_date:

camera->start: start capture
camera->stop: stop capture
camera->exit: camera exit

*/

```



##### ⑩-1 调试目标4: 显示摄像头监控效果

###### (1)借用官方镜像调试（有完整的上层库）

###### (2)应用层测试（先用OK的摄像头）

#### 7、调试深入

##### ①设备树更改：插槽一支持 IMX219,插槽二支持 OV5647

```
/或能同时兼容imx219和ov5647的设备树，能根据不同设备自动加载对应驱动   -> 避免频繁更改  
基石  //有一完全OK的软硬件环境，做交叉验证
      //run distro_bootcmd  插槽1：ok的imx219  

$ cd ~/kernel-4.9/hardware/nvidia/platform/t210/porg/kernel-dts/porg-platforms/
$ cp tegra210-porg-camera-rbpcv2-dual-imx219.dtsi   yh-dual-camera.dtsi  
$ cp tegra210-camera-rbpcv2-dual-imx219.dtsi  yh-camera-imx219-and-ov5647.dtsi 
```

###### (1)入口

```
//tegra210-p3448-0000-p3449-0000-b00.dts
//#include "porg-platforms/tegra210-porg-camera-rbpcv2-dual-imx219.dtsi"
//#include "porg-platforms/tegra210-porg-camera-rbpcv2-dual-ov5647.dtsi"  

#include "porg-platforms/yh_dual-camera.dtsi"  //仿照前面的,,imx219.dtsi 实现 插槽1：OK的imx219  插槽2: ov5647
   
```



###### (2)硬件接口设置

```
#define CAM1_PWDN       TEGRA_GPIO(S, 7)
#define CAM2_PWDN       TEGRA_GPIO(T, 0)
#define CAM_I2C_MUX TEGRA_GPIO(I, 0) // NFC_EN GPIO

/ {
    cam_i2cmux {
        compatible = "i2c-mux-gpio";
        #address-cells = <1>;
        #size-cells = <0>;
        mux-gpios = <&gpio CAM_I2C_MUX GPIO_ACTIVE_HIGH>;
        i2c-parent = <&i2c7>;
        i2c@0 {
            reg = <0>;
            #address-cells = <1>;
            #size-cells = <0>;
            //first csi is imx219
            rbpcv2_imx219_a@10 {
                reset-gpios = <&gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;
            };  
        };  
        i2c@1 {
            reg = <1>;
            #address-cells = <1>;
            #size-cells = <0>;
            //second csi is ov5647
            rbpcv2_ov5647_e@10 {
                reset-gpios = <&gpio CAM2_PWDN GPIO_ACTIVE_HIGH>;
            };
        };
    };

    gpio@6000d000 {
        camera-control-output-low {
            gpio-hog;
            output-low;
            gpios = < CAM1_PWDN 0  CAM2_PWDN 0>;
            label = "cam1-pwdn", "cam2-pwdn";
        };
    };
};
```



###### (3)芯片内部设置



###### (4)验证

```c
$ cp arch/arm64/boot/dts/tegra210-p3448-0000-p3449-0000-b00.dtb   /tftpboot    

重启板子
$ lsmod /* 查看驱动模块加载
  ov5647                 31320  0
  imx219                 17044  0

 */
$ dmesg|grep ov5647
$ dmesg|grep imx219
$ ls -l /dev/video0 //用于imx219
$ ls -l /dev/video1 //用于ov5647

```

##### ②寄存器查验:  动态读写寄存器

```
//芯片手册:  Camera  -> MIPI CSI  -> VI -> HOST1X
   
MIPI CSI //x4:  可接1个4通路的csi摄像头(如接多个，同时只能激活1个，分时复用)
         //2x2: 可接2个2通路的csi摄像头(同时使用)

VI  //可接 3个 MIPI CSI 模块（CSI1 CSI2 CSI3)  最多可接6个2x2的摄像头(CAM-A CAM-B ...CAM-F)
    //最多支持 6个数据源 ，6个Pixel Parser（像素解析通路，CSI-PPA CSI-PPB ....CSI-PPF)

```

###### (1)摄像头寄存器查验

###### (2)使用示例

###### (3)确认模式生效

###### (4)确认模式生效2

##### ③上层调用跟踪

###### (1)VI模块，启用视频采集的跟踪

###### (2)V4L2 应用线的跟踪

###### (3)BSP自定义的应用线的跟踪

#### 8、帧缓冲队列源码分析

##### ①对象定义：管理v4l2里所有数据缓冲区（视频帧）

###### (1)视频缓冲区队列

###### (2)视频缓冲区

###### (3)缓冲区队列的操作集

###### (4)缓冲区内存分配的操作集

##### ②入口

###### (1)入口1

###### (2)入口2

##### ③关联操作集

##### ④缓冲区核心处理(要考虑并发的互斥)

###### (1)初始化缓冲区队列

###### (2)申请视频的帧缓冲区

###### (3)缓冲区入队

###### (4)开启视频流

###### (5)出队,将填充满数据的缓存区给应用

###### (6)关闭视频流

#### 9、总结与挑战
